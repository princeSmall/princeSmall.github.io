<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>乐乐</title>
  <subtitle>Tong</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-24T08:19:29.430Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>TongLe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[iOS_排序算法]</title>
    <link href="http://yoursite.com/2017/11/24/iOS-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/11/24/iOS-排序算法/</id>
    <published>2017-11-24T06:36:37.000Z</published>
    <updated>2017-11-24T08:19:29.430Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客主要对快速排序，冒泡排序和简单选择排序进行改进，在时间处理上降低1/2。</p>
<h4 id="QuickSort-快速升序排序"><a href="#QuickSort-快速升序排序" class="headerlink" title="QuickSort - 快速升序排序"></a>QuickSort - 快速升序排序</h4><p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法</p>
<p><img src="/2017/11/24/iOS-排序算法/Quick.jpg" alt=""></p>
<ol>
<li>先调用改进算法QsortImprove使之基本有序</li>
<li><p>再用插入排序对基本有序序列排序</p>
<pre><code>+ (void)quickSort:(NSMutableArray *)array arrayCount:(int)c centerK:(int)k{
[self qsortImprove:array lowA:0 highB:c centerK:k];
for (int i = 1; i &lt;= c; i ++) {
int tmp = (int)[array[i] integerValue];
int j = i - 1;
while (tmp &lt; (int)[array[j] integerValue]) {
    array[j + 1] = array[j];
    j = j - 1;
}
array[j + 1] = [NSNumber numberWithInt:tmp];
   }
}
</code></pre></li>
<li><p>长度大于k时开始递归，k为指定的数</p>
</li>
<li><p>调用的PartitionArray 算法保持不变</p>
<pre><code>+(void)qsortImprove:(NSMutableArray *)array lowA:(int)a highB:(int)b centerK:(int)k{
if (b - a &gt; k) {
int privot = [self partitionArray:array lowA:a highB:b];
[self qsortImprove:array lowA:a highB:privot -1 centerK:k];
[self qsortImprove:array lowA:privot +1 highB:b centerK:k];
  }
}
</code></pre></li>
<li><p>基本有序</p>
<pre><code>+ (int)partitionArray:(NSMutableArray *)array lowA:(int)a highB:(int)b{
//    基准元素
 int privotKey = (int)array[a];
//     从表的两端交替地向中间扫描
while (a &lt; b) {

while (a &lt; b &amp;&amp; [array[b] integerValue] &gt;= privotKey) {
    b--;
    int tmp = (int)[array[a] integerValue];
    array[a] = array[b];
    array[b] = [NSNumber numberWithInt:tmp];
}
while (a &lt; b &amp;&amp; [array[a] integerValue] &lt;= privotKey) {
    a++;
    int tmp = (int)[array[a] integerValue];
    array[a] = array[b];
    array[b] = [NSNumber numberWithInt:tmp];
    }
  }
 return a;
}
</code></pre></li>
</ol>
<h4 id="BubbleSort-冒泡排序"><a href="#BubbleSort-冒泡排序" class="headerlink" title="BubbleSort - 冒泡排序"></a>BubbleSort - 冒泡排序</h4><p>对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。<br>传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。</p>
<p><img src="/2017/11/24/iOS-排序算法/Bubble.jpg" alt=""></p>
<pre><code>+(void)bubbleSort:(NSMutableArray *)array lowA:(int)low highB:(int)high{
int tmp,j;
while (low &lt; high) {
    for (j= low; j &lt; high; ++j) //正向冒泡,找到最大者
        if ([array[j] integerValue]&gt; [array[j+1] integerValue]) {
            tmp = (int)[array[j] integerValue];
            array[j]=array[j+1];
            array[j+1]=[NSNumber numberWithInt:tmp];
        }
    --high;                 //修改high值, 前移一位
    for ( j= high; j &gt; low; --j) //反向冒泡,找到最小者
        if ([array[j] integerValue]&lt;[array[j-1] integerValue]) {
            tmp = (int)[array[j] integerValue];
            array[j]=array[j-1];
            array[j-1]=[NSNumber numberWithInt:tmp];
        }
    ++low;//修改low值,后移一位
  }
}
</code></pre><h4 id="SelectSort-简单选择排序"><a href="#SelectSort-简单选择排序" class="headerlink" title="SelectSort - 简单选择排序"></a>SelectSort - 简单选择排序</h4><ol>
<li><p>在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；</p>
</li>
<li><p>然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。</p>
</li>
</ol>
<p><img src="/2017/11/24/iOS-排序算法/Select.jpg" alt=""></p>
<pre><code>+ (void)selectSort:(NSMutableArray *)array arrayCount:(int)n{
for (int i = 0; i &lt; n; i ++) {
    for (int j = i + 1; j &lt; n; j ++) {
        if ([array[i] integerValue] &gt; [array[j] integerValue]) {
            int temp = [array[i] intValue];
            array[i] = array[j];
            array[j] = [NSNumber numberWithInt:temp];
        }
    }
 }
}
</code></pre><h4 id="ComparatorSort-比较排序"><a href="#ComparatorSort-比较排序" class="headerlink" title="ComparatorSort - 比较排序"></a>ComparatorSort - 比较排序</h4><p>利用系统自带的方法比较排序</p>
<pre><code>+(NSArray *)ComparatorSort:(NSMutableArray *)array{

NSArray * arr = [array sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2)
{
    if ([obj1 integerValue] &gt; [obj2 integerValue]) {
        return (NSComparisonResult)NSOrderedDescending;
    }
    if ([obj1 integerValue] &lt; [obj2 integerValue]) {
        return (NSComparisonResult)NSOrderedAscending;
    }
    return (NSComparisonResult)NSOrderedSame;
}];
return arr;
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博客主要对快速排序，冒泡排序和简单选择排序进行改进，在时间处理上降低1/2。&lt;/p&gt;
&lt;h4 id=&quot;QuickSort-快速升序排序&quot;&gt;&lt;a href=&quot;#QuickSort-快速升序排序&quot; class=&quot;headerlink&quot; title=&quot;QuickSort - 
    
    </summary>
    
      <category term="OC" scheme="http://yoursite.com/categories/OC/"/>
    
    
  </entry>
  
  <entry>
    <title>[Animation_ViewAnimation应用]</title>
    <link href="http://yoursite.com/2017/11/22/Animation-ViewAnimation%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2017/11/22/Animation-ViewAnimation应用/</id>
    <published>2017-11-22T11:42:14.000Z</published>
    <updated>2017-11-22T12:48:31.993Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome:<a href="https://github.com/princeSmall/CellAnimation.git" target="_blank" rel="external">github地址</a></p>
<p>最近各式各样的动画也是被我玩坏了，今天直接拿来结合需求用。今天主要整理了UIView的动画方法，跟present，push不同，但又很相似，可以满足日常所需动画。话不多说，直接上码。</p>
<p><img src="/2017/11/22/Animation-ViewAnimation应用/AnimationView.gif" alt=""></p>
<h3 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h3><pre>
+(void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion;
duration : 动画时间
delay : 延迟时间
options : 动画的方式，so much...
animation : 需要执行的动作
completion : 完成后的方法，可以为空
</pre>

<h4 id="案例，登录注册的左移，右移和透明"><a href="#案例，登录注册的左移，右移和透明" class="headerlink" title="案例，登录注册的左移，右移和透明"></a>案例，登录注册的左移，右移和透明</h4><pre><code>[UIView animateWithDuration:1 animations:^{
    CGFloat x = self.nameTextField.frame.origin.x;
    x += Width - 40;
    self.nameTextField.alpha = 1.0;
    [self.nameTextField setFrame:CGRectMake(x, 100, Width - 80, 50)];
} completion:^(BOOL finished) {

}];
[UIView animateWithDuration:1 delay:0.5 options:(UIViewAnimationOptionCurveEaseInOut) animations:^{
    CGFloat x = self.passwordTextField.frame.origin.x;
    x -= Width - 40;
    self.passwordTextField.alpha = 1.0;
    [self.passwordTextField setFrame:CGRectMake(x, 200, Width - 80, 50)];
} completion:^(BOOL finished) {

}];
[UIView animateWithDuration:1 delay:1 options:(UIViewAnimationOptionCurveEaseInOut) animations:^{
    self.loginBtn.alpha =1.0;
    [self.loginBtn setTitle:@&quot;Login&quot; forState:UIControlStateNormal];
} completion:^(BOOL finished) {

}];

目前动画实现登录注册就好了
</code></pre><h3 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h3><pre>
+(void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^ __nullable)(void))animations completion:(void (^ __nullable)(BOOL finished))completion;
view : 需要变换的视图
duration : 动画的时间
options : 动画的方式， so much...
animation : 需要执行的动作
completion : 完成后的方法，可以为空
</pre>

<h4 id="案例，点击切换图片"><a href="#案例，点击切换图片" class="headerlink" title="案例，点击切换图片"></a>案例，点击切换图片</h4><pre><code>[UIView transitionWithView:cell.imageView duration:1 options:UIViewAnimationOptionTransitionFlipFromLeft animations:^{
    if ([cell.imageView.image isEqual:[UIImage imageNamed:@&quot;two&quot;]]) {
        cell.imageView.image = [UIImage imageNamed:@&quot;one&quot;];
    }else{
        cell.imageView.image = [UIImage imageNamed:@&quot;two&quot;];
    }
} completion:^(BOOL finished) {

}];

目前点击动画翻页就好了
</code></pre><h4 id="KeyFrame"><a href="#KeyFrame" class="headerlink" title="KeyFrame"></a>KeyFrame</h4><pre>
+(void)animateKeyframesWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewKeyframeAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion;
duration : 动画时间
delay : 延迟时间
options : 动画方式， so much...
animation : 需要执行的动作
completion : 完成后的方法，可以为空
</pre>

<h4 id="案例，移动画线"><a href="#案例，移动画线" class="headerlink" title="案例，移动画线"></a>案例，移动画线</h4><pre><code>[UIView animateKeyframesWithDuration:1 delay:0 options:(UIViewKeyframeAnimationOptionCalculationModeLinear) animations:^{
        CAShapeLayer * shapelayer = [CAShapeLayer layer];
        self.path = [UIBezierPath bezierPath];
        [self.path moveToPoint:CGPointMake(50, 200)];
        [self.path addLineToPoint:CGPointMake(200, 200)];
        [self.path addLineToPoint:CGPointMake(200, 350)];
        [self.path addLineToPoint:CGPointMake(350, 350)];
        shapelayer.path = self.path.CGPath;
        shapelayer.fillColor = [UIColor clearColor].CGColor;
        shapelayer.lineWidth = 4.0f;
        shapelayer.strokeColor = [UIColor redColor].CGColor;
        [self.view.layer addSublayer:shapelayer];
        CABasicAnimation *pathAnima = [CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;];
        pathAnima.duration = 3.0f;
        pathAnima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
        pathAnima.fromValue = [NSNumber numberWithFloat:0.0f];
        pathAnima.toValue = [NSNumber numberWithFloat:1.0f];
        pathAnima.fillMode = kCAFillModeForwards;
        pathAnima.removedOnCompletion = NO;
        [shapelayer addAnimation:pathAnima forKey:@&quot;strokeEndAnimation&quot;];
    } completion:^(BOOL finished) {      
    }];

目前一条移动的线条就好了
</code></pre><h3 id="炫酷的TableViewCell出场动画"><a href="#炫酷的TableViewCell出场动画" class="headerlink" title="炫酷的TableViewCell出场动画"></a>炫酷的TableViewCell出场动画</h3><p>这里只给出前几条，代码里已经全部封装好了</p>
<h4 id="Animation类，遍历改变alpha"><a href="#Animation类，遍历改变alpha" class="headerlink" title="Animation类，遍历改变alpha"></a>Animation类，遍历改变alpha</h4><pre><code>+(void)alphaAnimationWithTableView:(UITableView *)tableView {  
NSArray *cells = tableView.visibleCells;
for (int i = 0; i &lt; cells.count; i++) {
    UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i];
    cell.alpha = 0.0;
    [UIView animateWithDuration:0.3 delay:i*0.05 options:0 animations:^{
        cell.alpha = 1.0;
    } completion:^(BOOL finished) {

    }];
}
}
</code></pre><h4 id="Transition类"><a href="#Transition类" class="headerlink" title="Transition类"></a>Transition类</h4><h5 id="遍历移动x"><a href="#遍历移动x" class="headerlink" title="遍历移动x"></a>遍历移动x</h5><pre><code>+(void)moveAnimationWithTableView:(UITableView *)tableView {
NSArray *cells = tableView.visibleCells;
for (int i = 0; i &lt; cells.count; i++) {
    CGFloat totalTime = 0.4;
    UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i];
    cell.transform = CGAffineTransformMakeTranslation(-XS_SCREEN_WIDTH, 0);
    [UIView animateWithDuration:0.4 delay:i*(totalTime/cells.count) usingSpringWithDamping:0.7 initialSpringVelocity:1/0.7 options:UIViewAnimationOptionCurveEaseIn animations:^{
        cell.transform = CGAffineTransformIdentity;
    } completion:^(BOOL finished) {

    }];
}
}
</code></pre><h5 id="遍历交叉移动x"><a href="#遍历交叉移动x" class="headerlink" title="遍历交叉移动x"></a>遍历交叉移动x</h5><pre><code>+(void)shakeAnimationWithTableView:(UITableView *)tableView {
NSArray *cells = tableView.visibleCells;
for (int i = 0; i &lt; cells.count; i++) {
    UITableViewCell *cell = [cells objectAtIndex:i];
    if (i%2 == 0) {
        cell.transform = CGAffineTransformMakeTranslation(-XS_SCREEN_WIDTH,0);
    }else {
        cell.transform = CGAffineTransformMakeTranslation(XS_SCREEN_WIDTH,0);
    }
    [UIView animateWithDuration:0.4 delay:i*0.03 usingSpringWithDamping:0.75 initialSpringVelocity:1/0.75 options:0 animations:^{
        cell.transform = CGAffineTransformIdentity;
    } completion:^(BOOL finished) {

    }];
}
 }
</code></pre><h5 id="遍历移动y"><a href="#遍历移动y" class="headerlink" title="遍历移动y"></a>遍历移动y</h5><pre><code>+(void)fallAnimationWithTableView:(UITableView *)tableView {
NSArray *cells = tableView.visibleCells;   
NSTimeInterval totalTime = 0.8;  
for (int i = 0; i &lt; cells.count; i++) {
    UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i];
    cell.transform = CGAffineTransformMakeTranslation(0, - XS_SCREEN_HEIGHT);
    [UIView animateWithDuration:0.3 delay:(cells.count - i)*(totalTime/cells.count) options:0 animations:^{
        cell.transform = CGAffineTransformIdentity;
    } completion:^(BOOL finished) {

    }];
}
</code></pre><p>}</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my blog. Thanks.&lt;/p&gt;
&lt;p&gt;Dome:&lt;a href=&quot;https://github.com/princeSmall/CellAnimation.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github地
    
    </summary>
    
      <category term="Animation" scheme="http://yoursite.com/categories/Animation/"/>
    
    
      <category term="6" scheme="http://yoursite.com/tags/6/"/>
    
  </entry>
  
  <entry>
    <title>[Animation_ViewAnimation]</title>
    <link href="http://yoursite.com/2017/11/21/Animation-ViewAnimation/"/>
    <id>http://yoursite.com/2017/11/21/Animation-ViewAnimation/</id>
    <published>2017-11-21T07:57:57.000Z</published>
    <updated>2017-11-21T08:34:40.709Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/UIViewControllerAnimation.git" target="_blank" rel="external">github地址</a></p>
<p><img src="/2017/11/21/Animation-ViewAnimation/ViewAnimations.gif" alt="ViewAnimation"></p>
<h3 id="ViewControllerAnimation"><a href="#ViewControllerAnimation" class="headerlink" title="ViewControllerAnimation"></a>ViewControllerAnimation</h3><p>注：所有的动画我都封装起来了，这里不仅有present和dismiss在viewController中跳转，还有各种动画push和pop，当然view的动画出场也是必不可少的。拿了直接用即可，简单粗暴看代码，这里可以让你知其然，知其所以然。</p>
<h4 id="PresentAnimation"><a href="#PresentAnimation" class="headerlink" title="PresentAnimation"></a>PresentAnimation</h4><p>实现UIViewControllerTransitioningDelegate的代理方法，把present从下面出来的view从右边动画出来，具体代码看github代码，具体方法如下：</p>
<pre>
-(NSTimeInterval)transitionDuration:(id<uiviewcontrollercontexttransitioning>)transitionContext{
    return 1.0;
}
-(void)animateTransition:(id<uiviewcontrollercontexttransitioning>)transitionContext{
 UIViewController * fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
    UIViewController * toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
    UIView *containerView =  [transitionContext containerView];
    UIView *fromView = nil;
    UIView *toView = nil;

    if ([transitionContext respondsToSelector:@selector(viewForKey:)]) {
        fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];
        toView = [transitionContext viewForKey:UITransitionContextToViewKey];
    }else{
        fromView = fromViewController.view;
        toView = toViewController.view;
    }
    BOOL isPresent = (toViewController.presentingViewController == fromViewController);
    CGRect fromFrame = [transitionContext initialFrameForViewController:fromViewController];
    CGRect toFrame = [transitionContext finalFrameForViewController:toViewController];
    if (isPresent) {
        fromView.frame = fromFrame;
        toView.frame = CGRectOffset(toFrame, toFrame.size.width, 0);
        [containerView addSubview:toView];
    }  
    NSTimeInterval transitionDuration = [self transitionDuration:transitionContext];
    [UIView animateWithDuration:transitionDuration animations:^{
        if (isPresent) {
            toView.frame = toFrame;
            fromView.frame = CGRectOffset(fromFrame, fromFrame.size.width*0.3*-1, 0);
        }
    } completion:^(BOOL finished) {
        BOOL isCancelled = [transitionContext transitionWasCancelled];
        if (isCancelled)
            [toView removeFromSuperview]; 
        [transitionContext completeTransition:!isCancelled];
    }];
}
</uiviewcontrollercontexttransitioning></uiviewcontrollercontexttransitioning></pre>


<pre>
-(id<uiviewcontrolleranimatedtransitioning>)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source{
    return (id)[[PresentAnimation alloc]init];
}
</uiviewcontrolleranimatedtransitioning></pre>

<h4 id="DismissAnimation"><a href="#DismissAnimation" class="headerlink" title="DismissAnimation"></a>DismissAnimation</h4><pre>
- (NSTimeInterval)transitionDuration:(id<uiviewcontrollercontexttransitioning>)transitionContext{
    return 1.0;
}
-(void)animateTransition:(id<uiviewcontrollercontexttransitioning>)transitionContext{
  UIViewController *fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
    UIViewController *toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];

    UIView *containerView = [transitionContext containerView];
    UIView *fromView = nil;
    UIView *toView = nil;

    if ([transitionContext respondsToSelector:@selector(viewForKey:)]) {
        fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];
        toView = [transitionContext viewForKey:UITransitionContextToViewKey];
    }else{
        fromView = fromViewController.view;
        toView = toViewController.view;
    }

    BOOL isDismiss = (fromViewController.presentingViewController == toViewController);   
    CGRect fromFrame = [transitionContext initialFrameForViewController:fromViewController];
    CGRect toFrame = [transitionContext finalFrameForViewController:toViewController];

    if (isDismiss) {
        fromView.frame = fromFrame;
        toView.frame = CGRectOffset(toFrame, toFrame.size.width*0.3*-1, 0);
        [containerView insertSubview:toView belowSubview:fromView];
    }
    NSTimeInterval transitionDuration = [self transitionDuration:transitionContext];
    [UIView animateWithDuration:transitionDuration animations:^{
        if (isDismiss) {
            toView.frame = toFrame;
            fromView.frame = CGRectOffset(fromFrame, fromFrame.size.width, 0);
        }
    } completion:^(BOOL finished) {
        BOOL isCancel = [transitionContext transitionWasCancelled];
        if (isCancel) {
            [toView removeFromSuperview];
        }
        [transitionContext completeTransition:!isCancel];
    }];
  }
</uiviewcontrollercontexttransitioning></uiviewcontrollercontexttransitioning></pre>

<pre>
- (nullable id <uiviewcontrolleranimatedtransitioning>)animationControllerForDismissedController:(UIViewController *)dismissed {
    return (id)[[DismissAnimation alloc]init];
}
</uiviewcontrolleranimatedtransitioning></pre>


<h4 id="PushAnimation"><a href="#PushAnimation" class="headerlink" title="PushAnimation"></a>PushAnimation</h4><p>动画添加新的view，type和subType不同，动画方式就不一样。这里只写一个不累赘</p>
<pre><code> +(void)pushView:(UIView *)View subView:(UIView *)subView AndAnimationType:(NSString *)type AndsubType:(NSString *)subType{  
CATransition *transition = [CATransition animation];
transition.duration = 1.0f;
transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
transition.type = type;
transition.subtype = subType;
[View.layer addAnimation:transition forKey:@&quot;pushTransitionAnimation&quot;];
[View addSubview:subView];
  }
</code></pre><h4 id="PopAnimation"><a href="#PopAnimation" class="headerlink" title="PopAnimation"></a>PopAnimation</h4><p>动画移除新的view</p>
<pre><code> +(void)popView:(UIView *)View subView:(UIView *)subView AndAnimationType:(NSString *)type AndsubType:(NSString *)subType {
CATransition *transition = [CATransition animation];
transition.duration = 1.0f;
transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
transition.type = type;
transition.subtype = subType;
[View.superview.layer addAnimation:transition forKey:@&quot;popTransitionAnimation&quot;];
[subView removeFromSuperview];
 }
</code></pre><p>注：关于CATransition的type和subType的介绍，前两篇博客已经介绍过，看Animation_CATransition这篇。</p>
<h4 id="ScaleViewAnimation"><a href="#ScaleViewAnimation" class="headerlink" title="ScaleViewAnimation"></a>ScaleViewAnimation</h4><p>CGAffineTransform 主要用于形变，位移和旋转，可用于动画展示</p>
<h5 id="transform属性介绍，这里介绍最常用和好用的，其他属性去看CGAffineTransform"><a href="#transform属性介绍，这里介绍最常用和好用的，其他属性去看CGAffineTransform" class="headerlink" title="transform属性介绍，这里介绍最常用和好用的，其他属性去看CGAffineTransform"></a>transform属性介绍，这里介绍最常用和好用的，其他属性去看CGAffineTransform</h5><ul>
<li><p>位移X,Y</p>
<pre><code>CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty)
</code></pre></li>
<li><p>伸缩X,Y</p>
<pre><code>CGAffineTransformMakeScale(CGFloat sx, CGFloat sy)
</code></pre></li>
<li><p>旋转M_PI</p>
<pre><code>CGAffineTransformMakeRotation(CGFloat angle)
</code></pre></li>
<li><p>组合</p>
<pre><code>CGAffineTransformConcat(CGAffineTransform t1,CGAffineTransform t2)
</code></pre></li>
<li><p>回到原位</p>
<pre><code>CGAffineTransformIdentity
</code></pre></li>
</ul>
<h5 id="动画调用，包括动画时间，动画完成后回调"><a href="#动画调用，包括动画时间，动画完成后回调" class="headerlink" title="动画调用，包括动画时间，动画完成后回调"></a>动画调用，包括动画时间，动画完成后回调</h5> <pre>
  -(void)scaleView:(UIView *)view CGFloatX:(CGFloat)x CGFloatY:(CGFloat)y CGFloatW:(CGFloat)w CGFloatH:(CGFloat)h{
    CGFloat scaleW = self.window.frame.size.width / w;
    CGFloat scaleH = self.window.frame.size.height / h;
    CGFloat W = scaleW * 50 - 50 - x;
    CGFloat H = scaleH * 50 - 50 - y;
    [UIView animateWithDuration:1.0 animations:^{
        view.transform =CGAffineTransformConcat(CGAffineTransformMakeScale(scaleW, scaleH), CGAffineTransformMakeTranslation(W,H));
    } completion:^(BOOL finished) {
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            view.transform = CGAffineTransformIdentity;
        });
   }];

}
</pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my blog. Thanks.&lt;/p&gt;
&lt;p&gt;Dome: &lt;a href=&quot;https://github.com/princeSmall/UIViewControllerAnimation.git&quot; target=&quot;_blank&quot; rel=&quot;exte
    
    </summary>
    
      <category term="Animation" scheme="http://yoursite.com/categories/Animation/"/>
    
    
      <category term="6" scheme="http://yoursite.com/tags/6/"/>
    
  </entry>
  
  <entry>
    <title>[Amimation_GroupAnimation]</title>
    <link href="http://yoursite.com/2017/11/20/Amimation-GroupAnimation/"/>
    <id>http://yoursite.com/2017/11/20/Amimation-GroupAnimation/</id>
    <published>2017-11-20T06:36:52.000Z</published>
    <updated>2017-11-20T06:52:36.133Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/Full-animation-details" target="_blank" rel="external">github地址</a></p>
<p>CAAnimation大家族的最后一个组合动画，所有复杂的动画都是有组合动画合成的，也可以说是最简单的。其实没什么可说的，就上一个炫酷的心形组合动画好了，其余的可以在我的代码中看到，简单到你怀疑自己。</p>
<p><img src="/2017/11/20/Amimation-GroupAnimation/GroupAnimation.gif" alt="GroupAnimation"></p>
<h3 id="GroupAnimation"><a href="#GroupAnimation" class="headerlink" title="GroupAnimation"></a>GroupAnimation</h3><pre><code>animations：动画集合数组
</code></pre><h4 id="draw-a-heart"><a href="#draw-a-heart" class="headerlink" title="draw a heart"></a>draw a heart</h4><pre>
- (void)drawRect:(CGRect)rect {
    // 间距
    CGFloat padding = 4.0;
    // 半径(小圆半径)
    CGFloat curveRadius = (rect.size.width - 2 * padding)/4.0;
    UIBezierPath *heartPath = [UIBezierPath bezierPath];
    // 起点
    CGPoint tipLocation = CGPointMake(rect.size.width/2, rect.size.height-padding);
    // 从起点开始画
    [heartPath moveToPoint:tipLocation];
    // (左圆的第二个点)
    CGPoint topLeftCurveStart = CGPointMake(padding, rect.size.height/2.4);
    // 添加二次曲线
    [heartPath addQuadCurveToPoint:topLeftCurveStart controlPoint:CGPointMake(topLeftCurveStart.x, topLeftCurveStart.y + curveRadius)];
    // 画圆
    [heartPath addArcWithCenter:CGPointMake(topLeftCurveStart.x+curveRadius, topLeftCurveStart.y) radius:curveRadius startAngle:M_PI endAngle:0 clockwise:YES];
    // (左圆的第二个点)
    CGPoint topRightCurveStart = CGPointMake(topLeftCurveStart.x + 2*curveRadius, topLeftCurveStart.y);
    // 画圆
    [heartPath addArcWithCenter:CGPointMake(topRightCurveStart.x+curveRadius, topRightCurveStart.y) radius:curveRadius startAngle:M_PI endAngle:0 clockwise:YES];
    // 右上角控制点
    CGPoint topRightCurveEnd = CGPointMake(topLeftCurveStart.x + 4*curveRadius, topRightCurveStart.y);
    // 添加二次曲线
    [heartPath addQuadCurveToPoint:tipLocation controlPoint:CGPointMake(topRightCurveEnd.x, topRightCurveEnd.y+curveRadius)];
    // 设置填充色
    [[UIColor redColor] setFill];
    [heartPath fill];

    heartPath.lineWidth = 2;
    heartPath.lineCapStyle  = kCGLineCapRound;
    heartPath.lineJoinStyle = kCGLineJoinRound;
    [[UIColor yellowColor] setStroke];
    [heartPath stroke];

}
</pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my blog. Thanks.&lt;/p&gt;
&lt;p&gt;Dome: &lt;a href=&quot;https://github.com/princeSmall/Full-animation-details&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;g
    
    </summary>
    
      <category term="Animation" scheme="http://yoursite.com/categories/Animation/"/>
    
    
      <category term="6" scheme="http://yoursite.com/tags/6/"/>
    
  </entry>
  
  <entry>
    <title>[Animation_ProgressAnimation]</title>
    <link href="http://yoursite.com/2017/11/19/Animation-ProgressAnimation/"/>
    <id>http://yoursite.com/2017/11/19/Animation-ProgressAnimation/</id>
    <published>2017-11-19T02:32:16.000Z</published>
    <updated>2017-11-20T02:41:15.418Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/Full-animation-details" target="_blank" rel="external">github地址</a></p>
<p>今天主要讲一些动画的运用，也就是进度条，有弧形的，扇形的，圆形的。<br>其实没什么难点，我封装在一个个View里，直接调用就行，弧度跟着进度条走就OK的。<br>饮水思源，喜欢或者用得上就github给个Star</p>
<p><img src="/2017/11/19/Animation-ProgressAnimation/Progress.gif" alt=""></p>
<h3 id="ProgressAnimation"><a href="#ProgressAnimation" class="headerlink" title="ProgressAnimation"></a>ProgressAnimation</h3><h4 id="UIBezierPath方法详解"><a href="#UIBezierPath方法详解" class="headerlink" title="UIBezierPath方法详解"></a>UIBezierPath方法详解</h4><p>UIBezierPath 顾名思义，这是用贝塞尔曲线的方式来构建一段弧线，你可以用任意条弧线来组成你想要的形状</p>
<pre><code>-(void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise
center 圆弧圆心
radius 圆弧半径
startAngle 开始弧度
endAngle 结束弧度
closewise 是否顺时针

-(void)fill
填充颜色
-(void)stroke
线条颜色
</code></pre><p>注: 使用UIBezierPath绘画的代码写在自定义视图的drawRect:方法中</p>
<h4 id="CAShaperLayer"><a href="#CAShaperLayer" class="headerlink" title="CAShaperLayer"></a>CAShaperLayer</h4><p>CAShaperLayer也就是在现有的图层上再次添加或覆盖一层以达到界面在显示时会呈现出不同形状的效果   </p>
<pre><code>fillColor 填充颜色
strokeColor 边框颜色
lineWidth 线条宽度
path 线条曲线
strokeStart 开始角度
strokeEnd 结束角度
</code></pre><p>注：进度条主要就以上方法</p>
<h4 id="应用界面调用"><a href="#应用界面调用" class="headerlink" title="应用界面调用"></a>应用界面调用</h4><p>懒加载UISlider</p>
<pre>- (UISlider *)sectorSlider{
    if (_sectorSlider == nil) {
        _sectorSlider = [[UISlider alloc]initWithFrame:CGRectMake(winWidth/2.0 - 100, 100, 200, 10)];
        _sectorSlider.continuous = YES;
        [_sectorSlider addTarget:self action:@selector(sliderValueChanged:) forControlEvents:UIControlEventValueChanged];
        [_sectorSlider setMinimumValue:0.0];
        [_sectorSlider setMaximumValue:1.0];
    }
    return _sectorSlider;
}
</pre>

<p>点击调用UISlider方法</p>
<pre>-(void)sliderValueChanged:(UISlider *)slider{
    NSLog(@"---%f", slider.value);
    self.percentLable.text = [NSString stringWithFormat:@"%.2f",slider.value * 100];
    [self.animationView  setStartMove:slider.value];
    [self.animationBallView setStartMove:slider.value];
    [self.animationTimeView setStartMove:slider.value];
}
</pre>

<h4 id="圆形进度条生成"><a href="#圆形进度条生成" class="headerlink" title="圆形进度条生成"></a>圆形进度条生成</h4><ol>
<li>UIBezierPath根据进度条随时改变开始弧度和结束弧度，不设置中心point</li>
</ol>
<pre>
- (void)drawRect:(CGRect)rect {
    CGPoint point = CGPointMake(100, 100);
    CGFloat radius = 95.0f;

    UIBezierPath *ballPath = [UIBezierPath bezierPathWithArcCenter:point radius:radius startAngle:self.startAngle endAngle:self.endAngle clockwise:YES];

    [[UIColor greenColor]set];
    [ballPath fill];

    //    在球形的外面绘制一个描边空心的圆形，不然很难看
    UIBezierPath *strokePath = [UIBezierPath bezierPathWithArcCenter:point radius:radius startAngle:0 endAngle:-0.00000001 clockwise:YES];
    [[UIColor lightGrayColor]set];
    [strokePath stroke];
}


-(void)setStartMove:(CGFloat)value{

    //    设置起始点，位置是根据进度动态变换的
    self.startAngle = M_PI_2 - value * M_PI;
    self.endAngle = M_PI_2 + value * M_PI;

    [self setNeedsDisplay];
}
</pre>

<h4 id="扇形进度条生成"><a href="#扇形进度条生成" class="headerlink" title="扇形进度条生成"></a>扇形进度条生成</h4><ol>
<li>UIBezierPath根据进度条随时改变结束弧度，设置中心point</li>
</ol>
<pre>
-(void)drawRect:(CGRect)rect{
    CGPoint point = CGPointMake(100 , 100);
    CGFloat radius = 95.0f;
    CGFloat startAngle = - M_PI_2;
    CGFloat endAngle = startAngle + self.endAngle;
    UIBezierPath * path = [UIBezierPath bezierPathWithArcCenter:point radius:radius startAngle:startAngle endAngle:endAngle clockwise:YES];
    [path addLineToPoint:point];
    [[UIColor greenColor]set];
    [path fill];
    UIBezierPath *strokePath = [UIBezierPath bezierPathWithArcCenter:point radius:radius startAngle:0 endAngle:-0.00000001 clockwise:YES];
    [[UIColor lightGrayColor]set];
    [strokePath stroke];

}
- (void)setStartMove:(CGFloat)value{
    self.endAngle = value * M_PI * 2;
    [self setNeedsDisplay];
}
</pre>

<h4 id="弧形进度条生成"><a href="#弧形进度条生成" class="headerlink" title="弧形进度条生成"></a>弧形进度条生成</h4><ol>
<li>先画一个封闭的背景圆self.backShaperLayer</li>
<li>根据圆弧先设置self.shaperLayer的开始，根据进度条的改变随时改变结束弧度</li>
</ol>
<pre>
- (void)drawRect:(CGRect)rect{

    self.shapeLayer = [CAShapeLayer layer];
    self.shapeLayer.fillColor = [UIColor clearColor].CGColor;
    self.shapeLayer.lineWidth = 6.0f;
    self.shapeLayer.strokeColor = [UIColor greenColor].CGColor;


    self.backShapeLayer = [CAShapeLayer layer];
    self.backShapeLayer.fillColor = [UIColor clearColor].CGColor;
    self.backShapeLayer.lineWidth = 6.0f;
    self.backShapeLayer.strokeColor = [UIColor darkGrayColor].CGColor;


    UIBezierPath * path = [UIBezierPath bezierPath];
    [path addArcWithCenter:CGPointMake(50, 50) radius:40 startAngle:0 endAngle:M_PI * 2 clockwise:YES];

    self.shapeLayer.path = path.CGPath;
    self.shapeLayer.strokeStart = 0;
    self.shapeLayer.strokeEnd = self.toValue;
    self.backShapeLayer.path = path.CGPath;
    self.backShapeLayer.strokeStart = 0;
    self.backShapeLayer.strokeEnd = 1;
    [self.layer addSublayer:self.backShapeLayer];
    [self.layer addSublayer:self.shapeLayer];

}
- (void)setStartMove:(CGFloat)value{
    self.toValue = value;
    [self setNeedsDisplay];
}
</pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my blog. Thanks.&lt;/p&gt;
&lt;p&gt;Dome: &lt;a href=&quot;https://github.com/princeSmall/Full-animation-details&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;g
    
    </summary>
    
      <category term="Animation" scheme="http://yoursite.com/categories/Animation/"/>
    
    
      <category term="6" scheme="http://yoursite.com/tags/6/"/>
    
  </entry>
  
  <entry>
    <title>[Animation_TransitionAnimation]</title>
    <link href="http://yoursite.com/2017/11/18/Animation-TransitionAnimation/"/>
    <id>http://yoursite.com/2017/11/18/Animation-TransitionAnimation/</id>
    <published>2017-11-18T02:58:25.000Z</published>
    <updated>2017-11-18T03:02:26.558Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/Full-animation-details" target="_blank" rel="external">github地址</a></p>
<p>今天周末也没有工作要去加班正好可以好好地整理CATransition动画属性的讲解和应用，以及UIView翻页的实例，简单上手。</p>
<h3 id="TransitionAnimation"><a href="#TransitionAnimation" class="headerlink" title="TransitionAnimation"></a>TransitionAnimation</h3><ul>
<li>duration</li>
</ul>
<pre>设置动画时间</pre>

<ul>
<li>type</li>
</ul>
<pre>设置运动类型

1、公有API的Type

    Fade,                       淡入淡出
    Push,                       推挤
    Reveal,                     揭开
    MoveIn,                     覆盖

2、私有API的Type

    Cube,                       立方体
    SuckEffect,                 吮吸
    OglFlip,                    翻转
    RippleEffect,               波纹
    PageCurl,                   翻页
    PageUnCurl,                 反翻页
    CameraIrisHollowOpen,       开镜头
    CameraIrisHollowClose,      关镜头

3、UIView翻页Type

    CurlDown,                   下翻页
    CurlUp,                     上翻页
    FlipFromLeft,               左翻转
    FlipFromRight,              右翻转
</pre>

<ul>
<li>subtype</li>
</ul>
<pre>设置运动方向

    kCATransitionFromLeft
    kCATransitionFromBottom
    kCATransitionFromRight
    kCATransitionFromTop

</pre>

<ul>
<li>timingFunction</li>
</ul>
<pre>设置运动轨迹

 kCAMediaTimingFunctionLinear            线性,即匀速
 kCAMediaTimingFunctionEaseIn            先慢后快
 kCAMediaTimingFunctionEaseOut           先快后慢
 kCAMediaTimingFunctionEaseInEaseOut     先慢后快再慢
 kCAMediaTimingFunctionDefault           实际效果是动画中间比较快.

</pre>


<p>4、使用方法</p>
<pre><code>- (void) transitionWithType:(NSString *)type WithSubtype:(NSString *)subtype ForView:(UIView *)view{
CATransition *animation = [CATransition animation];
animation.duration = 0.7f;
animation.type = type;
if (subtype != nil) {
    animation.subtype = subtype;
}
[view.layer addAnimation:animation forKey:@&quot;animation&quot;];
 }
</code></pre><p>5、实例应用，UIView上下左右翻页</p>
<pre><code>- (void) animationWithView : (UIView *)view WithAnimationTransition : (UIViewAnimationTransition) transition{
[UIView animateWithDuration:1.0f animations:^{
    [UIView setAnimationCurve:UIViewAnimationCurveEaseInOut];
    [UIView setAnimationTransition:transition forView:view cache:YES];
} completion:^(BOOL finished) {
    self.title = @&quot;0000&quot;;
}];
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my blog. Thanks.&lt;/p&gt;
&lt;p&gt;Dome: &lt;a href=&quot;https://github.com/princeSmall/Full-animation-details&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;g
    
    </summary>
    
      <category term="Animation" scheme="http://yoursite.com/categories/Animation/"/>
    
    
      <category term="6" scheme="http://yoursite.com/tags/6/"/>
    
  </entry>
  
  <entry>
    <title>[Animation_keyFrameAnimation]</title>
    <link href="http://yoursite.com/2017/11/17/Animation-keyFrameAnimation/"/>
    <id>http://yoursite.com/2017/11/17/Animation-keyFrameAnimation/</id>
    <published>2017-11-17T00:00:31.000Z</published>
    <updated>2017-11-20T03:16:29.501Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/Full-animation-details" target="_blank" rel="external">github地址</a></p>
<p>CAPropertyAnimation 的子类有CABsicAnimation 和 CAKeyframeAnimation。<br>今天要说的就是CAKeyframeAnimation关键帧动画，毫无疑问一切复杂的动画都是由简单的动画拼接来的，知其所以然，需要的时候必定能写出好的动画</p>
<p><img src="/2017/11/17/Animation-keyFrameAnimation/keyFrame.gif" alt="keyFrameAnimation"></p>
<h3 id="keyFrameAnimation"><a href="#keyFrameAnimation" class="headerlink" title="keyFrameAnimation"></a>keyFrameAnimation</h3><h4 id="属性值了解"><a href="#属性值了解" class="headerlink" title="属性值了解"></a>属性值了解</h4><p>1、关键帧值数组,一组变化值</p>
<pre><code>@property(nullable, copy) NSArray *values;
</code></pre><p>2、关键帧帧路径,优先级比values大</p>
<pre><code>@property(nullable) CGPathRef path;
</code></pre><p>3、每一帧对应的时间,时间可以控制速度.它和每一个帧相对应,取值为0.0-1.0,不设则每一帧时间相等.</p>
<pre><code>@property(nullable, copy) NSArray *keyTimes;
</code></pre><p>4、每一帧对应的时间曲线函数,也就是每一帧的运动节奏</p>
<pre><code>@property(nullable, copy) NSArray *timingFunctions;
</code></pre><p>5、动画的计算模式,默认值: kCAAnimationLinear.有以下几个值:</p>
<pre><code>@property(copy) NSString *calculationMode;

kCAAnimationLinear
关键帧为座标点的时候,关键帧之间直接直线相连进行插值计算;

kCAAnimationDiscrete
离散的,也就是没有补间动画

kCAAnimationPaced
平均，keyTimes跟timeFunctions失效

kCAAnimationCubic
对关键帧为座标点的关键帧进行圆滑曲线相连后插值计算,对于曲线的形状还可以通过tensionValues,continuityValues,biasValues来进行调整自定义,keyTimes跟timeFunctions失效

kCAAnimationCubicPaced
在kCAAnimationCubic的基础上使得动画运行变得均匀,就是系统时间内运动的距离相同,,keyTimes跟timeFunctions失效
</code></pre><p>6、动画的张力,当动画为立方计算模式的时候此属性提供了控制插值,因为每个关键帧都可能有张力所以连续性会有所偏差它的范围为[-1,1].同样是此作用</p>
<pre><code>@property(nullable, copy) NSArray *tensionValues;
</code></pre><p>7、动画的连续性值</p>
<pre><code>@property(nullable, copy) NSArray *continuityValues;
</code></pre><p>8、动画的偏斜率</p>
<pre><code>@property(nullable, copy) NSArray *biasValues;
</code></pre><p>9、动画沿路径旋转方式,默认为nil.它有两个值:</p>
<pre><code>@property(nullable, copy) NSString *rotationMode;
kCAAnimationRotateAuto
自动旋转
kCAAnimationRotateAutoReverse
自动翻转
</code></pre><h4 id="动画应用"><a href="#动画应用" class="headerlink" title="动画应用"></a>动画应用</h4><p>draw  a curve</p>
<pre><code>keyFrame：
path：路径
duration：单次时间
rotationMode：旋转样式
repeatCount：重复次数
</code></pre><p>1、弧形</p>
<pre><code>- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise ;
center ： 弧形的中心
radius： 弧形的半径
startAngle：弧形开始弧度
endAngle：弧形结束弧度
colockwise：顺逆时针
</code></pre><p>2、抛物线</p>
<pre><code>- (void)moveToPoint:(CGPoint)point
- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint;
point：开始位置
endPoint：结束位置
controlPoint：拐点位置
</code></pre><p>3、椭圆形</p>
<pre><code>+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect;
rect： x起点
       y起点
       width宽度
       height高度
</code></pre><p>4、圆形</p>
<pre><code>rect：
width = height
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my blog. Thanks.&lt;/p&gt;
&lt;p&gt;Dome: &lt;a href=&quot;https://github.com/princeSmall/Full-animation-details&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;g
    
    </summary>
    
      <category term="Animation" scheme="http://yoursite.com/categories/Animation/"/>
    
    
      <category term="6" scheme="http://yoursite.com/tags/6/"/>
    
  </entry>
  
  <entry>
    <title>[Animation_SpringAnimation]</title>
    <link href="http://yoursite.com/2017/11/16/Animation-SpringAnimation/"/>
    <id>http://yoursite.com/2017/11/16/Animation-SpringAnimation/</id>
    <published>2017-11-16T00:04:58.000Z</published>
    <updated>2017-11-18T03:01:53.638Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/Full-animation-details" target="_blank" rel="external">github地址</a></p>
<p>昨天整理了BasicAnimation，昨晚对SpringAnimation也进行了梳理。说白了，它的父类也是BasicAnimation，也增加了UIView 实例方法的应用。明天将会整理CATransition动画使用方法和应用实例。</p>
<h3 id="SpringAnimation"><a href="#SpringAnimation" class="headerlink" title="SpringAnimation"></a>SpringAnimation</h3><p>1、</p>
<pre><code>mass:

质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大

动画的速度变慢，并且波动幅度变大
</code></pre><p>2、 </p>
<pre><code>stiffness:

刚度系数(劲度系数/弹性系数)，刚度系数越大，形变产生的力就越大，运动越快
</code></pre><p>3、</p>
<pre><code>damping:

阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快
</code></pre><p>4、</p>
<pre><code>initialVelocity:

初始速率，动画视图的初始速度大小

速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反
</code></pre><p>5、</p>
<pre><code>CASpringAnimation * springAnimation = [CASpringAnimation animationWithKeyPath:@&quot;position&quot;];
springAnimation.damping = damping;
springAnimation.stiffness = stiffness;
springAnimation.mass = mass;
springAnimation.initialVelocity = initialVelocity;
springAnimation.toValue = [NSValue valueWithCGSize:CGSizeMake(self.redView.layer.position.x, self.redView.layer.position.y + 200)];
springAnimation.duration = springAnimation.settlingDuration;
[self.redView.layer addAnimation:springAnimation forKey:springAnimation.keyPath];
</code></pre><p>6、</p>
<pre><code> [UIView animateWithDuration:5 delay:0 usingSpringWithDamping:0.3 initialSpringVelocity:10 options:UIViewAnimationOptionTransitionFlipFromRight animations:^{
        CGPoint point =self.redView.center;
        point.y += 150;
        [self.redView setCenter:point];
    } completion:^(BOOL finished) {
        [self.redView setCenter:CGPointMake(250 + 49, 250 + 49)];
        [self.redView setBackgroundColor:[UIColor redColor]];
    }];
}     
      duration: 动画时长
      delay: 动画延迟
      damping: 弹簧效果
      springVelocity: 初始速度
      options: 过度效果
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my blog. Thanks.&lt;/p&gt;
&lt;p&gt;Dome: &lt;a href=&quot;https://github.com/princeSmall/Full-animation-details&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;g
    
    </summary>
    
      <category term="Animation" scheme="http://yoursite.com/categories/Animation/"/>
    
    
      <category term="6" scheme="http://yoursite.com/tags/6/"/>
    
  </entry>
  
  <entry>
    <title>[Animation_BasicAnimation]</title>
    <link href="http://yoursite.com/2017/11/15/Animation-BasicAnimation/"/>
    <id>http://yoursite.com/2017/11/15/Animation-BasicAnimation/</id>
    <published>2017-11-15T06:10:33.000Z</published>
    <updated>2017-11-23T04:45:24.317Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/Full-animation-details" target="_blank" rel="external">github地址</a></p>
<p>由于下班的时候出了事故，导致卧病休息了一个月左右，天天根本没时间更新博客，觉得没有记录就没有进步，很难过。好歹前段时间完成了公司的任务，现在有时间整理点东西。关于Animation明天会陆续整理出来，今天就是最简单的BasicAnimation。</p>
<h3 id="BasicAnimation"><a href="#BasicAnimation" class="headerlink" title="BasicAnimation"></a>BasicAnimation</h3><p><img src="/2017/11/15/Animation-BasicAnimation/Animation.gif" alt="animation"></p>
<p>1、keyPath</p>
<pre><code>rotation 旋轉

scale 缩放

translation 平移

CGPoint Key Paths : (example)position.x 位移

CGRect Key Paths : (example)bounds.size.width 伸缩

origin 原点

size 大小

opacity 透明度

backgroundColor  背景 颜色

contents  内容

Shadow Key Path: 阴影
</code></pre><p>2、</p>
<pre><code>duration：动画的持续时间
</code></pre><p>3、<br>　　<pre>repeatCount：动画的重复次数</pre></p>
<p>4、<br>　　<pre>timingFunction：动画的时间节奏控制</pre></p>
<p>5、Use</p>
<pre><code>    case 0:
        animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.x&quot;];
        //setFromValue不设置,默认以当前状态为准
        [animation setToValue:@(2 * M_PI)];
        break;
    case 1:
        animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.y&quot;];
        //setFromValue不设置,默认以当前状态为准
        [animation setToValue:@(2 * M_PI)];
        break;
    case 2:
        animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];
        //setFromValue不设置,默认以当前状态为准
        [animation setToValue:@(2 * M_PI)];
        break;
    case 3:
        //平移
        animation = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;];
        //setFromValue不设置,默认以当前状态为准
        [animation setToValue:[NSValue valueWithCGPoint:CGPointMake(self.redView.center.x, self.redView.center.y + 200)]];
        break;
    case 4:
        animation = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];
        [animation setFromValue:@1.0];
        [animation setToValue:@0.1];
        break;
    case 5:
        animation = [CABasicAnimation animationWithKeyPath:@&quot;backgroundColor&quot;];
        animation.fromValue = (__bridge id _Nullable)([UIColor redColor].CGColor);
        animation.toValue = (__bridge id _Nullable)([UIColor greenColor].CGColor);

        break;
    case 6:
        animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;];
        [animation setFromValue:@1.0];
        [animation setToValue:@0.1];
        break;
    case 7:
        animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale.x&quot;];
        [animation setFromValue:@1.0];
        [animation setToValue:@0.1];
        break;
    case 8:
        animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale.y&quot;];
        [animation setFromValue:@1.0];
        [animation setToValue:@0.1];
        break;
    case 9:
        animation = [CABasicAnimation animationWithKeyPath:@&quot;bounds&quot;];
        [animation setToValue:[NSValue valueWithCGRect:CGRectMake(self.redView.frame.origin.x, self.redView.frame.origin.y, 200, 200)]];
        break;

    default:
        break;
}
[animation setDelegate:self];//代理回调
[animation setDuration:1];//设置动画时间，单次动画时间
[animation setRemovedOnCompletion:NO];//默认为YES,设置为NO时setFillMode有效
[animation setTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]];
[animation setAutoreverses:YES];
[animation setFillMode:kCAFillModeBoth];
[self.redView.layer addAnimation:animation forKey:@&quot;basicAnimation&quot;];
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my blog. Thanks.&lt;/p&gt;
&lt;p&gt;Dome: &lt;a href=&quot;https://github.com/princeSmall/Full-animation-details&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;g
    
    </summary>
    
      <category term="Animation" scheme="http://yoursite.com/categories/Animation/"/>
    
    
      <category term="6" scheme="http://yoursite.com/tags/6/"/>
    
  </entry>
  
  <entry>
    <title>[iOS_零碎知识点整理]</title>
    <link href="http://yoursite.com/2017/09/30/iOS-%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2017/09/30/iOS-零碎知识点整理/</id>
    <published>2017-09-30T07:54:23.000Z</published>
    <updated>2017-11-24T08:12:49.531Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>明天就十一，项目也告一段路，今天就把以前的零碎知识点整理下，备忘录好几页找都不好找了</p>
<h3 id="iOS中属性-property的常用关键字"><a href="#iOS中属性-property的常用关键字" class="headerlink" title="iOS中属性@property的常用关键字"></a>iOS中属性@property的常用关键字</h3><p>strong，weak，assign，copy，nonatomic，retain ，atomic….</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>解析</th>
</tr>
</thead>
<tbody>
<tr>
<td>strong</td>
<td>释放旧对象，将旧对象的值赋予输入对象，输入对象的索引计数加1</td>
</tr>
<tr>
<td>weak</td>
<td>不增加引用计数，不持有对象，因此也不能决定对象释放</td>
</tr>
<tr>
<td>assign</td>
<td>适用于基础数据类型（NSInteger CGFloat…），不增加引用计数</td>
</tr>
<tr>
<td>copy</td>
<td>建立一个索引计数为1 的对象然后释放旧对象，此属性只对那些实行了NSCopying协议的对象类型有效（NSString , Block）</td>
</tr>
<tr>
<td>nonatomic</td>
<td>非原子性访问对于属性赋值的时候不加锁，多线程并发访问会提高性能，如果不加此属性则默认是两个访问方法都为原子型事务访问</td>
</tr>
<tr>
<td>retain</td>
<td>对象的引用计数+1。ARC下已经不再使用此关键字，用strong代替</td>
</tr>
<tr>
<td>atomic</td>
<td>和 nonatomic用来决定编译器生成的getter和setter是否为原子操作，atomic设置成员变量的@property属性时  默认为是atomic 提供线程安全</td>
</tr>
<tr>
<td>unsafe_unretained</td>
<td>跟weak类似，声明一个弱引用，但是当引用计数为0时，变量不会自动设置为nil</td>
</tr>
</tbody>
</table>
<h4 id="ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"><a href="#ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？" class="headerlink" title="ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"></a>ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h4><p>strong, atomic, readwrite</p>
<h4 id="copy-和-strong"><a href="#copy-和-strong" class="headerlink" title="copy 和 strong"></a>copy 和 strong</h4><p>（1）因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.<br>（2）如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性</p>
<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>Class 是一个 objc_class 结构类型的指针；而 id（任意对象） 是一个 objc_object 结构类型的指针<br>struct objc_class</p>
<pre>
{
    struct objc_class* isa;
    struct objc_class* super_class;
    const char* name;
    long version;
    long info;
    long instance_size;
    struct objc_ivar_list* ivars;
    struct objc_method_list** methodLists;
    struct objc_cache* cache;
    struct objc_protocol_list* protocols;
};
</pre>

<ol>
<li><p>（1）isa：对象的isa指向类（class），类的isa指向元类（meta class），元类isa指向元类的根类（root meteClass）。isa 帮助一个对象找到它的方法</p>
</li>
<li><p>（2）super_class：指向该类的父类！如果该类已经是最顶层的根类，如 NSObject 或 NSProxy），那么 super_class 就为 NULL。</p>
</li>
<li><p>（3）name：一个 C 字符串，指示类的名称。</p>
</li>
<li><p>（4）version：类的版本信息，默认初始化为 0。我们可以在运行期对其进行修改（class_setVersion）或获取</p>
</li>
<li>（5）info：供运行期使用的一些位标识。有如下一些位掩码：<br>CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含实例方法和变量；<br>CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法；<br>CLS_INITIALIZED (0x4L) 表示该类已经被运行期初始化了，这个标识位只被 objc_addClass 所设置；<br>CLS_POSING (0x8L) 表示该类被 pose 成其他的类；（poseclass 在ObjC 2.0中被废弃了）；<br>CLS_MAPPED (0x10L) 为ObjC运行期所使用<br>CLS_FLUSH_CACHE (0x20L) 为ObjC运行期所使用<br>CLS_GROW_CACHE (0x40L) 为ObjC运行期所使用<br>CLS_NEED_BIND (0x80L) 为ObjC运行期所使用<br>CLS_METHOD_ARRAY (0x100L) 该标志位指示 methodlists 是指向一个 objc_method_list 还是一个包含 objc_method_list 指针的数组；</li>
<li>（6）instance_size：该类的实例变量大小（包括从父类继承下来的实例变量）。</li>
<li>（7）ivars：指向 objc_ivar_list 的指针，存储每个实例变量的内存地址，如果该类没有任何实例变量则为 NULL；</li>
<li>（8）methodLists：与 info 的一些标志位有关，CLS_METHOD_ARRAY 标识位决定其指向的东西（是指向单个 objc_method_list还是一个 objc_method_list 指针数组），如果 info 设置了 CLS_CLASS 则 objc_method_list  存储实例方法，如果设置的是 CLS_META 则存储类方法；</li>
<li>（9）cache：指向 objc_cache 的指针，用来缓存最近使用的方法，以提高效率。</li>
<li>（10）protocols：指向 objc_protocol_list 的指针，存储该类声明要遵守的正式协议。</li>
</ol>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p>IMP本质上就是一个函数指针，指向方法的实现，在objc.h找到它的定义<br>typedef void (<em>IMP)(void /</em> id, SEL, … */ );</p>
<p>#else<br>typedef id (*IMP)(id, SEL, …);</p>
<p>#endif</p>
<h4 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h4><p>objc_msgSend它具体是如何发送消息：<br>首先根据receiver对象的isa指针获取它对应的class；<br>优先在class的cache查找message方法，如果找不到，再到methodLists查找；<br>如果没有在class找到，再到super_class查找；<br>一旦找到message这个方法，就执行它实现的IMP。<br>注：当objc_msgSend找不到实现的IMP时，程序并不会直接崩溃，而是给开发者一个plan b：方法决议与消息转发</p>
<h3 id="iOS的一些小技巧"><a href="#iOS的一些小技巧" class="headerlink" title="iOS的一些小技巧"></a>iOS的一些小技巧</h3><h4 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h4><ol>
<li><p>设置UILable行间距</p>
<pre><code>NSMutableAttributedString* attrString = [[NSMutableAttributedString  alloc] initWithString:label.text];

NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];

[style setLineSpacing:20];

[attrString addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, label.text.length)];

label.attributedText = attrString;
</code></pre></li>
<li><p>UILabel显示不同颜色字体</p>
<pre><code>NSMutableAttributedString * string = [[NSMutableAttributedString alloc] initWithString:label.text];

[string addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0,5)];

[string addAttribute:NSForegroundColorAttributeName value:[UIColor greenColor] range:NSMakeRange(5,6)];

[string addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(11,5)];

label.attributedText = string;
</code></pre></li>
<li><p>动画修改label上的文字</p>
<pre><code>方法一
CATransition * animation = [CATransition animation];
animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
animation.type = kCATransitionFade;
animation.duration = 0.75;
[self.label.layer addAnimation:animation forKey:@&quot;kCATransitionFade&quot;];
self.label.text = @&quot;New&quot;;

方法二
[UIView transitionWithView:self.label
              duration:0.25f
               options:UIViewAnimationOptionTransitionCrossDissolve
            animations:^{
                self.label.text = @&quot;Well done!&quot;;
            } completion:nil];

 方法三
 [UIView animateWithDuration:1.0
             animations:^{
                 self.label.alpha = 0.0f;
                 self.label.text = @&quot;newText&quot;;
                 self.label.alpha = 1.0f;
             }];
</code></pre></li>
</ol>
<ol>
<li><p>播放一张张连续的图片</p>
<pre><code>加入现在有三张图片分别为animate_1、animate_2、animate_3
方法一：
imageView.animationImages = @[[UIImage imageNamed:@&quot;animate_1&quot;], [UIImage imageNamed:@&quot;animate_2&quot;], [UIImage imageNamed:@&quot;animate_3&quot;]];
imageView.animationDuration = 1.0;
方法二：
imageView.image = [UIImage animatedImageNamed:@&quot;animate_&quot; duration:1.0];
方法二解释下：
这个方法会加载animate_为前缀的，后边0-1024，也就是animate_0、animate_1一直到animate_1024
</code></pre></li>
<li><p>修改UISearBar内部背景颜色</p>
<pre><code>UITextField *textField = [_searchBar valueForKey:@&quot;_searchField&quot;];
textField.backgroundColor = [UIColor redColor];
</code></pre></li>
<li><p>监听UISlider拖动状态</p>
<pre><code>[slider addTarget:self action:@selector(sliderValurChanged:forEvent:) forControlEvents:UIControlEventValueChanged];

 - (void)sliderValurChanged:(UISlider*)slider forEvent:(UIEvent*)event {
   UITouch *touchEvent = [[event allTouches] anyObject];
   switch (touchEvent.phase) {
       case UITouchPhaseBegan:
            NSLog(@&quot;开始拖动&quot;);
            break;
       case UITouchPhaseMoved:
            NSLog(@&quot;正在拖动&quot;);
            break;
       case UITouchPhaseEnded:
            NSLog(@&quot;结束拖动&quot;);
            break;
       default:
            break;
      }
  }
</code></pre></li>
</ol>
<h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><ol>
<li><p>MD5加密</p>
<pre><code>+ (NSString *)md5:(NSString *)str
{
   const char *concat_str = [str UTF8String];
   unsigned char result[CC_MD5_DIGEST_LENGTH];
   CC_MD5(concat_str, (unsigned int)strlen(concat_str), result);
   NSMutableString *hash = [NSMutableString string];
   for (int i =0; i&lt;16; i++){
      [hash appendFormat:@&quot;X&quot;, result[i]];
   }
   return [hash uppercaseString];
}
</code></pre></li>
<li><p>base64加密       </p>
<pre><code>@interface NSData (Base64)
/**
 *  @brief  字符串base64后转data
 */
+ (NSData *)dataWithBase64EncodedString:(NSString *)string
{
  if (![string length]) return nil;
  NSData *decoded = nil;
#if __MAC_OS_X_VERSION_MIN_REQUIRED &lt; __MAC_10_9 || __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_7_0
 if (![NSData instancesRespondToSelector:@selector(initWithBase64EncodedString:options:)])
 {
#pragma clang diagnostic push
#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;
decoded = [[self alloc] initWithBase64Encoding:[string stringByReplacingOccurrencesOfString:@&quot;[^A-Za-z0-9+/=]&quot; withString:@&quot;&quot; options:NSRegularExpressionSearch range:NSMakeRange(0, [string length])]];
#pragma clang diagnostic pop
 }
else
#endif
{
decoded = [[self alloc] initWithBase64EncodedString:string options:NSDataBase64DecodingIgnoreUnknownCharacters];
}
return [decoded length]? decoded: nil;
}
/**
  *  @brief  NSData转string
  *  @param wrapWidth 换行长度  76  64
  */
- (NSString *)base64EncodedStringWithWrapWidth:(NSUInteger)wrapWidth
{
   if (![self length]) return nil;
   NSString *encoded = nil;
  #if __MAC_OS_X_VERSION_MIN_REQUIRED &lt; __MAC_10_9 || __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_7_0
   if (![NSData instancesRespondToSelector:@selector(base64EncodedStringWithOptions:)])
   {
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;
encoded = [self base64Encoding];
#pragma clang diagnostic pop

 }
else
#endif
{
switch (wrapWidth)
{
    case 64:
    {
        return [self base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];
    }
    case 76:
    {
        return [self base64EncodedStringWithOptions:NSDataBase64Encoding76CharacterLineLength];
    }
    default:
    {
        encoded = [self base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)0];
    }
}
 }
if (!wrapWidth || wrapWidth &gt;= [encoded length])
{
   return encoded;
 }
 wrapWidth = (wrapWidth / 4) * 4;
 NSMutableString *result = [NSMutableString string];
   for (NSUInteger i = 0; i &lt; [encoded length]; i+= wrapWidth)
 {
if (i + wrapWidth &gt;= [encoded length])
{
    [result appendString:[encoded substringFromIndex:i]];
    break;
}
[result appendString:[encoded substringWithRange:NSMakeRange(i, wrapWidth)]];
[result appendString:@&quot;\r\n&quot;];
  }
  return result;
 }
/**
  *  @brief  NSData转string 换行长度默认64
  */
 - (NSString *)base64EncodedString
 {
      return [self base64EncodedStringWithWrapWidth:0];
 }
</code></pre></li>
<li><p>3DES加密</p>
<pre><code>#import
@interface NSData (3DES)
/**
  *  利用3DES加密数据
  */
- (NSData*)encryptedWith3DESUsingKey:(NSString*)key andIV:(NSData*)iv {

      NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];

      size_t dataMoved;
      NSMutableData *encryptedData = [NSMutableData dataWithLength:self.length + kCCBlockSize3DES];

      CCCryptorStatus result = CCCrypt(kCCEncrypt,kCCAlgorithm3DES,kCCOptionPKCS7Padding,keyData.bytes,keyData.length,iv.bytes,self.bytes,self.length,encryptedData.mutableBytes,encryptedData.length,&amp;dataMoved);

     if (result == kCCSuccess) {
encryptedData.length = dataMoved;
return encryptedData;
        }

    return nil;

 }
/**
  *  @brief   利用3DES解密数据
  */
- (NSData*)decryptedWith3DESUsingKey:(NSString*)key andIV:(NSData*)iv {

   NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];

  size_t dataMoved;
  NSMutableData *decryptedData = [NSMutableData dataWithLength:self.length + kCCBlockSize3DES];

  CCCryptorStatus result = CCCrypt(kCCDecrypt,kCCAlgorithm3DES,kCCOptionPKCS7Padding,keyData.bytes,keyData.length,iv.bytes,self.bytes,self.length,decryptedData.mutableBytes,decryptedData.length,&amp;dataMoved);

 if (result == kCCSuccess) {
      decryptedData.length = dataMoved;
      return decryptedData;
    }

   return nil;

}
</code></pre></li>
</ol>
<h4 id="零碎知识点"><a href="#零碎知识点" class="headerlink" title="零碎知识点"></a>零碎知识点</h4><ol>
<li><p>页面跳转实现翻转动画</p>
<pre><code>modal方式
TestViewController *vc = [[TestViewController alloc] init];
vc.view.backgroundColor = [UIColor redColor];
vc.modalTransitionStyle = UIModalTransitionStyleCoverVertical;
[self presentViewController:vc animated:YES completion:nil];

push方式:
TestViewController *vc = [[TestViewController alloc] init];
vc.view.backgroundColor = [UIColor redColor];
[UIView beginAnimations:@&quot;View Flip&quot; context:nil];
[UIView setAnimationDuration:0.80];
[UIView setAnimationCurve:UIViewAnimationCurveEaseInOut];
[UIView setAnimationTransition:UIViewAnimationTransitionFlipFromRight forView:self.navigationController.view cache:NO];
[self.navigationController pushViewController:vc animated:YES];
[UIView commitAnimations];
</code></pre></li>
<li><p>多网络请求：</p>
<pre><code>dispatch_group_t group = dispatch_group_create();
dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.wzb.test.www&quot;, DISPATCH_QUEUE_SERIAL);
dispatch_group_enter(group);
dispatch_group_async(group, serialQueue, ^{
// 网络请求一
[WebClick getDataSuccess:^(ResponseModel *model) {
    dispatch_group_leave(group);
} failure:^(NSString *err) {
    dispatch_group_leave(group);
}];
});
dispatch_group_enter(group);
  dispatch_group_async(group, serialQueue, ^{
// 网络请求二
[WebClick getDataSuccess:getBigTypeRM onSuccess:^(ResponseModel *model) {
    dispatch_group_leave(group);
}                                  failure:^(NSString *errorString) {
    dispatch_group_leave(group);
}];
});
dispatch_group_enter(group);
dispatch_group_async(group, serialQueue, ^{
// 网络请求三
[WebClick getDataSuccess:^{
    dispatch_group_leave(group);
} failure:^(NSString *errorString) {
    dispatch_group_leave(group);
}];
});

// 所有网络请求结束后会来到这个方法
dispatch_group_notify(group, serialQueue, ^{
dispatch_async(dispatch_get_global_queue(0, 0), ^{
    dispatch_async(dispatch_get_main_queue(), ^{
        // 刷新UI
    });
});
});
</code></pre></li>
<li><p>监听scrollView是否滚动到了顶部／底部</p>
<pre><code>-(void)scrollViewDidScroll: (UIScrollView*)scrollView
 {
   float scrollViewHeight = scrollView.frame.size.height;
   float scrollContentSizeHeight = scrollView.contentSize.height;
   float scrollOffset = scrollView.contentOffset.y;

   if (scrollOffset == 0)
    {
// 滚动到了顶部
    }
   else if (scrollOffset + scrollViewHeight ==  scrollContentSizeHeight)
    {
// 滚动到了底部
    }
  }
</code></pre></li>
<li><p>过滤空格</p>
</li>
</ol>
<pre><code>-(NSString *)userName:(NSString *)name{

name = [name stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];//前后空格

name = [name stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];//中间空格
return name;
}
</code></pre><ol>
<li><p>获取邮箱用户部分和域名部分</p>
<pre><code>- (BOOL)validateEmail:(NSString *)email {
    if ((0 != [email rangeOfString:@&quot;@&quot;].length) &amp;&amp;
        (0 != [email rangeOfString:@&quot;.&quot;].length)) {
         NSCharacterSet *tmpInvalidCharSet =
[[NSCharacterSet alphanumericCharacterSet] invertedSet];
        NSMutableCharacterSet *tmpInvalidMutableCharSet =
[tmpInvalidCharSet mutableCopy];
        [tmpInvalidMutableCharSet removeCharactersInString:@&quot;_-&quot;];

         NSRange range1 = [email rangeOfString:@&quot;@&quot; options:NSCaseInsensitiveSearch];

//取得用户名部分
NSString *userNameString = [email substringToIndex:range1.location];
NSLog(@&quot;length---%ld&quot;,userNameString.length);
if (userNameString.length &lt; 1 || userNameString.length &gt; 20) {
    return NO;
}else
//取得域名部分
NSString *domainString = [email substringFromIndex:range1.location + 1];
NSArray *domainArray = [domainString componentsSeparatedByString:@&quot;.&quot;];

for (NSString *string in domainArray) {
    NSRange rangeOfInavlidChars =
    [string rangeOfCharacterFromSet:tmpInvalidMutableCharSet];
    if (rangeOfInavlidChars.length != 0 || [string isEqualToString:@&quot;&quot;])
        return NO;
}

return YES;
} else {
return NO;
       }
}
</code></pre></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my blog. Thanks.&lt;/p&gt;
&lt;p&gt;明天就十一，项目也告一段路，今天就把以前的零碎知识点整理下，备忘录好几页找都不好找了&lt;/p&gt;
&lt;h3 id=&quot;iOS中属性-property的常用关键字&quot;&gt;&lt;a href=&quot;#iOS中属性-propert
    
    </summary>
    
      <category term="OC" scheme="http://yoursite.com/categories/OC/"/>
    
    
      <category term="5" scheme="http://yoursite.com/tags/5/"/>
    
  </entry>
  
  <entry>
    <title>[iOS_正则表达式]</title>
    <link href="http://yoursite.com/2017/09/25/iOS-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/09/25/iOS-正则表达式/</id>
    <published>2017-09-25T07:17:23.000Z</published>
    <updated>2017-11-24T08:12:37.268Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>新的项目用户名、邮箱和密码等要用到正则，所以就把以前整理的拿出来用了，不要太方便，索性就打个flag吧。嗯，我以前笔记做的还是比较清楚的</p>
<p>  正则表达式记录表</p>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><pre><code>1、 \b : 单词的开始或结束

2、 .* : 任意数量的不包含换行的字符
    .  : 匹配除换行符以外的任意字符 

3、 \d : 是新的元字符，匹配一位数字
  \d{n} : 必须连续重复匹配n次

4、 \s : 匹配任意的空白符（空格，制表格，换行符，中文全角空格等）

5、 \w : 匹配字母或者数字或者下划线或者汉字等

6、  ^  : 匹配字符串的开始
    ￥  : 匹配字符串的结束
</code></pre><p> 注意：</p>
<pre><code>* 字符转义

如果你想查找元字符本身，比如.和* ，这时候你就应该使用\.和\*
</code></pre><h4 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h4><pre><code>    代码       |     说明      
------------- | -------------
   *          |   重复零次或更多次
   +          |   重复一次或更多次
   ?          |   重复零次或一次
   {n}        |   重复n次
   {n,}       |   重复n次或更多次
   {n,m}      |   重复n到m次
</code></pre><p>注意：</p>
<pre><code>*字符类

如果想匹配没有预定义的元字符集合，比如a，e，o。这时候你就要[aeo]就匹配任何一个英文元音的字母。[.?!]匹配任意一个标点符号
</code></pre><h3 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h3><ol>
<li><p>满足任意一种规则都应该当成匹配，用 | 把不同的规则分割开来</p>
<pre><code>0\d{2}-\d{8}|0\d{3}-\d{7} 这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)

 \(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔
</code></pre></li>
<li><p>使用分枝条件时，要注意个分枝的顺序</p>
<pre><code>\d{5}-\d{4}|\d{5} 换成 \d{5}|\d{5}-\d{4}，那么就只会匹配5位的邮编。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了
</code></pre></li>
<li><p>重复多个字符，使用分组</p>
<pre><code>(\d{1,3}\.){3}\d{1,3}是一个简单的IP地址匹配表达式

(\d{1,3}\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})

不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址

((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。解析正确IP：01-09,0-255
1. 2[0-4]\d :（200-249)
2. 25[0-5] :(250-255)
3. [01]?\d\d? : (01-09,0-199)
</code></pre></li>
</ol>
<h3 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h3><pre><code>   代码        |语法
--------------|-------------------      
    \W        |匹配任意不是字母，数字，下划线，汉字的字符
    \S        |匹配任意不是空白符的字符
    \D        |匹配任意非数字的字符
    \B        |匹配不是单词开头或结束的位置
    [^x]      |匹配除了x以外的任意字符
    [^aeiou]  |匹配除了aeiou这几个字母以外的任意字符

例如： 

 \S+匹配不包含空白符的字符串。

 &lt;a[^&gt;]+&gt;匹配用尖括号括起来的以a开头的字符串
</code></pre><h3 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h3><p>常用分组语法</p>
<pre><code>       分类 |代码/语法     |说明
-----------|-------------|-----------------
  捕获      |  (exp)      |匹配exp,并捕获文本到自动命名的组里
           | (?&lt;name&gt;exp |匹配exp,并捕获文本到名称为name的组里，也可以写成(?&apos;name&apos;exp)
           |  (?:exp)    |匹配exp,不捕获匹配的文本，也不给此分组分配组号
  零宽断言  |   (?=exp)   |   匹配exp前面的位置                 
           |   (?&lt;=exp)  |匹配exp后面的位置
           |   (?!exp)   |匹配后面跟的不是exp的位置
           | (?&lt;!exp)    |匹配前面不是exp的位置
 注释      | (?#comment)  |这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读
</code></pre><p>注意：</p>
<pre><code>分组0对应整个正则表达式
实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号
你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权
</code></pre><p>例如：</p>
<pre><code>\b(\w+)\b\s+\1\b可以用来匹配重复的单词：html  html
</code></pre><h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><pre><code>          &lt;?!w+&gt; ?&lt;!w+

  \b\w*q[^u]\w*\b匹配包含后面不是字母u的字母q的单词。

  你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w*\b将会匹配下一个单词，于是\b\w*q[^u]\w*\b就能匹配整个Iraq fighting

  负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：\b\w*q(?!u)\w*\b

例如

\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。

(?&lt;![a-z])\d{7}匹配前面不是小写字母的七位数字。

(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)匹配不包含属性的简单HTML标签内里的内容：被尖括号括起来的单词(比如可能是&lt;b&gt;)，然后是.*(任意的字符串),最后是一个后缀(?=&lt;\/\1&gt;)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是&lt;b&gt;的话，后缀就是&lt;/b&gt;了。整个表达式匹配的是&lt;b&gt;和&lt;/b&gt;之间的内容(再次提醒，不包括前缀和后缀本身)
</code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><pre><code>    代码          |语法
------------------|-----------------
      (?&lt;=        |# 断言要匹配的文本的前缀
      &lt;(\w+)&gt;     |# 查找尖括号括起来的字母或数字(即HTML/XML标签)
      (           |  # 前缀结束
      .*          |  # 匹配任意文本
      (?=         | # 断言要匹配的文本的后缀
     &lt;\ / \1&gt;     |# 查找尖括号括起来的内容：前面是一个&quot;/&quot;，后面是先前捕获的标签
       )          | # 后缀结束

例如：
2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)。
</code></pre><h3 id="贪婪和懒惰"><a href="#贪婪和懒惰" class="headerlink" title="贪婪和懒惰"></a>贪婪和懒惰</h3><ol>
<li><p>a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。它会匹配整个字符串aabab。这被称为贪婪匹配  </p>
</li>
<li><p>a.*?b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，匹配任意数量的重复，(但是在能使整个匹配成功的前提下)使用最少的重复,会匹配aab和ab。这被称为懒惰匹配</p>
<p>注意：</p>
<pre><code>为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？
简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：
最先开始的匹配拥有最高的优先权
</code></pre></li>
<li><p>懒惰限定符</p>
<pre><code> 代码          |说明
-----------------|------------------------
  *？            |重复任意次，但尽可能少重复
  +？            |重复1次或更多次，但尽可能少重复
 ？？            |重复0次或1次，但尽可能少重复
 {n,m}?         |重复n到m次，但尽可能少重复
 {n,}?          |重复n次以上，但尽可能少重复 
</code></pre></li>
</ol>
<h3 id="处理选项"><a href="#处理选项" class="headerlink" title="处理选项"></a>处理选项</h3><p>注意:</p>
<pre><code>Regex regex = new Regex(@&quot;\ba\w{6}\b&quot;, RegexOptions.IgnoreCase);
</code></pre><p>常用的处理选项</p>
<pre><code>            名称            |说明
---------------------------|--------------------------------
  IgnoreCase               |匹配时不区分大小写
  Multiline                |更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)
  Singleline               |更改.的含义，使它与每一个字符匹配（包括换行符\n）
  IgnorePatternWhitespace  |忽略表达式中的非转义空白并启用由#标记的注释。
  ExplicitCapture          | 仅捕获已被显式命名的组。 
</code></pre><h3 id="常用事例"><a href="#常用事例" class="headerlink" title="常用事例"></a>常用事例</h3><pre><code> 说明              |正则表达式     
 -----------------|----------------------------          
网址(url)         |[a-zA-z]+://[^\s]*
IP地址            |((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)
电子邮件(email)    |\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*
QQ号码            | [1-9]\d{4,}
HTML标签          |&lt;(.*)(.*)&gt;.*&lt;\/\1&gt;|&lt;(.*) \/&gt;
密码(有数字/大写字母/小写字母/标点，8位以上) |(?=^.{8,}$)(?=.*\d)(?=.*\W+)(?=.*[A-Z])(?=.*[a-z])(?!.*\n).*$
日期              |(\d{4}|\d{2})-((1[0-2])|(0?[1-9]))-(([12][0-9])|(3[01])|(0?[1-9]))
汉字              |[\u4e00-\u9fa5]
中文及全角标点符号  |[\u3000-\u301e\ufe10-\ufe19\ufe30-\ufe44\ufe50-\ufe6b\uff01-\uffee]
</code></pre><p>注意：</p>
<pre><code>ios 开发使用 RegexKit.framework 框架 
</code></pre><p>使用规则：</p>
<pre><code> 昵称验证：(4-8)位汉字    
 + (BOOL) validateNickname:(NSString *)nickname
{
    NSString *nicknameRegex = @&quot;^[\u4e00-\u9fa5]{4,8}$&quot;;

    NSPredicate *passWordPredicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,nicknameRegex];

    return [passWordPredicate evaluateWithObject:nickname];
}

密码验证：(6-20)位英文不分大小写和数字
+ (BOOL) validatePassword:(NSString *)passWord
{
   NSString *passWordRegex = @&quot;^[a-zA-Z0-9]{6,20}+$&quot;;

   NSPredicate *passWordPredicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,passWordRegex];

   return [passWordPredicate evaluateWithObject:passWord];
}

邮箱验证：
+ (BOOL) validateEmail:(NSString *)email
{
   NSString *emailRegex = @&quot;[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}&quot;;

   NSPredicate *emailTest = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, emailRegex];

   return [emailTest evaluateWithObject:email];
 }   
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my blog. Thanks.&lt;/p&gt;
&lt;p&gt;新的项目用户名、邮箱和密码等要用到正则，所以就把以前整理的拿出来用了，不要太方便，索性就打个flag吧。嗯，我以前笔记做的还是比较清楚的&lt;/p&gt;
&lt;p&gt;  正则表达式记录表&lt;/p&gt;
&lt;h3 id=&quot;元字符
    
    </summary>
    
      <category term="OC" scheme="http://yoursite.com/categories/OC/"/>
    
    
      <category term="3" scheme="http://yoursite.com/tags/3/"/>
    
  </entry>
  
  <entry>
    <title>[GIT_版本库管理]</title>
    <link href="http://yoursite.com/2017/09/22/GIT-%E7%89%88%E6%9C%AC%E5%BA%93%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2017/09/22/GIT-版本库管理/</id>
    <published>2017-09-22T02:14:17.000Z</published>
    <updated>2017-09-22T07:36:55.084Z</updated>
    
    <content type="html"><![CDATA[<p>今天新同事不会用git，着实让我惊讶了，还好我有做笔记的习惯。就把我A long time ago 学习整理的git给他了，上手简单，很快就会成为git 大神，啊哈哈</p>
<h3 id="Git-小技能"><a href="#Git-小技能" class="headerlink" title="Git 小技能"></a>Git 小技能</h3><p>多人开发Git版本库的管理是再好不过的了，首先你要会把远程仓库的代码clone到你的电脑里，其次建立本地你的分支，写上你的code，然后添加到暂存区，没有问题就提交到修改区。既然是同时开发，肯能你同事也修改了，那就要把他的code先从远程仓库pull下来，不管你知不知道他们是否提交，避免冲突，先pull再push。然后无误后在merge到master分支，一切一气呵成。</p>
<h4 id="远程仓库管理"><a href="#远程仓库管理" class="headerlink" title="远程仓库管理"></a>远程仓库管理</h4><ol>
<li>先克隆代码到桌面吧，这克隆的是master分支代码<pre>
cd desktop
git clone (远程仓库地址)
</pre></li>
<li>如果你想克隆远程别的分支代码<pre>
git checkout -b (分支名) origin/(远程分支名)
git checkout —track origin/(远程分支名)
</pre></li>
<li>添加远程仓库<pre>
git remote add origin (远程仓库地址)：
</pre></li>
<li>删除远程仓库<pre>
git remote remove origin (远程仓库地址)
</pre></li>
<li>显示远程分支<pre>
git remote show origin
</pre>

</li>
</ol>
<h4 id="代码管理"><a href="#代码管理" class="headerlink" title="代码管理"></a>代码管理</h4><ol>
<li>代码添加到暂存区<pre>
git add (文件名)：添加某个文件
git add . : 添加所有文件
git add -A : 添加所有文件夹和文件
</pre></li>
<li>代码添加到当前分支<pre>
git commit -m "提交描述"
</pre></li>
<li>拉取远程代码<pre>
git pull origin (远程分支)
</pre></li>
<li>同步本地代码<pre>
git push origin (远程分支)
</pre>

</li>
</ol>
<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><ol>
<li>查看当前分支<pre>
git branch
</pre></li>
<li>创建新的分支<pre>
git checkout -b newBranch
</pre></li>
<li>删除旧的分支<pre>
git checkout -d newBranch
</pre></li>
<li>合并分支<pre>
git merge (要合并的分支)
</pre>

</li>
</ol>
<h4 id="提交管理"><a href="#提交管理" class="headerlink" title="提交管理"></a>提交管理</h4><ol>
<li>找到历史提交的commit id<pre>
git log —pretty=oneline —abbrev-commit
</pre></li>
<li>取消暂存<pre>
git reset HEAD 文件名
</pre></li>
<li>放弃当前修改<pre>
git checkout  -- (文件名)：（放弃当前文件修改）
git checkout . :(放弃当前所有修改)
</pre></li>
<li>恢复commit_id对应的版本<pre>
git reset --hard commit_id
</pre>

</li>
</ol>
<h4 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h4><ol>
<li>查看标签<pre>
git tag
</pre></li>
<li>查看标签信息<pre>
git show v1.0
</pre></li>
<li>创建标签<pre>
git tag v1.0  : 创建1.0标签
git tag v2.0 (commit_id): 创建指定提交的标签
</pre></li>
<li>删除标签<pre>
git tag -d v1.0 :（删除1.0标签）
git push origin :refs/tags/v0.9：（删除远程0.9标签）
</pre></li>
<li>推送本地标签<pre>
git push origin v1.0 ：（推送本地标签到远程）
git push origin —tags：（推送所有本地标签到远程）
</pre>

</li>
</ol>
<p>当然没有写Git冲突处理，因为我觉得冲突太简单了，打开项目包内容，定位到冲突的地方。保留正确的code，删除多余的运行就OK。如果一些乱七八糟的冲突，当然我也遇到过但是没有记录下来，很遗憾。</p>
<h4 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h4><p><img src="/2017/09/22/GIT-版本库管理/1.jpg" alt=""><br><img src="/2017/09/22/GIT-版本库管理/2.jpg" alt=""><br><img src="/2017/09/22/GIT-版本库管理/3.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天新同事不会用git，着实让我惊讶了，还好我有做笔记的习惯。就把我A long time ago 学习整理的git给他了，上手简单，很快就会成为git 大神，啊哈哈&lt;/p&gt;
&lt;h3 id=&quot;Git-小技能&quot;&gt;&lt;a href=&quot;#Git-小技能&quot; class=&quot;header
    
    </summary>
    
      <category term="GIT" scheme="http://yoursite.com/categories/GIT/"/>
    
    
      <category term="5" scheme="http://yoursite.com/tags/5/"/>
    
  </entry>
  
  <entry>
    <title>[机器学习_CoreML_Inceptionv3]</title>
    <link href="http://yoursite.com/2017/09/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-CoreML-Inceptionv3/"/>
    <id>http://yoursite.com/2017/09/21/机器学习-CoreML-Inceptionv3/</id>
    <published>2017-09-21T01:15:15.000Z</published>
    <updated>2017-09-21T02:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome:<a href="https://github.com/princeSmall/CoreML_Inceptionv3" target="_blank" rel="external">github地址</a></p>
<p>一直直接用图片给.mlmodel去识别，觉得没有直接调用相机来的方便，一直看的都是swift版本的，所以想写一个oc的，立个flag。</p>
<h1 id="CoreML-Inceptionv3"><a href="#CoreML-Inceptionv3" class="headerlink" title="CoreML_Inceptionv3"></a>CoreML_Inceptionv3</h1><p><img src="/2017/09/21/机器学习-CoreML-Inceptionv3/Inceptionv3.gif" alt="Inceptionv3"></p>
<h3 id="相机调用"><a href="#相机调用" class="headerlink" title="相机调用"></a>相机调用</h3><ol>
<li>info.plist 添加调用相机请求</li>
<li>相机调用请求</li>
<li>相机数据输出的delegate</li>
</ol>
<h4 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h4><ul>
<li>摄像显示区域</li>
<li>相机调用请求</li>
<li>相机数据输出</li>
<li>线程</li>
<li>数据显示</li>
<li>InceptionvModel</li>
<li>InceptionvModel输出</li>
</ul>
<pre>
@property (nonatomic,strong) AVCaptureVideoPreviewLayer
*previewLayer; 
@property (nonatomic,strong) AVCaptureSession *session;
@property (nonatomic,strong) AVCaptureVideoDataOutput *videoOutPut;
@property (nonatomic,strong) AVCaptureConnection *videoConnection;
@property (nonatomic,strong) dispatch_queue_t videoQueue;
@property (nonatomic,strong) UILabel *resultLabel;
@property (nonatomic,strong) Inceptionv3 *InceptionvModel;
@property (nonatomic,strong) Inceptionv3Output *outPut;
</pre>

<h4 id="相机调用请求"><a href="#相机调用请求" class="headerlink" title="相机调用请求"></a>相机调用请求</h4><pre>
self.session = [[AVCaptureSession alloc] init];

    //视频
    AVCaptureDevice *videoDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];
    if (videoDevice.isFocusPointOfInterestSupported && [videoDevice isFocusModeSupported:AVCaptureFocusModeContinuousAutoFocus]) {
        [videoDevice lockForConfiguration:nil];
        [videoDevice setFocusMode:AVCaptureFocusModeContinuousAutoFocus];
        [videoDevice unlockForConfiguration];
    }

    AVCaptureDeviceInput *cameraDeviceInput = [[AVCaptureDeviceInput alloc] initWithDevice:videoDevice error:nil];


    if ([self.session canAddInput:cameraDeviceInput]) {
        [self.session addInput:cameraDeviceInput];
    }

    //视频
    self.videoOutPut = [[AVCaptureVideoDataOutput alloc] init];
    NSDictionary * outputSettings = [[NSDictionary alloc] initWithObjectsAndKeys:[NSNumber numberWithInt:kCVPixelFormatType_32BGRA],(id)kCVPixelBufferPixelFormatTypeKey, nil];
    [self.videoOutPut setVideoSettings:outputSettings];
    if ([self.session canAddOutput:self.videoOutPut]) {
        [self.session addOutput:self.videoOutPut];
    }
    self.videoConnection = [self.videoOutPut connectionWithMediaType:AVMediaTypeVideo];
    self.videoConnection.enabled = NO;
    [self.videoConnection setVideoOrientation:AVCaptureVideoOrientationPortrait];
</pre>

<h4 id="初始化预览层"><a href="#初始化预览层" class="headerlink" title="初始化预览层"></a>初始化预览层</h4><pre>
 self.previewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:self.session];
    [self.previewLayer setVideoGravity:AVLayerVideoGravityResizeAspectFill];
</pre>

<h4 id="打开相机"><a href="#打开相机" class="headerlink" title="打开相机"></a>打开相机</h4><pre>
 [self.session startRunning];
    self.videoConnection.enabled = YES;
    self.videoQueue = dispatch_queue_create("videoQueue", NULL);
    [self.videoOutPut setSampleBufferDelegate:self queue:self.videoQueue];
</pre>

<h4 id="关闭相机"><a href="#关闭相机" class="headerlink" title="关闭相机"></a>关闭相机</h4><pre>
[self.videoOutPut setSampleBufferDelegate:nil queue:nil];
    self.videoConnection.enabled = NO;
    self.videoQueue = nil;
    [self.session stopRunning];
</pre>

<h3 id="CoreML数据输出"><a href="#CoreML数据输出" class="headerlink" title="CoreML数据输出"></a>CoreML数据输出</h3><ol>
<li>获取相机数据输出的CMSampleBufferRef</li>
<li>转换成UIImage大小为299.299</li>
<li>输出为Inceptionv3Output</li>
</ol>
<h4 id="下载Inceptionv3-mlmodel"><a href="#下载Inceptionv3-mlmodel" class="headerlink" title="下载Inceptionv3.mlmodel"></a>下载Inceptionv3.mlmodel</h4><ol>
<li>target-&gt;build phases-&gt;compile sources 添加Inceptionv3.mlmodel</li>
<li>导入头文件Inceptionv3.h</li>
</ol>
<h4 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h4><pre>
-(UIImage *)image:(CGSize)resize{
    UIGraphicsBeginImageContext(resize);
    [self drawInRect:CGRectMake(0, 0, resize.width, resize.height)];
    UIImage * image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return image;
}
</pre>

<h4 id="数据输出"><a href="#数据输出" class="headerlink" title="数据输出"></a>数据输出</h4><pre>
-(void)imageOutput:(CMSampleBufferRef)sampleBuffer{    
    CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);
    CIImage * ciImage = [CIImage imageWithCVImageBuffer:imageBuffer];

    Inceptionv3Image * uiImage =[[Inceptionv3Image alloc]initWithCIImage:ciImage];
    UIImage * uiimage = [uiImage image:CGSizeMake(299, 299)];

    CGImageRef cgImage = uiimage.CGImage;
    CVPixelBufferRef pixelBuffer = [ImageConvert pixelBufferFromImage:cgImage];
    self.InceptionvModel = [[Inceptionv3 alloc]init];
    self.outPut =  [self.InceptionvModel predictionFromImage:pixelBuffer error:nil];
}
</pre>

<h4 id="在AVCaptureOutputDelegat回调方法中开启线程"><a href="#在AVCaptureOutputDelegat回调方法中开启线程" class="headerlink" title="在AVCaptureOutputDelegat回调方法中开启线程"></a>在AVCaptureOutputDelegat回调方法中开启线程</h4><ol>
<li>把相机输出的数据转换成Inceptionv3接收的数据</li>
<li>在主线程刷新界面</li>
</ol>
<pre>
dispatch_queue_t queue = dispatch_queue_create("CMSampleBufferRef", NULL);
    dispatch_sync(queue, ^{
        [self imageOutput:sampleBuffer];
        dispatch_async(dispatch_get_main_queue(), ^{
            self.resultLabel.text = self.outPut.classLabel;
        });
    });
</pre>


]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my blog. Thanks.&lt;/p&gt;
&lt;p&gt;Dome:&lt;a href=&quot;https://github.com/princeSmall/CoreML_Inceptionv3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="3" scheme="http://yoursite.com/tags/3/"/>
    
  </entry>
  
  <entry>
    <title>[机器学习_CoreML_MobileNet]</title>
    <link href="http://yoursite.com/2017/09/20/Python-CoreML-MobileNet/"/>
    <id>http://yoursite.com/2017/09/20/Python-CoreML-MobileNet/</id>
    <published>2017-09-20T02:40:12.000Z</published>
    <updated>2017-09-20T09:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome:<a href="https://github.com/princeSmall/CoreML_MobileNet" target="_blank" rel="external">github地址</a></p>
<h1 id="CoreML-MobileNet"><a href="#CoreML-MobileNet" class="headerlink" title="CoreML_MobileNet"></a>CoreML_MobileNet</h1><p>接着上面再写一个MobileNet.mlmodel,这次这个直接拿来用。</p>
<p>GoogLeNetPlaces.mlmodel 和 Resnet50都可以识别人物和静态物体。不过这个才24M，小多了，所以就简尔处理给张特定的image，然后输出结果</p>
<p><img src="/2017/09/20/Python-CoreML-MobileNet/pool.png" alt=""></p>
<h3 id="Download-Core-ML-Model"><a href="#Download-Core-ML-Model" class="headerlink" title="Download Core ML Model"></a>Download Core ML Model</h3><p><a href="https://developer.apple.com/machine-learning/" target="_blank" rel="external">GoogLeNetPlaces.mlmodel下载地址</a></p>
<h3 id="导入头文件"><a href="#导入头文件" class="headerlink" title="导入头文件"></a>导入头文件</h3><pre>
 #import < CoreML/CoreML.h>
 #import < Vision/Vision.h>
 #import "GoogLeNetPlaces.h"
</pre>


<h3 id="图片识别"><a href="#图片识别" class="headerlink" title="图片识别"></a>图片识别</h3><ol>
<li><p>创建Resnet对象，加载CoreMLModel</p>
<pre>
GoogLeNetPlaces *googleModel = [[GoogLeNetPlaces alloc] init];
VNCoreMLModel * vnCoreModel = [VNCoreMLModel modelForMLModel:googleModel.model error:nil];
</pre>
</li>
<li><p>创建Vision请求，带有completion handle</p>
<pre>
VNCoreMLRequest * vnCoreMlRequest = [[VNCoreMLRequest alloc] initWithModel:vnCoreModel completionHandler:^(VNRequest * _Nonnull request, NSError * _Nullable error) {
   CGFloat confidence = 0.0f;
   VNClassificationObservation * tempClassification = nil;
   for (VNClassificationObservation *classification in request.results) {
       if (classification.confidence > confidence) {
           confidence = classification.confidence;
           tempClassification = classification;
       }
   }        
}];
</pre>
</li>
<li><p>VNClassificationObservation对象两个属性</p>
<ul>
<li>identifier：识别对象 </li>
<li>confidence：识别率</li>
</ul>
</li>
<li><p>发送图片识别请求</p>
<pre>
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
  VNImageRequestHandler * vnImageRequestHandler = [[VNImageRequestHandler alloc] initWithCGImage:image.CGImage options:nil];   
   NSError *error = nil;
   [vnImageRequestHandler performRequests:@[vnCoreMlRequest] error:&error]; 
   if (error) {
       NSLog(@"%@",error.localizedDescription);
   }
});
</pre>
</li>
<li><p>回调在主线程更新UI</p>
<pre>
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
       self.resultLable.text = [NSString stringWithFormat:@"识别结果:%@",tempClassification.identifier];
       self.confidenceLabel.text = [NSString stringWithFormat:@"匹配率:%@",@(tempClassification.confidence)];
   });
</pre>


</li>
</ol>
<p>多次下来是不是很简单，大同小异，只要熟悉CoreML，一切就是那么easy</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my blog. Thanks.&lt;/p&gt;
&lt;p&gt;Dome:&lt;a href=&quot;https://github.com/princeSmall/CoreML_MobileNet&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github地址
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="3" scheme="http://yoursite.com/tags/3/"/>
    
  </entry>
  
  <entry>
    <title>[机器学习_CoreML_Resnet50]</title>
    <link href="http://yoursite.com/2017/09/20/Python-CoreML-Resnet50/"/>
    <id>http://yoursite.com/2017/09/20/Python-CoreML-Resnet50/</id>
    <published>2017-09-20T02:18:31.000Z</published>
    <updated>2017-09-21T02:21:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome:<a href="https://github.com/princeSmall/CoreML_Resnet50" target="_blank" rel="external">github地址</a></p>
<h1 id="CoreML-Resnet50"><a href="#CoreML-Resnet50" class="headerlink" title="CoreML_Resnet50"></a>CoreML_Resnet50</h1><p>把玩了几天的CoreML，现在上手就写很是方便啊，所以研究透之后再来些例子就简单了。<br>这次用的是苹果提供的resnet50.mlmodel。</p>
<p><img src="/2017/09/20/Python-CoreML-Resnet50/cat.png" alt="举例图片" width="250" height="500"><br><img src="/2017/09/20/Python-CoreML-Resnet50/dog.png" alt="举例图片" width="250" height="500"><br><img src="/2017/09/20/Python-CoreML-Resnet50/mouse.png" alt="举例图片" width="250" height="500"><br><img src="/2017/09/20/Python-CoreML-Resnet50/panda.png" alt="举例图片" width="250" height="500"></p>
<h3 id="Download-Core-ML-Model"><a href="#Download-Core-ML-Model" class="headerlink" title="Download Core ML Model"></a>Download Core ML Model</h3><p><a href="https://developer.apple.com/machine-learning/" target="_blank" rel="external">Resnet50.mlmodel下载地址</a></p>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><ol>
<li>把下载后的mlmodel放入Xcode里面，绑定target，会自动生成.h和.m文件</li>
<li>导入头文件</li>
</ol>
<pre>
 #import < CoreML/CoreML.h>
 #import < Vision/Vision.h>
 #import "Resnet50.h"
</pre>

<h3 id="添加UIScrollView和UIPageControl"><a href="#添加UIScrollView和UIPageControl" class="headerlink" title="添加UIScrollView和UIPageControl"></a>添加UIScrollView和UIPageControl</h3><pre>
self.scrollView = [[UIScrollView alloc]initWithFrame:CGRectMake(0, 0, viewWidth, 250)];
    self.scrollView.delegate = self;
    self.scrollView.bounces = YES;
    self.scrollView.contentSize = CGSizeMake(5 * viewWidth, 250);
    self.scrollView.pagingEnabled = YES;
    self.scrollView.showsHorizontalScrollIndicator = NO;
    [self.view addSubview:self.scrollView];

    self.pageControl = [[UIPageControl alloc]init];
    [self.pageControl setCenter:CGPointMake(viewWidth / 2 - 20, 250 - 10)];
    self.pageControl.numberOfPages = 5;
    self.pageControl.pageIndicatorTintColor = [UIColor blackColor];
    self.pageControl.currentPageIndicatorTintColor = [UIColor redColor];
    for (int i = 0; i < 5; i ++) {
        UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(i * viewWidth, 0, viewWidth, 250)];
        imageView.image = [UIImage imageNamed:[NSString stringWithFormat:@"%d.jpg",i + 1]];
        [self.scrollView addSubview:imageView];
    }

    [self.view addSubview:self.pageControl];
 </pre>

<h4 id="滚动到开头或末尾"><a href="#滚动到开头或末尾" class="headerlink" title="滚动到开头或末尾"></a>滚动到开头或末尾</h4> <pre>
if (scrollView.contentOffset.x > 4 * viewWidth) 
{
        self.scrollView.contentOffset = CGPointMake(0, 0);
    }else if (scrollView.contentOffset.x < 0){
        self.scrollView.contentOffset = CGPointMake(4 * viewWidth, 0);
 }
 </pre> 

<h4 id="滚动结束后识别图片"><a href="#滚动结束后识别图片" class="headerlink" title="滚动结束后识别图片"></a>滚动结束后识别图片</h4> <pre>
  self.currentImage =[UIImage imageNamed:[NSString stringWithFormat:@"%d.jpg",(int)(self.pageControl.currentPage)]];
   [self openResnet50];
 </pre>

<h3 id="图片识别"><a href="#图片识别" class="headerlink" title="图片识别"></a>图片识别</h3><ol>
<li><p>创建Resnet对象，加载CoreMLModel</p>
<pre>
Resnet50 *resnetModel = [[Resnet50 alloc] init];
VNCoreMLModel * vnCoreModel = [VNCoreMLModel modelForMLModel:resnetModel.model error:nil];
</pre>
</li>
<li><p>创建Vision请求，带有completion handle</p>
<pre>
VNCoreMLRequest * vnCoreMlRequest = [[VNCoreMLRequest alloc] initWithModel:vnCoreModel completionHandler:^(VNRequest * _Nonnull request, NSError * _Nullable error) {
   CGFloat confidence = 0.0f;
   VNClassificationObservation * tempClassification = nil;
   for (VNClassificationObservation *classification in request.results) {
       if (classification.confidence > confidence) {
           confidence = classification.confidence;
           tempClassification = classification;
       }
   }        
}];
</pre>
</li>
<li><p>VNClassificationObservation对象两个属性</p>
<ul>
<li>identifier：识别对象 </li>
<li>confidence：识别率</li>
</ul>
</li>
<li><p>发送图片识别请求</p>
<pre>
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
  VNImageRequestHandler * vnImageRequestHandler = [[VNImageRequestHandler alloc] initWithCGImage:image.CGImage options:nil];   
   NSError *error = nil;
   [vnImageRequestHandler performRequests:@[vnCoreMlRequest] error:&error]; 
   if (error) {
       NSLog(@"%@",error.localizedDescription);
   }
});
</pre>
</li>
<li><p>回调在主线程更新UI</p>
<pre>
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
       self.resultLable.text = [NSString stringWithFormat:@"识别结果:%@",tempClassification.identifier];
       self.confidenceLabel.text = [NSString stringWithFormat:@"匹配率:%@",@(tempClassification.confidence)];
   });
</pre>




</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my blog. Thanks.&lt;/p&gt;
&lt;p&gt;Dome:&lt;a href=&quot;https://github.com/princeSmall/CoreML_Resnet50&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github地址&lt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="3" scheme="http://yoursite.com/tags/3/"/>
    
  </entry>
  
  <entry>
    <title>[机器学习_Python_mlmodel]</title>
    <link href="http://yoursite.com/2017/09/20/Python-mlmodel/"/>
    <id>http://yoursite.com/2017/09/20/Python-mlmodel/</id>
    <published>2017-09-20T00:47:12.000Z</published>
    <updated>2017-09-20T09:07:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome:<a href="https://github.com/princeSmall/CoreMLModel" target="_blank" rel="external">github地址</a></p>
<h1 id="CoreMLModel"><a href="#CoreMLModel" class="headerlink" title="CoreMLModel"></a>CoreMLModel</h1><p><img src="/2017/09/20/Python-mlmodel/mlmodel.png" alt=""><br>把玩CoreML创建自己的.mlmodel的心酸历程，足足摆弄了半天，各种坑。立个flag</p>
<h3 id="Permission-denied-问题"><a href="#Permission-denied-问题" class="headerlink" title="[Permission denied]问题"></a>[Permission denied]问题</h3><p><img src="/2017/09/20/Python-mlmodel/coremltoolsbug.png" alt="tools"></p>
<ul>
<li><p>pip install -U coremltools</p>
</li>
<li><p>从图也可以看出coremltools包含numpy,six,protobuf,coremltools。<br>因为权限问题导致失败</p>
</li>
</ul>
<p><img src="/2017/09/20/Python-mlmodel/coremltools.png" alt=""></p>
<ul>
<li>sudo pip install -U coremltools</li>
<li>遇到[Permission denied]都要加sudo</li>
</ul>
<h3 id="ImportError-No-module-named-pkg-resources-问题"><a href="#ImportError-No-module-named-pkg-resources-问题" class="headerlink" title="ImportError: No module named pkg_resources 问题"></a>ImportError: No module named pkg_resources 问题</h3><ul>
<li><p>Step: 1 Login in root user.</p>
<pre>
sudo su root
</pre>
</li>
<li><p>Step: 2 Uninstall python-pip package if existing.</p>
<pre>
apt-get purge -y python-pip
</pre>
</li>
<li><p>Step: 3 Download files using wget command(File download in pwd )</p>
<pre>
wget https://bootstrap.pypa.io/get-pip.py
</pre>
</li>
<li><p>Step: 4 Run python file.</p>
<pre>
python ./get-pip.py
</pre>
</li>
<li><p>Step: 5 Finaly exicute installation command.</p>
<pre>
apt-get install python-pip
</pre>

</li>
</ul>
<p><div><span style="color:red">Note: User must be root.</span></div></p>
<p>好吧，这两个问题遍布整个流程，期间各种小问题我已经不记得了，接下来就开始正文了</p>
<ol>
<li><p>下载coremltools</p>
<pre>sudo pip install -U coremltools</pre>
</li>
<li><p>下载pip.py文件</p>
<pre>sudo python get-pip.py</pre>
</li>
<li><p>下载scikit-learn</p>
<pre>sudo pip install -U numpy scipy scikit-learn</pre>
</li>
<li><p>下载panda</p>
<pre>sudo pip install pandas</pre>

</li>
</ol>
<p>准备就绪，开工</p>
<h4 id="创建csv文件"><a href="#创建csv文件" class="headerlink" title="创建csv文件"></a>创建csv文件</h4><ol>
<li>csv文件属性Square_Feet，Price</li>
<li>记录文件所存储位置，调用的时候需要</li>
</ol>
<h4 id="在终端输入生成-mlmodel文件"><a href="#在终端输入生成-mlmodel文件" class="headerlink" title="在终端输入生成.mlmodel文件"></a>在终端输入生成.mlmodel文件</h4><ol>
<li>导入需要的类</li>
<li>调用csv文件</li>
<li>coremltools转换成.mlmodel文件</li>
<li>author,license,description描述</li>
<li>输入Square_Feet，输出Price，保存</li>
</ol>
<ul>
<li><blockquote>
<blockquote>
<blockquote>
<p>import coremltools</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>from sklearn.linear_model import LinearRegression</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>import pandas as pd</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>data = pd.read_csv(‘/Users/sansi/Desktop/CoreMLModel/input_data.csv’)</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>model = LinearRegression()</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>model.fit(data[[“Square_Feet”]], data[“Price”])</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>coreml_model = coremltools.converters.sklearn.convert(model, “Square_Feet”, “Price”)</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>coreml_model.author = ‘tongle’</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>coreml_model.license = ‘BSD’</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>coreml_model.short_description = ‘Predicts the price of a house in the Seattle area.’</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>coreml_model.input_description[‘Square_Feet’] = ‘Size (in square feet)’</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>coreml_model.output_description[‘Price’] = ‘Price of the house’</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>coreml_model.save(‘HousePricer.mlmodel’)</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<p>如果没有一点python功底，我都要死在电脑前了，哈哈</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my blog. Thanks.&lt;/p&gt;
&lt;p&gt;Dome:&lt;a href=&quot;https://github.com/princeSmall/CoreMLModel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github地址&lt;/a&gt;&lt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="3" scheme="http://yoursite.com/tags/3/"/>
    
  </entry>
  
  <entry>
    <title>[iOS_CellAnimation]</title>
    <link href="http://yoursite.com/2017/09/12/iOS-CellAnimation/"/>
    <id>http://yoursite.com/2017/09/12/iOS-CellAnimation/</id>
    <published>2017-09-12T07:17:55.000Z</published>
    <updated>2017-11-24T08:15:09.469Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/CellAnimation" target="_blank" rel="external">github地址</a></p>
<p>最近在用cell动画，就研究修改了别人的cell动画，整理了一下。</p>
<p><img src="/2017/09/12/iOS-CellAnimation/CellAnimation.gif" alt="CellAnimation"></p>
<h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p>导入Animation类，直接用类调用,输入要动画的tableview和动画type，即可</p>
<pre>
 [Animation addAnimationWithTableView:tableView andRow:self.type];
</pre>

<h3 id="UITableViewCell-出场动画："><a href="#UITableViewCell-出场动画：" class="headerlink" title="UITableViewCell 出场动画："></a>UITableViewCell 出场动画：</h3><p>简而明了的说就是利用cell的contentView来做一下出场动画animation</p>
<pre>
 CGFloat width = [[UIScreen mainScreen] bounds].size.width - 40;
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(20, 10, width, 60)];
    view.backgroundColor = [UIColor redColor];
    view.layer.masksToBounds = YES;
    view.layer.cornerRadius = 9.0;
    [cell.contentView addSubview:view];
</pre>

<h3 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h3><h4 id="move动画"><a href="#move动画" class="headerlink" title="move动画"></a>move动画</h4><pre>
+ (void)moveAnimationWithTableView:(UITableView *)tableView {

    NSArray *cells = tableView.visibleCells;
    for (int i = 0; i < cells.count; i++) {
        CGFloat totalTime = 0.4;
        UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i];
        cell.transform = CGAffineTransformMakeTranslation(-XS_SCREEN_WIDTH, 0);
        [UIView animateWithDuration:0.4 delay:i*(totalTime/cells.count) usingSpringWithDamping:0.7 initialSpringVelocity:1/0.7 options:UIViewAnimationOptionCurveEaseIn animations:^{
            cell.transform = CGAffineTransformIdentity;
        } completion:^(BOOL finished) {

        }];
    }
}
</pre>

<h4 id="alpha动画"><a href="#alpha动画" class="headerlink" title="alpha动画"></a>alpha动画</h4><pre>
+ (void)alphaAnimationWithTableView:(UITableView *)tableView {

    NSArray *cells = tableView.visibleCells;
    for (int i = 0; i < cells.count; i++) {
        UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i];
        cell.alpha = 0.0;
        [UIView animateWithDuration:0.3 delay:i*0.05 options:0 animations:^{
            cell.alpha = 1.0;
        } completion:^(BOOL finished) {

        }];
    }
}
</pre>

<h4 id="fall动画"><a href="#fall动画" class="headerlink" title="fall动画"></a>fall动画</h4><pre>
+ (void)fallAnimationWithTableView:(UITableView *)tableView {

    NSArray *cells = tableView.visibleCells;

    NSTimeInterval totalTime = 0.8;

    for (int i = 0; i < cells.count; i++) {
        UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i];
        cell.transform = CGAffineTransformMakeTranslation(0, - XS_SCREEN_HEIGHT);
        [UIView animateWithDuration:0.3 delay:(cells.count - i)*(totalTime/cells.count) options:0 animations:^{
            cell.transform = CGAffineTransformIdentity;
        } completion:^(BOOL finished) {

        }];
    }
}
</pre>

<h4 id="shake动画"><a href="#shake动画" class="headerlink" title="shake动画"></a>shake动画</h4><pre>
+ (void)shakeAnimationWithTableView:(UITableView *)tableView {

    NSArray *cells = tableView.visibleCells;
    for (int i = 0; i < cells.count; i++) {
        UITableViewCell *cell = [cells objectAtIndex:i];
        if (i%2 == 0) {
            cell.transform = CGAffineTransformMakeTranslation(-XS_SCREEN_WIDTH,0);
        }else {
            cell.transform = CGAffineTransformMakeTranslation(XS_SCREEN_WIDTH,0);
        }
        [UIView animateWithDuration:0.4 delay:i*0.03 usingSpringWithDamping:0.75 initialSpringVelocity:1/0.75 options:0 animations:^{
            cell.transform = CGAffineTransformIdentity;
        } completion:^(BOOL finished) {

        }];
    }
}
</pre>

<h4 id="overTurn动画"><a href="#overTurn动画" class="headerlink" title="overTurn动画"></a>overTurn动画</h4><pre>
+ (void)overTurnAnimationWithTableView:(UITableView *)tableView {

    NSArray *cells = tableView.visibleCells;
    for (int i = 0; i < cells.count; i++) {
        UITableViewCell *cell = [cells objectAtIndex:i];
        cell.layer.opacity = 0.0;
        cell.layer.transform = CATransform3DMakeRotation(M_PI, 1, 0, 0);
        NSTimeInterval totalTime = 0.7;
        [UIView animateWithDuration:0.3 delay:i*(totalTime/cells.count) options:0 animations:^{
            cell.layer.opacity = 1.0;
            cell.layer.transform = CATransform3DIdentity;
        } completion:^(BOOL finished) {

        }];

    }
}
</pre>

<h4 id="toTop动画"><a href="#toTop动画" class="headerlink" title="toTop动画"></a>toTop动画</h4><pre>
+ (void)toTopAnimationWithTableView:(UITableView *)tableView {


    NSArray *cells = tableView.visibleCells;

    NSTimeInterval totalTime = 0.8;

    for (int i = 0; i < cells.count; i++) {
        UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i];
        cell.transform = CGAffineTransformMakeTranslation(0,  XS_SCREEN_HEIGHT);
        [UIView animateWithDuration:0.35 delay:i*(totalTime/cells.count) options:UIViewAnimationOptionCurveEaseOut animations:^{
            cell.transform = CGAffineTransformIdentity;
        } completion:^(BOOL finished) {

        }];
    }
}
</pre>

<h4 id="spring动画"><a href="#spring动画" class="headerlink" title="spring动画"></a>spring动画</h4><pre>
+ (void)springListAnimationWithTableView:(UITableView *)tableView {

    NSArray *cells = tableView.visibleCells;
    for (int i = 0; i < cells.count; i++) {
        UITableViewCell *cell = [cells objectAtIndex:i];
        cell.layer.opacity = 0.7;
        cell.layer.transform = CATransform3DMakeTranslation(0, -XS_SCREEN_HEIGHT, 20);
        NSTimeInterval totalTime = 1.0;

        [UIView animateWithDuration:0.4 delay:i*(totalTime/cells.count) usingSpringWithDamping:0.65 initialSpringVelocity:1/0.65 options:UIViewAnimationOptionCurveEaseIn animations:^{
            cell.layer.opacity = 1.0;
            cell.layer.transform = CATransform3DMakeTranslation(0, 0, 20);
        } completion:^(BOOL finished) {

        }];
    }
}
</pre>

<h4 id="shrink动画"><a href="#shrink动画" class="headerlink" title="shrink动画"></a>shrink动画</h4><pre>
+ (void)shrinkToTopAnimationWithTableView:(UITableView *)tableView {
    NSArray *cells = tableView.visibleCells;
    for (int i = 0; i < cells.count; i++) {
        UITableViewCell *cell = [cells objectAtIndex:i];
        CGRect rect = [cell convertRect:cell.bounds fromView:tableView];
        cell.transform = CGAffineTransformMakeTranslation(0, -rect.origin.y);
        [UIView animateWithDuration:0.5 animations:^{
            cell.transform = CGAffineTransformIdentity;
        }];
    }
}
</pre>

<h3 id="laydown动画"><a href="#laydown动画" class="headerlink" title="laydown动画"></a>laydown动画</h3><pre>
+ (void)layDownAnimationWithTableView:(UITableView *)tableView {
    NSArray *cells = tableView.visibleCells;
    NSMutableArray *rectArr = [[NSMutableArray alloc] init];
    for (int i = 0; i < cells.count; i++) {
        UITableViewCell *cell = [cells objectAtIndex:i];
        CGRect rect = cell.frame;
        [rectArr addObject:[NSValue valueWithCGRect:rect]];
        rect.origin.y = i * 10;
        cell.frame = rect;
        cell.layer.transform = CATransform3DMakeTranslation(0, 0, i*5);
    }
    NSTimeInterval totalTime = 0.8;
    for (int i = 0; i < cells.count; i++) {
        UITableViewCell *cell = [cells objectAtIndex:i];
        CGRect rect = [[rectArr objectAtIndex:i] CGRectValue];
        [UIView animateWithDuration:(totalTime/cells.count) * i animations:^{
            cell.frame = rect;
        } completion:^(BOOL finished) {
            cell.layer.transform = CATransform3DIdentity;
        }];
    }

}
</pre>

<h4 id="rote动画"><a href="#rote动画" class="headerlink" title="rote动画"></a>rote动画</h4><pre>
+ (void)roteAnimationWithTableView:(UITableView *)tableView {

    NSArray *cells = tableView.visibleCells;
    CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"transform.rotation.y"];
    animation.fromValue = @(-M_PI);
    animation.toValue = 0;
    animation.duration = 0.3;
    animation.removedOnCompletion = NO;
    animation.repeatCount = 3;
    animation.fillMode = kCAFillModeForwards;
    animation.autoreverses = NO;

    for (int i = 0; i < cells.count; i++) {
        UITableViewCell *cell = [cells objectAtIndex:i];

        cell.alpha = 0.0;
        [UIView animateWithDuration:0.1 delay:i*0.25 options:0 animations:^{
            cell.alpha = 1.0;
        } completion:^(BOOL finished) {
            [cell.layer addAnimation:animation forKey:@"rotationYkey"];
        }];
    }
}
</pre>


]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my blog. Thanks.&lt;/p&gt;
&lt;p&gt;Dome: &lt;a href=&quot;https://github.com/princeSmall/CellAnimation&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github地址&lt;/
    
    </summary>
    
      <category term="OC" scheme="http://yoursite.com/categories/OC/"/>
    
    
      <category term="2" scheme="http://yoursite.com/tags/2/"/>
    
  </entry>
  
  <entry>
    <title>[iOS-QRCodeImage]</title>
    <link href="http://yoursite.com/2017/09/11/iOS-QRCodeImage/"/>
    <id>http://yoursite.com/2017/09/11/iOS-QRCodeImage/</id>
    <published>2017-09-11T01:08:33.000Z</published>
    <updated>2017-11-24T08:14:45.272Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/QRCodeImage" target="_blank" rel="external">github地址</a></p>
<p>好几天没写博客了，正好在忙二维码的生成，扫描就里一个flag吧</p>
<p><img src="/2017/09/11/iOS-QRCodeImage/QRCode.gif" alt="gif"></p>
<h3 id="原始二维码"><a href="#原始二维码" class="headerlink" title="原始二维码"></a>原始二维码</h3><p>通过滤镜CIFilter生成二维码</p>
<ol>
<li>创建过滤器</li>
<li>给过滤器添加数据</li>
<li>设置滤镜inputMessage数据</li>
<li>输出二维码</li>
</ol>
<pre>
+ (CIImage *)qrCodeImageWithContent:(NSString *)content{
    CIFilter *qrFilter = [CIFilter filterWithName:@"CIQRCodeGenerator"];
    NSData *contentData = [content dataUsingEncoding:NSUTF8StringEncoding];
    [qrFilter setValue:contentData forKey:@"inputMessage"];
    [qrFilter setValue:@"H" forKey:@"inputCorrectionLevel"];
    CIImage *image = qrFilter.outputImage;
    return image;
}

void ProviderReleaseData (void *info, const void *data, size_t size){
    free((void*)data);
}
</pre>

<p>生成制定大小的二维码</p>
<ol>
<li>传入原始二维码数据</li>
<li>设置倍数scale</li>
<li>通过bitmapImage放大并保存</li>
</ol>
<pre>
+ (UIImage *)qrCodeImageWithContent:(NSString *)content codeImageSize:(CGFloat)size{
    CIImage *image = [self qrCodeImageWithContent:content];
    CGRect integralRect = CGRectIntegral(image.extent);
    CGFloat scale = MIN(size/CGRectGetWidth(integralRect), size/CGRectGetHeight(integralRect));  
    size_t width = CGRectGetWidth(integralRect)*scale;
    size_t height = CGRectGetHeight(integralRect)*scale;
    CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceGray();
    CGContextRef bitmapRef = CGBitmapContextCreate(nil, width, height, 8, 0, colorSpaceRef, (CGBitmapInfo)kCGImageAlphaNone);
    CIContext *context = [CIContext contextWithOptions:nil];
    CGImageRef bitmapImage = [context createCGImage:image fromRect:integralRect];
    CGContextSetInterpolationQuality(bitmapRef, kCGInterpolationNone);
    CGContextScaleCTM(bitmapRef, scale, scale);
    CGContextDrawImage(bitmapRef, integralRect, bitmapImage);

    CGImageRef scaledImage = CGBitmapContextCreateImage(bitmapRef);
    CGContextRelease(bitmapRef);
    CGImageRelease(bitmapImage);
    return [UIImage imageWithCGImage:scaledImage];
}
</pre>



<h3 id="原始条形码"><a href="#原始条形码" class="headerlink" title="原始条形码"></a>原始条形码</h3><p>通过滤镜CIFilter生成二维码</p>
<ol>
<li>创建过滤器</li>
<li>给过滤器添加数据</li>
<li>设置滤镜inputMessage数据</li>
<li>输出二维码</li>
</ol>
<pre>
+ (CIImage *)barcodeImageWithContent:(NSString *)content{
    CIFilter *qrFilter = [CIFilter filterWithName:@"CICode128BarcodeGenerator"];
    NSData *contentData = [content dataUsingEncoding:NSUTF8StringEncoding];
    [qrFilter setValue:contentData forKey:@"inputMessage"];
    [qrFilter setValue:@(0.00) forKey:@"inputQuietSpace"];
    CIImage *image = qrFilter.outputImage;
    return image;
}

void ProviderReleaseData (void *info, const void *data, size_t size){
    free((void*)data);
}
</pre>

<p>生成定制大小的条形码</p>
<ol>
<li>传入原始二维码数据</li>
<li>设置倍数scale</li>
<li>通过bitmapImage放大并保存</li>
</ol>
<pre>
+ (UIImage *)barcodeImageWithContent:(NSString *)content codeImageSize:(CGSize)size{
    CIImage *image = [self barcodeImageWithContent:content];
    CGRect integralRect = CGRectIntegral(image.extent);
    CGFloat scale = MIN(size.width/CGRectGetWidth(integralRect), size.height/CGRectGetHeight(integralRect));  
    size_t width = CGRectGetWidth(integralRect)*scale;
    size_t height = CGRectGetHeight(integralRect)*scale;
    CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceGray();
    CGContextRef bitmapRef = CGBitmapContextCreate(nil, width, height, 8, 0, colorSpaceRef, (CGBitmapInfo)kCGImageAlphaNone);
    CIContext *context = [CIContext contextWithOptions:nil];
    CGImageRef bitmapImage = [context createCGImage:image fromRect:integralRect];
    CGContextSetInterpolationQuality(bitmapRef, kCGInterpolationNone);
    CGContextScaleCTM(bitmapRef, scale, scale);
    CGContextDrawImage(bitmapRef, integralRect, bitmapImage);

    CGImageRef scaledImage = CGBitmapContextCreateImage(bitmapRef);
    CGContextRelease(bitmapRef);
    CGImageRelease(bitmapImage);
    return [UIImage imageWithCGImage:scaledImage];
}
</pre>


<h3 id="彩色二维码"><a href="#彩色二维码" class="headerlink" title="彩色二维码"></a>彩色二维码</h3><p>获取原始二维码改变像素点颜色</p>
<ol>
<li>@param content 二维码数据</li>
<li>@param size 二维码大小</li>
<li>@param red 0 ~ 1.0</li>
<li>@param green 0 ~ 1.0</li>
<li>@param blue 0 ~ 1.0</li>
</ol>
<pre>
+ (UIImage *)qrCodeImageWithContent:(NSString *)content codeImageSize:(CGFloat)size red:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue{
    UIImage *image = [self qrCodeImageWithContent:content codeImageSize:size];
    int imageWidth = image.size.width;
    int imageHeight = image.size.height;
    size_t bytesPerRow = imageWidth * 4;
    uint32_t *rgbImageBuf = (uint32_t *)malloc(bytesPerRow * imageHeight);
    CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(rgbImageBuf, imageWidth, imageHeight, 8, bytesPerRow, colorSpaceRef, kCGBitmapByteOrder32Little|kCGImageAlphaNoneSkipLast);
    CGContextDrawImage(context, CGRectMake(0, 0, imageWidth, imageHeight), image.CGImage);
    //遍历像素, 改变像素点颜色
    int pixelNum = imageWidth * imageHeight;
    uint32_t *pCurPtr = rgbImageBuf;
    for (int i = 0; i< pixelNum; i++, pCurPtr++) {
        if ((*pCurPtr & 0xFFFFFF00) < 0x99999900) {
            uint8_t* ptr = (uint8_t*)pCurPtr;
            ptr[3] = red*255;
            ptr[2] = green*255;
            ptr[1] = blue*255;
        }else{
            uint8_t* ptr = (uint8_t*)pCurPtr;
            ptr[0] = 0;
        }
    }
    //取出图片
    CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, rgbImageBuf, bytesPerRow * imageHeight, ProviderReleaseData);
    CGImageRef imageRef = CGImageCreate(imageWidth, imageHeight, 8, 32, bytesPerRow, colorSpaceRef,
                                        kCGImageAlphaLast | kCGBitmapByteOrder32Little, dataProvider,
                                        NULL, true, kCGRenderingIntentDefault);
    CGDataProviderRelease(dataProvider);
    UIImage *resultImage = [UIImage imageWithCGImage:imageRef];
    CGImageRelease(imageRef);
    CGContextRelease(context);
    CGColorSpaceRelease(colorSpaceRef);

    return resultImage;
}
</pre>

<p>给二维码添加中心logo</p>
<pre>
+ (UIImage *)qrCodeImageWithContent:(NSString *)content
                      codeImageSize:(CGFloat)size
                               logo:(UIImage *)logo
                          logoFrame:(CGRect)logoFrame
                                red:(CGFloat)red
                              green:(CGFloat)green
                               blue:(CGFloat)blue{
    UIImage * image = [self qrCodeImageWithContent:content codeImageSize:size red:red green:green blue:blue];   
    if (logo != nil) {
        UIGraphicsBeginImageContext(image.size);
        [image drawInRect:CGRectMake(0, 0, image.size.width, image.size.height)];
        [logo drawInRect:logoFrame];
        UIImage *resultImage = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();
        return resultImage;
    }else{
        return image;
    }   
}
</pre>

<h3 id="彩色条形码"><a href="#彩色条形码" class="headerlink" title="彩色条形码"></a>彩色条形码</h3><p>获取原始二维码改变像素点颜色</p>
<ol>
<li>@param content 二维码数据</li>
<li>@param size 二维码大小</li>
<li>@param red 0 ~ 1.0</li>
<li>@param green 0 ~ 1.0</li>
<li>@param blue 0 ~ 1.0</li>
</ol>
<pre>
+ (UIImage *)barcodeImageWithContent:(NSString *)content codeImageSize:(CGSize)size red:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue{
    UIImage *image = [self barcodeImageWithContent:content codeImageSize:size];
    int imageWidth = image.size.width;
    int imageHeight = image.size.height;
    size_t bytesPerRow = imageWidth * 4;
    uint32_t *rgbImageBuf = (uint32_t *)malloc(bytesPerRow * imageHeight);
    CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(rgbImageBuf, imageWidth, imageHeight, 8, bytesPerRow, colorSpaceRef, kCGBitmapByteOrder32Little|kCGImageAlphaNoneSkipLast);
    CGContextDrawImage(context, CGRectMake(0, 0, imageWidth, imageHeight), image.CGImage);
    //遍历像素, 改变像素点颜色
    int pixelNum = imageWidth * imageHeight;
    uint32_t *pCurPtr = rgbImageBuf;
    for (int i = 0; i< pixelNum; i++, pCurPtr++) {
        if ((*pCurPtr & 0xFFFFFF00) < 0x99999900) {
            uint8_t* ptr = (uint8_t*)pCurPtr;
            ptr[3] = red*255;
            ptr[2] = green*255;
            ptr[1] = blue*255;
        }else{
            uint8_t* ptr = (uint8_t*)pCurPtr;
            ptr[0] = 0;
        }
    }
    //取出图片
    CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, rgbImageBuf, bytesPerRow * imageHeight, ProviderReleaseData);
    CGImageRef imageRef = CGImageCreate(imageWidth, imageHeight, 8, 32, bytesPerRow, colorSpaceRef,
                                        kCGImageAlphaLast | kCGBitmapByteOrder32Little, dataProvider,
                                        NULL, true, kCGRenderingIntentDefault);
    CGDataProviderRelease(dataProvider);
    UIImage *resultImage = [UIImage imageWithCGImage:imageRef];
    CGImageRelease(imageRef);
    CGContextRelease(context);
    CGColorSpaceRelease(colorSpaceRef); 
    return resultImage;
}
</pre>

<h3 id="渐变二维码"><a href="#渐变二维码" class="headerlink" title="渐变二维码"></a>渐变二维码</h3><p>绘制黑白二维码</p>
<pre>
- (UIImage *)genQRCodeImageMask:(UIImage *)image {
    if (image != nil) {
        int bitsPerComponent = 8;
        int bytesPerPixel = 4;
        int width = image.size.width;
        int height = image.size.height;
        unsigned char * imageData = (unsigned char *)malloc(width * height * bytesPerPixel);

        // 将原始黑白二维码图片绘制到像素格式为ARGB的图片上，绘制后的像素数据在imageData中。
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef imageContext = CGBitmapContextCreate(imageData, width, height, bitsPerComponent, bytesPerPixel * width, colorSpace, kCGImageAlphaPremultipliedFirst);
        UIGraphicsPushContext(imageContext);
        CGContextTranslateCTM(imageContext, 0, height);
        CGContextScaleCTM(imageContext, 1, -1);
        [image drawInRect:CGRectMake(0, 0, width, height)];

        CGColorSpaceRelease(colorSpace);

        // 根据每个像素R通道的值修改Alpha通道的值，当Red大于100，则将Alpha置为0，反之置为255
        for (int row = 0; row < height; ++row) {
            for (int col = 0; col < width; ++col) {
                int offset = row * width * bytesPerPixel + col * bytesPerPixel;
                unsigned char r = imageData[offset + 1];
                unsigned char alpha = r > 100 ? 0 : 255;
                imageData[offset] = alpha;
            }
        }

        CGImageRef cgMaskImage = CGBitmapContextCreateImage(imageContext);
        UIImage *maskImage = [UIImage imageWithCGImage:cgMaskImage];
        CFRelease(cgMaskImage);
        UIGraphicsPopContext();
        CFRelease(imageContext);

        free(imageData);
        return maskImage;
    }
    return nil;
}
</pre>

<p>设置蒙层的颜色</p>
<pre>
- (CAGradientLayer *)gradientLayer {
    if (_gradientLayer == nil) {
        _gradientLayer = [CAGradientLayer new];
        _gradientLayer.colors = @[
                                  (__bridge id)[UIColor colorWithRed: 0x2a / 255.0 green:0x9c / 255.0 blue: 0x1f / 255.0 alpha:1.0].CGColor,
                                  (__bridge id)[UIColor colorWithRed: 0xe6 / 255.0 green:0xcd / 255.0 blue: 0x27 / 255.0 alpha:1.0].CGColor,
                                  (__bridge id)[UIColor colorWithRed: 0xe6 / 255.0 green:0x27 / 255.0 blue: 0x57 / 255.0 alpha:1.0].CGColor
                                  ];
        [self.layer addSublayer: _gradientLayer];
        _gradientLayer.frame = self.bounds;
    }
    return _gradientLayer;
}
</pre>

<p>添加蒙层，设置黑白二维码图片</p>
<pre>- (void)setQRCodeImage:(UIImage *)qrcodeImage {
    UIImage *maskImage = [self genQRCodeImageMask: qrcodeImage];
    self.maskLayer.contents = (__bridge id)maskImage.CGImage;
    self.maskLayer.frame = self.bounds;
    self.gradientLayer.mask = self.maskLayer;
}
</pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my blog. Thanks.&lt;/p&gt;
&lt;p&gt;Dome: &lt;a href=&quot;https://github.com/princeSmall/QRCodeImage&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github地址&lt;/a&gt;
    
    </summary>
    
      <category term="OC" scheme="http://yoursite.com/categories/OC/"/>
    
    
      <category term="2" scheme="http://yoursite.com/tags/2/"/>
    
  </entry>
  
  <entry>
    <title>[iOS物理动画引擎_UIDynamic]</title>
    <link href="http://yoursite.com/2017/09/05/iOS%E7%89%A9%E7%90%86%E5%8A%A8%E7%94%BB%E5%BC%95%E6%93%8E-UIDynamic/"/>
    <id>http://yoursite.com/2017/09/05/iOS物理动画引擎-UIDynamic/</id>
    <published>2017-09-05T05:52:22.000Z</published>
    <updated>2017-11-24T08:14:36.640Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Welcome-to-my-blog-Thanks"><a href="#Welcome-to-my-blog-Thanks" class="headerlink" title="Welcome to my blog. Thanks."></a>Welcome to my blog. Thanks.</h3><p>Dome: <a href="https://github.com/princeSmall/UIDynamic" target="_blank" rel="external">github地址</a></p>
<p>iOS物理动画引擎-UIDynamic</p>
<p><img src="/2017/09/05/iOS物理动画引擎-UIDynamic/UIDynamic.gif" alt="UIDynamic"></p>
<h3 id="UIDynamicBehavior-仿真行为"><a href="#UIDynamicBehavior-仿真行为" class="headerlink" title="UIDynamicBehavior 仿真行为"></a>UIDynamicBehavior 仿真行为</h3><ol>
<li>创建一个仿真者,用来仿真所有的物理行为</li>
</ol>
<pre>
 animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view]
 </pre>
2. 创建具体的物理仿真行为

<pre>
gravity = [[UIGravityBehavior alloc]init]
collision = [[UICollisionBehavior alloc]init]
snapBehavior = [[UISnapBehavior alloc] init]
itemBehavior = [[UIDynamicItemBehavior alloc] init]
</pre>
3. 将物理仿真行为添加给仿真者实现仿真效果。

<pre>
 -(void)addBehavior:(UIDynamicBehavior *)behavior;
 -(void)removeBehavior:(UIDynamicBehavior *)behavior;
 -(void)removeAllBehaviors;
</pre>

<h3 id="UIGravityBehavior-重力行为"><a href="#UIGravityBehavior-重力行为" class="headerlink" title="UIGravityBehavior 重力行为"></a>UIGravityBehavior 重力行为</h3><ul>
<li>创建仿真者</li>
</ul>
<pre>
 self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];
</pre>

<ul>
<li>创建仿真行为</li>
</ul>
<pre>
-(UIGravityBehavior *)gravity{
    if (_gravity == nil) {
        _gravity = [[UIGravityBehavior alloc]init];
    }
    return _gravity;
}
-(UICollisionBehavior *)collision{
    if (_collision == nil) {
        _collision = [[UICollisionBehavior alloc]init];
    }
    return _collision;
}
</pre>

<ul>
<li>触碰屏幕生成重力小球</li>
</ul>
<pre>
-(void)touchesBegan:(NSSet<uitouch *=""> *)touches withEvent:(UIEvent *)event{
    UITouch * touch = touches.anyObject;
    CGPoint location = [touch locationInView:self.view];
    self.redView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, widthRed, widthRed)];
    self.redView.center = location;
    [self.view addSubview:self.redView];

    // 随机色方块
    self.redView.backgroundColor = randomColor;

    // 创建重力的物理仿真行为，并设置具体的items(需要仿真的view)
    [self.gravity addItem:self.redView];

    // 下落方向
    // [gravity setAngle:0.5];

    // 创建弹性的物理仿真行为，并设置具体的items(需要仿真的view)
    [self.collision addItem:self.redView];
    self.collision.translatesReferenceBoundsIntoBoundary = YES;

    // 将重力仿真行为添加给仿真者实现仿真效果，开始仿真
    [self.animator addBehavior:self.gravity];
    [self.animator addBehavior:self.collision];

}
</uitouch></pre>

<h3 id="UICollisionBehavior-碰撞行为"><a href="#UICollisionBehavior-碰撞行为" class="headerlink" title="UICollisionBehavior 碰撞行为"></a>UICollisionBehavior 碰撞行为</h3><ul>
<li>创建仿真者</li>
</ul>
<pre>
 self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];
</pre>

<ul>
<li>创建碰撞对象</li>
</ul>
<pre>
self.greenView = [[UIView alloc] initWithFrame:CGRectMake(100, 200, 100, 30)];
self.greenView.backgroundColor = [UIColor greenColor];
[self.view addSubview:self.greenView];

self.blueView = [[UIView alloc] initWithFrame:CGRectMake(120, 300, 100, 30)];
self.blueView.backgroundColor = [UIColor blueColor];
[self.view addSubview:self.blueView];

  //未绑定仿真对象  
self.blackView = [[UIView alloc] initWithFrame:CGRectMake(140, 400, 100, 30)];
self.blackView.backgroundColor = [UIColor blackColor];
[self.view addSubview:self.blackView];

  // 物体角度  
self.blueView.transform =  CGAffineTransformMakeRotation(M_PI_4);
self.greenView.transform = CGAffineTransformMakeRotation(-M_PI / 8);

</pre>

<ul>
<li>创建仿真行为</li>
</ul>
<pre>
-(UIGravityBehavior *)gravity{
    if (_gravity == nil) {
        _gravity = [[UIGravityBehavior alloc]init];
    }
    return _gravity;
}
-(UICollisionBehavior *)collision{
    if (_collision == nil) {
        _collision = [[UICollisionBehavior alloc]init];
    }
    return _collision;
}
</pre>

<ul>
<li>开始碰撞行为</li>
</ul>
<pre>
-(void)touchesBegan:(NSSet<uitouch *=""> *)touches withEvent:(UIEvent *)event{
    // 获取点击位置，生成仿真者
    UITouch * touch = touches.anyObject;
    CGPoint location = [touch locationInView:self.view];
    self.redView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, widthRed, widthRed)];
    self.redView.center = location;
    // pch中宏定义的随机色
    self.redView.backgroundColor = randomColor;
    [self.view addSubview:self.redView];
    [self.gravity addItem:self.redView];
    // 添加碰撞检测
    [self.collision addItem:self.redView];
    [self.collision addItem:self.greenView];
    [self.collision  addItem:self.blueView];
    self.collision.translatesReferenceBoundsIntoBoundary = YES;
    self.collision.collisionDelegate = self;


   __weak typeof(self) weakSelf = self;
        // 获取方块运动轨迹坐标
    self.collision.action = ^{
        NSLog(@"%@", NSStringFromCGRect(weakSelf.redView.frame));

    };

    CGFloat Y = self.view.frame.size.height;
    CGFloat X = self.view.frame.size.width;
    CGFloat height = self.view.frame.size.height;

    //设置红色的View为底边界,左边框跟右边框作为边界
    [self.collision addBoundaryWithIdentifier:@"collision1" fromPoint:CGPointMake(0,Y) toPoint:CGPointMake(X, Y)];
    [self.collision addBoundaryWithIdentifier:@"collision2" fromPoint:CGPointMake(0, 0) toPoint:CGPointMake(0, height)];
    [self.collision addBoundaryWithIdentifier:@"collision3" fromPoint:CGPointMake(X,0) toPoint:CGPointMake(X, height)];
    [self.animator addBehavior:self.collision];
    [self.animator addBehavior:self.gravity];  
}
</uitouch></pre>

<ul>
<li>碰撞开始时给被碰撞的物体添加重力仿真</li>
</ul>
<pre>
// UICollisionBehavior 代理行为
- (void)collisionBehavior:(UICollisionBehavior*)behavior beganContactForItem:(id <uidynamicitem>)item withBoundaryIdentifier:(nullable id <nscopying>)identifier atPoint:(CGPoint)p{

    if ([item isEqual:self.greenView]) {
        UIGravityBehavior * gravity = [[UIGravityBehavior alloc] initWithItems:@[self.greenView]];
        [self.animator addBehavior:gravity];
    }else if ([item isEqual:self.blueView]){
        UIGravityBehavior * gravity = [[UIGravityBehavior alloc] initWithItems:@[self.blueView]];
        [self.animator addBehavior:gravity];
    }

}
</nscopying></uidynamicitem></pre>

<h3 id="UISnapBehavior-吸附行为"><a href="#UISnapBehavior-吸附行为" class="headerlink" title="UISnapBehavior 吸附行为"></a>UISnapBehavior 吸附行为</h3><ul>
<li>创建仿真者</li>
</ul>
<pre>
self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];
</pre>

<ul>
<li>创建吸附对象</li>
</ul>
<pre>
-(UIView *)redView{
    if (_redView ==nil) {
        _redView = [[UIView alloc]initWithFrame:CGRectMake(p.x, p.y, 50, 50)];
        _redView.backgroundColor = [UIColor redColor];
        [self.view addSubview:_redView];
    }
    return _redView;
}
</pre>

<ul>
<li>开始吸附行为</li>
</ul>
<pre>
-(void)touchesBegan:(NSSet<uitouch *=""> *)touches withEvent:(UIEvent *)event{

    [self.animator removeAllBehaviors];
    UITouch * touch = touches.anyObject;
    CGPoint location = [touch locationInView:self.view];
    p = location;
    NSLog(@"%@",NSStringFromCGPoint(location));
     // 3 添加吸附事件
     UISnapBehavior *snap = [[UISnapBehavior alloc] initWithItem:self.redView snapToPoint:location];
    // 改变震动幅度，0表示振幅最大，1振幅最小
    snap.damping = 0.5;
    // 4. 将吸附事件添加到仿真者行为中
    [self.animator addBehavior:snap];

}
</uitouch></pre>

<h3 id="UIDynamicItemBehavior-迅猛移动弹跳摆动行为"><a href="#UIDynamicItemBehavior-迅猛移动弹跳摆动行为" class="headerlink" title="UIDynamicItemBehavior 迅猛移动弹跳摆动行为"></a>UIDynamicItemBehavior 迅猛移动弹跳摆动行为</h3><ul>
<li>创建仿真者</li>
</ul>
<pre>
self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];
</pre>

<ul>
<li>创建仿真行为</li>
</ul>
<pre>
-(UIGravityBehavior *)gravity{
    if (_gravity == nil) {
        _gravity = [[UIGravityBehavior alloc]init];
    }
    return _gravity;
}
-(UICollisionBehavior *)collision{
    if (_collision == nil) {
        _collision = [[UICollisionBehavior alloc]init];
         [_collision addBoundaryWithIdentifier:@"barrier" forPath:[UIBezierPath bezierPathWithRect:self.view.bounds]];
        _collision.translatesReferenceBoundsIntoBoundary = YES;
    }
    return _collision;
}
-(UIDynamicItemBehavior *)itemBehavior{
    if (_itemBehavior == nil) {
        _itemBehavior = [[UIDynamicItemBehavior alloc] init];
        _itemBehavior.elasticity = 1;
    }
    return _itemBehavior;
}
</pre>

<ul>
<li>生成小球，添加仿真事件</li>
</ul>
<pre>
-(void)touchesAddSquareView{
    float  viewWidth = 20;
    UIView * view = [[UIView alloc]initWithFrame:CGRectMake(p.x, p.y, viewWidth, viewWidth)];
    view.layer.cornerRadius = viewWidth / 2.0;
    view.backgroundColor = randomColor;
    [self performSelector:@selector(removeView:) withObject:view afterDelay:10];
    [self.view addSubview:view];
    [self.collision addItem:view];
    [self.itemBehavior addItem:view];
    [self.gravity addItem:view];
    [self.animator addBehavior:self.collision];
    [self.animator addBehavior:self.itemBehavior];
    [self.animator addBehavior:self.gravity];

}
</pre>

<ul>
<li>点触，移动和松开创建小球</li>
</ul>
<pre>
- (void)touchesBegan:(NSSet<uitouch *=""> *)touches withEvent:(UIEvent *)event
{
    UITouch * touch = touches.anyObject;
    CGPoint location = [touch locationInView:self.view];
    p = location;
    [self touchesAddSquareView];
}

- (void)touchesMoved:(NSSet<uitouch *=""> *)touches withEvent:(UIEvent *)event
{
    UITouch * touch = touches.anyObject;
    CGPoint location = [touch locationInView:self.view];
    p = location;
   [self touchesAddSquareView];
}
- (void)touchesEnded:(NSSet<uitouch *=""> *)touches withEvent:(UIEvent *)event
{
    [self touchesAddSquareView];
}
</uitouch></uitouch></uitouch></pre>

<ul>
<li>10s后删除小球和其物理仿真行为</li>
</ul>
<pre>
-(void)removeView:(UIView *)view{
    if (view == nil) {
        return;
    }
    [UIView animateWithDuration:.5 animations:^{
        view.alpha = 0;
    } completion:^(BOOL finished) {
        [view removeFromSuperview];
        [self.collision removeItem:view];
        [self.itemBehavior removeItem:view];
        [self.gravity removeItem:view];
    }];

}
</pre>

]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Welcome-to-my-blog-Thanks&quot;&gt;&lt;a href=&quot;#Welcome-to-my-blog-Thanks&quot; class=&quot;headerlink&quot; title=&quot;Welcome to my blog. Thanks.&quot;&gt;&lt;/a&gt;Welcome t
    
    </summary>
    
      <category term="OC" scheme="http://yoursite.com/categories/OC/"/>
    
    
      <category term="1" scheme="http://yoursite.com/tags/1/"/>
    
  </entry>
  
  <entry>
    <title>[Swift_popAnimation实例]</title>
    <link href="http://yoursite.com/2017/08/28/Swift-popAnimation%E5%AE%9E%E4%BE%8B/"/>
    <id>http://yoursite.com/2017/08/28/Swift-popAnimation实例/</id>
    <published>2017-08-28T05:42:20.000Z</published>
    <updated>2017-08-28T06:18:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/hamburger" target="_blank" rel="external">github地址</a></p>
<p>情人节在写博客也是蛮拼的</p>
<ol>
<li>Pod pop 如 [Swift_popAnimation初级]</li>
</ol>
<h3 id="动画思路"><a href="#动画思路" class="headerlink" title="动画思路"></a>动画思路</h3><pre>
   三条杠变叉：中间杠的消失和两边杠的偏移。
   叉变三条杠：两边杠的偏移和中间杠的出现。
</pre>

<ol>
<li><p>三条杠用三个view来代替，添加在一个button上。声明全局属性</p>
<pre>
 var  hamburger = true
 var  hamburgerButton : UIButton?
 var  top:UIView?
 var  middle:UIView?
 var  bottom:UIView?
</pre>
</li>
<li><p>实例化对象</p>
<pre><code>self.hamburgerButton = UIButton()
self.hamburgerButton?.backgroundColor = UIColor.black
self.hamburgerButton?.frame = CGRect(x: 100, y: 200, width: 150, height: 150)     
self.hamburgerButton?.layer.cornerRadius = 75
self.view.addSubview(hamburgerButton!)
self.hamburgerButton?.addTarget(self, action:#selector(didTapHamburgerButton), for: UIControlEvents.touchUpInside)
//三道杠
let sectionWidth:CGFloat = 80.0
let sectionHeight:CGFloat = 11.0
//top
top = UIView(frame: CGRect(x: (self.hamburgerButton?.bounds.size.width)! / 2 - sectionWidth / 2, y: 40, width: sectionWidth, height: sectionHeight))
top?.backgroundColor = UIColor.white
top?.isUserInteractionEnabled = false
top?.layer.cornerRadius = sectionHeight / 2
self.hamburgerButton?.addSubview(top!)
//middle
middle = UIView(frame: CGRect(x: (self.hamburgerButton?.bounds.size.width)! / 2 - sectionWidth / 2, y: 69, width: sectionWidth, height: sectionHeight))
middle?.backgroundColor = UIColor.white
middle?.isUserInteractionEnabled = false
middle?.layer.cornerRadius = sectionHeight / 2
self.hamburgerButton?.addSubview(middle!)
//bottom
bottom = UIView(frame: CGRect(x: (self.hamburgerButton?.bounds.size.width)! / 2 - sectionWidth / 2, y: 99, width: sectionWidth, height: sectionHeight))
bottom?.backgroundColor = UIColor.white
bottom?.isUserInteractionEnabled = false
bottom?.layer.cornerRadius = sectionHeight / 2
self.hamburgerButton?.addSubview(bottom!)
</code></pre></li>
</ol>
<h3 id="pop对象复用"><a href="#pop对象复用" class="headerlink" title="pop对象复用"></a>pop对象复用</h3><ol>
<li>颜色动画：<pre>
     var topColor = self.top?.pop_animation(forKey: "topColor") as! POPSpringAnimation?
     var bottomColor = self.top?.pop_animation(forKey: "bottomColor") as! POPSpringAnimation?
</pre></li>
<li>旋转动画：<pre>
     var topRotate = self.top?.layer.pop_animation(forKey: "topRotate") as! POPSpringAnimation?
     var bottomRotate = self.top?.layer.pop_animation(forKey: "bottomRotate") as! POPSpringAnimation?
</pre></li>
<li>位置动画：<pre>
     var topPosition = self.top?.layer.pop_animation(forKey: "topPosition")as!POPSpringAnimation?
     var bottomPosition = self.top?.layer.pop_animation(forKey: "bottomPosition")as!POPSpringAnimation?
</pre>

</li>
</ol>
<h3 id="三道杠变红叉叉"><a href="#三道杠变红叉叉" class="headerlink" title="三道杠变红叉叉"></a>三道杠变红叉叉</h3><pre>
 hamburger = false
            UIView.animate(withDuration: 0.2, animations: {
                self.middle?.alpha = 0
            })
            //变色
            if topColor != nil {
                topColor?.toValue = UIColor.red
            }else{
                topColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor)
                topColor?.toValue = UIColor.red
                topColor?.springBounciness = 0
                topColor?.springSpeed = 18
                top?.pop_add(topColor, forKey: "topColor")
            }
            if bottomColor != nil {
                bottomColor?.toValue = UIColor.red
            }else{
                bottomColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor)
                bottomColor?.toValue = UIColor.red
                bottomColor?.springBounciness = 0
                bottomColor?.springSpeed = 18
                bottom?.pop_add(topColor, forKey: "bottomColor")
            }
            //旋转
            if topRotate != nil {
                topRotate?.toValue = -Double.pi / 4
            }else{
                topRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation)
                topRotate?.toValue = -Double.pi / 4
                topRotate?.springBounciness = 11
                topRotate?.springSpeed = 18
                top?.layer.pop_add(topRotate, forKey: "topRotate")
            }
            if bottomRotate != nil {
                bottomRotate?.toValue = Double.pi / 4
            }else{
                bottomRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation)
                bottomRotate?.toValue = Double.pi / 4
                bottomRotate?.springBounciness = 11
                bottomRotate?.springSpeed = 18
                bottom?.layer.pop_add(bottomRotate, forKey: "bottomRotate")
            }
            //移动
            if topPosition != nil {
                topPosition?.toValue = 29
            }else{
                topPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY)
                topPosition?.toValue = 29
                topPosition?.springBounciness = 11
                topPosition?.springSpeed = 18
                top?.layer.pop_add(topPosition, forKey: "topPosition")
            }
            if bottomPosition != nil {
                bottomPosition?.toValue = -29
            }else{
                bottomPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY)
                bottomPosition?.toValue = -29
                bottomPosition?.springBounciness = 11
                bottomPosition?.springSpeed = 18
                bottom?.layer.pop_add(bottomPosition, forKey: "bottomPosition")
            }

}
</pre>

<h3 id="红叉叉变三道杠-逆向-gt-就还原一起改变值"><a href="#红叉叉变三道杠-逆向-gt-就还原一起改变值" class="headerlink" title="红叉叉变三道杠:逆向-&gt;就还原一起改变值"></a>红叉叉变三道杠:逆向-&gt;就还原一起改变值</h3><pre>
   hamburger = true
            UIView.animate(withDuration: 0.2, animations: {
                self.middle?.alpha = 1
            })
            //变色
            if topColor != nil {
                topColor?.toValue = UIColor.white
            }else{
                topColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor)
                topColor?.toValue = UIColor.white
                topColor?.springBounciness = 0
                topColor?.springSpeed = 18
                top?.pop_add(topColor, forKey: "topColor")
            }
            if bottomColor != nil {
                bottomColor?.toValue = UIColor.white
            }else{
                bottomColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor)
                bottomColor?.toValue = UIColor.white
                bottomColor?.springBounciness = 0
                bottomColor?.springSpeed = 18
                bottom?.pop_add(topColor, forKey: "bottomColor")
            }
            //旋转
            if topRotate != nil {
                topRotate?.toValue = 0
            }else{
                topRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation)
                topRotate?.toValue = 0
                topRotate?.springBounciness = 11
                topRotate?.springSpeed = 18
                top?.layer.pop_add(topRotate, forKey: "topRotate")
            }
            if bottomRotate != nil {
                bottomRotate?.toValue = 0
            }else{
                bottomRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation)
                bottomRotate?.toValue = 0
                bottomRotate?.springBounciness = 11
                bottomRotate?.springSpeed = 18
                bottom?.layer.pop_add(bottomRotate, forKey: "bottomRotate")
            }
            //移动
            if topPosition != nil {
                topPosition?.toValue = 0
            }else{
                topPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY)
                topPosition?.toValue = 0
                topPosition?.springBounciness = 11
                topPosition?.springSpeed = 18
                top?.layer.pop_add(topPosition, forKey: "topPosition")
            }
            if bottomPosition != nil {
                bottomPosition?.toValue = 0
            }else{
                bottomPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY)
                bottomPosition?.toValue = 0
                bottomPosition?.springBounciness = 11
                bottomPosition?.springSpeed = 18
                bottom?.layer.pop_add(bottomPosition, forKey: "bottomPosition")
            }


        }

    }
</pre>

<p>so easy<br><img src="/2017/08/28/Swift-popAnimation实例/san.png" alt=""><br><img src="/2017/08/28/Swift-popAnimation实例/hong.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my blog. Thanks.&lt;/p&gt;
&lt;p&gt;Dome: &lt;a href=&quot;https://github.com/princeSmall/hamburger&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github地址&lt;/a&gt;&lt;/
    
    </summary>
    
      <category term="Swift" scheme="http://yoursite.com/categories/Swift/"/>
    
    
      <category term="3" scheme="http://yoursite.com/tags/3/"/>
    
  </entry>
  
</feed>
