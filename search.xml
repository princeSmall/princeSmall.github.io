<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[[iOS-QRCodeImage]]]></title>
      <url>/2017/09/11/iOS-QRCodeImage/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/QRCodeImage" target="_blank" rel="external">github地址</a></p>
<p>好几天没写博客了，正好在忙二维码的生成，扫描就里一个flag吧</p>
<p><img src="/2017/09/11/iOS-QRCodeImage/QRCode.gif" alt="gif"></p>
<h3 id="原始二维码"><a href="#原始二维码" class="headerlink" title="原始二维码"></a>原始二维码</h3><p>通过滤镜CIFilter生成二维码</p>
<ol>
<li>创建过滤器</li>
<li>给过滤器添加数据</li>
<li>设置滤镜inputMessage数据</li>
<li>输出二维码</li>
</ol>
<pre>
+ (CIImage *)qrCodeImageWithContent:(NSString *)content{
    CIFilter *qrFilter = [CIFilter filterWithName:@"CIQRCodeGenerator"];
    NSData *contentData = [content dataUsingEncoding:NSUTF8StringEncoding];
    [qrFilter setValue:contentData forKey:@"inputMessage"];
    [qrFilter setValue:@"H" forKey:@"inputCorrectionLevel"];
    CIImage *image = qrFilter.outputImage;
    return image;
}

void ProviderReleaseData (void *info, const void *data, size_t size){
    free((void*)data);
}
</pre>

<p>生成制定大小的二维码</p>
<ol>
<li>传入原始二维码数据</li>
<li>设置倍数scale</li>
<li>通过bitmapImage放大并保存</li>
</ol>
<pre>
+ (UIImage *)qrCodeImageWithContent:(NSString *)content codeImageSize:(CGFloat)size{
    CIImage *image = [self qrCodeImageWithContent:content];
    CGRect integralRect = CGRectIntegral(image.extent);
    CGFloat scale = MIN(size/CGRectGetWidth(integralRect), size/CGRectGetHeight(integralRect));  
    size_t width = CGRectGetWidth(integralRect)*scale;
    size_t height = CGRectGetHeight(integralRect)*scale;
    CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceGray();
    CGContextRef bitmapRef = CGBitmapContextCreate(nil, width, height, 8, 0, colorSpaceRef, (CGBitmapInfo)kCGImageAlphaNone);
    CIContext *context = [CIContext contextWithOptions:nil];
    CGImageRef bitmapImage = [context createCGImage:image fromRect:integralRect];
    CGContextSetInterpolationQuality(bitmapRef, kCGInterpolationNone);
    CGContextScaleCTM(bitmapRef, scale, scale);
    CGContextDrawImage(bitmapRef, integralRect, bitmapImage);

    CGImageRef scaledImage = CGBitmapContextCreateImage(bitmapRef);
    CGContextRelease(bitmapRef);
    CGImageRelease(bitmapImage);
    return [UIImage imageWithCGImage:scaledImage];
}
</pre>



<h3 id="原始条形码"><a href="#原始条形码" class="headerlink" title="原始条形码"></a>原始条形码</h3><p>通过滤镜CIFilter生成二维码</p>
<ol>
<li>创建过滤器</li>
<li>给过滤器添加数据</li>
<li>设置滤镜inputMessage数据</li>
<li>输出二维码</li>
</ol>
<pre>
+ (CIImage *)barcodeImageWithContent:(NSString *)content{
    CIFilter *qrFilter = [CIFilter filterWithName:@"CICode128BarcodeGenerator"];
    NSData *contentData = [content dataUsingEncoding:NSUTF8StringEncoding];
    [qrFilter setValue:contentData forKey:@"inputMessage"];
    [qrFilter setValue:@(0.00) forKey:@"inputQuietSpace"];
    CIImage *image = qrFilter.outputImage;
    return image;
}

void ProviderReleaseData (void *info, const void *data, size_t size){
    free((void*)data);
}
</pre>

<p>生成定制大小的条形码</p>
<ol>
<li>传入原始二维码数据</li>
<li>设置倍数scale</li>
<li>通过bitmapImage放大并保存</li>
</ol>
<pre>
+ (UIImage *)barcodeImageWithContent:(NSString *)content codeImageSize:(CGSize)size{
    CIImage *image = [self barcodeImageWithContent:content];
    CGRect integralRect = CGRectIntegral(image.extent);
    CGFloat scale = MIN(size.width/CGRectGetWidth(integralRect), size.height/CGRectGetHeight(integralRect));  
    size_t width = CGRectGetWidth(integralRect)*scale;
    size_t height = CGRectGetHeight(integralRect)*scale;
    CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceGray();
    CGContextRef bitmapRef = CGBitmapContextCreate(nil, width, height, 8, 0, colorSpaceRef, (CGBitmapInfo)kCGImageAlphaNone);
    CIContext *context = [CIContext contextWithOptions:nil];
    CGImageRef bitmapImage = [context createCGImage:image fromRect:integralRect];
    CGContextSetInterpolationQuality(bitmapRef, kCGInterpolationNone);
    CGContextScaleCTM(bitmapRef, scale, scale);
    CGContextDrawImage(bitmapRef, integralRect, bitmapImage);

    CGImageRef scaledImage = CGBitmapContextCreateImage(bitmapRef);
    CGContextRelease(bitmapRef);
    CGImageRelease(bitmapImage);
    return [UIImage imageWithCGImage:scaledImage];
}
</pre>


<h3 id="彩色二维码"><a href="#彩色二维码" class="headerlink" title="彩色二维码"></a>彩色二维码</h3><p>获取原始二维码改变像素点颜色</p>
<ol>
<li>@param content 二维码数据</li>
<li>@param size 二维码大小</li>
<li>@param red 0 ~ 1.0</li>
<li>@param green 0 ~ 1.0</li>
<li>@param blue 0 ~ 1.0</li>
</ol>
<pre>
+ (UIImage *)qrCodeImageWithContent:(NSString *)content codeImageSize:(CGFloat)size red:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue{
    UIImage *image = [self qrCodeImageWithContent:content codeImageSize:size];
    int imageWidth = image.size.width;
    int imageHeight = image.size.height;
    size_t bytesPerRow = imageWidth * 4;
    uint32_t *rgbImageBuf = (uint32_t *)malloc(bytesPerRow * imageHeight);
    CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(rgbImageBuf, imageWidth, imageHeight, 8, bytesPerRow, colorSpaceRef, kCGBitmapByteOrder32Little|kCGImageAlphaNoneSkipLast);
    CGContextDrawImage(context, CGRectMake(0, 0, imageWidth, imageHeight), image.CGImage);
    //遍历像素, 改变像素点颜色
    int pixelNum = imageWidth * imageHeight;
    uint32_t *pCurPtr = rgbImageBuf;
    for (int i = 0; i< pixelNum; i++, pCurPtr++) {
        if ((*pCurPtr & 0xFFFFFF00) < 0x99999900) {
            uint8_t* ptr = (uint8_t*)pCurPtr;
            ptr[3] = red*255;
            ptr[2] = green*255;
            ptr[1] = blue*255;
        }else{
            uint8_t* ptr = (uint8_t*)pCurPtr;
            ptr[0] = 0;
        }
    }
    //取出图片
    CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, rgbImageBuf, bytesPerRow * imageHeight, ProviderReleaseData);
    CGImageRef imageRef = CGImageCreate(imageWidth, imageHeight, 8, 32, bytesPerRow, colorSpaceRef,
                                        kCGImageAlphaLast | kCGBitmapByteOrder32Little, dataProvider,
                                        NULL, true, kCGRenderingIntentDefault);
    CGDataProviderRelease(dataProvider);
    UIImage *resultImage = [UIImage imageWithCGImage:imageRef];
    CGImageRelease(imageRef);
    CGContextRelease(context);
    CGColorSpaceRelease(colorSpaceRef);

    return resultImage;
}
</pre>

<p>给二维码添加中心logo</p>
<pre>
+ (UIImage *)qrCodeImageWithContent:(NSString *)content
                      codeImageSize:(CGFloat)size
                               logo:(UIImage *)logo
                          logoFrame:(CGRect)logoFrame
                                red:(CGFloat)red
                              green:(CGFloat)green
                               blue:(CGFloat)blue{
    UIImage * image = [self qrCodeImageWithContent:content codeImageSize:size red:red green:green blue:blue];   
    if (logo != nil) {
        UIGraphicsBeginImageContext(image.size);
        [image drawInRect:CGRectMake(0, 0, image.size.width, image.size.height)];
        [logo drawInRect:logoFrame];
        UIImage *resultImage = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();
        return resultImage;
    }else{
        return image;
    }   
}
</pre>

<h3 id="彩色条形码"><a href="#彩色条形码" class="headerlink" title="彩色条形码"></a>彩色条形码</h3><p>获取原始二维码改变像素点颜色</p>
<ol>
<li>@param content 二维码数据</li>
<li>@param size 二维码大小</li>
<li>@param red 0 ~ 1.0</li>
<li>@param green 0 ~ 1.0</li>
<li>@param blue 0 ~ 1.0</li>
</ol>
<pre>
+ (UIImage *)barcodeImageWithContent:(NSString *)content codeImageSize:(CGSize)size red:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue{
    UIImage *image = [self barcodeImageWithContent:content codeImageSize:size];
    int imageWidth = image.size.width;
    int imageHeight = image.size.height;
    size_t bytesPerRow = imageWidth * 4;
    uint32_t *rgbImageBuf = (uint32_t *)malloc(bytesPerRow * imageHeight);
    CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(rgbImageBuf, imageWidth, imageHeight, 8, bytesPerRow, colorSpaceRef, kCGBitmapByteOrder32Little|kCGImageAlphaNoneSkipLast);
    CGContextDrawImage(context, CGRectMake(0, 0, imageWidth, imageHeight), image.CGImage);
    //遍历像素, 改变像素点颜色
    int pixelNum = imageWidth * imageHeight;
    uint32_t *pCurPtr = rgbImageBuf;
    for (int i = 0; i< pixelNum; i++, pCurPtr++) {
        if ((*pCurPtr & 0xFFFFFF00) < 0x99999900) {
            uint8_t* ptr = (uint8_t*)pCurPtr;
            ptr[3] = red*255;
            ptr[2] = green*255;
            ptr[1] = blue*255;
        }else{
            uint8_t* ptr = (uint8_t*)pCurPtr;
            ptr[0] = 0;
        }
    }
    //取出图片
    CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, rgbImageBuf, bytesPerRow * imageHeight, ProviderReleaseData);
    CGImageRef imageRef = CGImageCreate(imageWidth, imageHeight, 8, 32, bytesPerRow, colorSpaceRef,
                                        kCGImageAlphaLast | kCGBitmapByteOrder32Little, dataProvider,
                                        NULL, true, kCGRenderingIntentDefault);
    CGDataProviderRelease(dataProvider);
    UIImage *resultImage = [UIImage imageWithCGImage:imageRef];
    CGImageRelease(imageRef);
    CGContextRelease(context);
    CGColorSpaceRelease(colorSpaceRef); 
    return resultImage;
}
</pre>

<h3 id="渐变二维码"><a href="#渐变二维码" class="headerlink" title="渐变二维码"></a>渐变二维码</h3><p>绘制黑白二维码</p>
<pre>
- (UIImage *)genQRCodeImageMask:(UIImage *)image {
    if (image != nil) {
        int bitsPerComponent = 8;
        int bytesPerPixel = 4;
        int width = image.size.width;
        int height = image.size.height;
        unsigned char * imageData = (unsigned char *)malloc(width * height * bytesPerPixel);

        // 将原始黑白二维码图片绘制到像素格式为ARGB的图片上，绘制后的像素数据在imageData中。
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef imageContext = CGBitmapContextCreate(imageData, width, height, bitsPerComponent, bytesPerPixel * width, colorSpace, kCGImageAlphaPremultipliedFirst);
        UIGraphicsPushContext(imageContext);
        CGContextTranslateCTM(imageContext, 0, height);
        CGContextScaleCTM(imageContext, 1, -1);
        [image drawInRect:CGRectMake(0, 0, width, height)];

        CGColorSpaceRelease(colorSpace);

        // 根据每个像素R通道的值修改Alpha通道的值，当Red大于100，则将Alpha置为0，反之置为255
        for (int row = 0; row < height; ++row) {
            for (int col = 0; col < width; ++col) {
                int offset = row * width * bytesPerPixel + col * bytesPerPixel;
                unsigned char r = imageData[offset + 1];
                unsigned char alpha = r > 100 ? 0 : 255;
                imageData[offset] = alpha;
            }
        }

        CGImageRef cgMaskImage = CGBitmapContextCreateImage(imageContext);
        UIImage *maskImage = [UIImage imageWithCGImage:cgMaskImage];
        CFRelease(cgMaskImage);
        UIGraphicsPopContext();
        CFRelease(imageContext);

        free(imageData);
        return maskImage;
    }
    return nil;
}
</pre>

<p>设置蒙层的颜色</p>
<pre>
- (CAGradientLayer *)gradientLayer {
    if (_gradientLayer == nil) {
        _gradientLayer = [CAGradientLayer new];
        _gradientLayer.colors = @[
                                  (__bridge id)[UIColor colorWithRed: 0x2a / 255.0 green:0x9c / 255.0 blue: 0x1f / 255.0 alpha:1.0].CGColor,
                                  (__bridge id)[UIColor colorWithRed: 0xe6 / 255.0 green:0xcd / 255.0 blue: 0x27 / 255.0 alpha:1.0].CGColor,
                                  (__bridge id)[UIColor colorWithRed: 0xe6 / 255.0 green:0x27 / 255.0 blue: 0x57 / 255.0 alpha:1.0].CGColor
                                  ];
        [self.layer addSublayer: _gradientLayer];
        _gradientLayer.frame = self.bounds;
    }
    return _gradientLayer;
}
</pre>

<p>添加蒙层，设置黑白二维码图片</p>
<pre>- (void)setQRCodeImage:(UIImage *)qrcodeImage {
    UIImage *maskImage = [self genQRCodeImageMask: qrcodeImage];
    self.maskLayer.contents = (__bridge id)maskImage.CGImage;
    self.maskLayer.frame = self.bounds;
    self.gradientLayer.mask = self.maskLayer;
}
</pre>]]></content>
      
        <categories>
            
            <category> Ios </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 2 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[iOS物理动画引擎_UIDynamic]]]></title>
      <url>/2017/09/05/iOS%E7%89%A9%E7%90%86%E5%8A%A8%E7%94%BB%E5%BC%95%E6%93%8E-UIDynamic/</url>
      <content type="html"><![CDATA[<h3 id="Welcome-to-my-blog-Thanks"><a href="#Welcome-to-my-blog-Thanks" class="headerlink" title="Welcome to my blog. Thanks."></a>Welcome to my blog. Thanks.</h3><p>Dome: <a href="https://github.com/princeSmall/UIDynamic" target="_blank" rel="external">github地址</a></p>
<p>iOS物理动画引擎-UIDynamic</p>
<p><img src="/2017/09/05/iOS物理动画引擎-UIDynamic/UIDynamic.gif" alt="UIDynamic"></p>
<h3 id="UIDynamicBehavior-仿真行为"><a href="#UIDynamicBehavior-仿真行为" class="headerlink" title="UIDynamicBehavior 仿真行为"></a>UIDynamicBehavior 仿真行为</h3><ol>
<li>创建一个仿真者,用来仿真所有的物理行为</li>
</ol>
<pre>
 animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view]
 </pre>
2. 创建具体的物理仿真行为

<pre>
gravity = [[UIGravityBehavior alloc]init]
collision = [[UICollisionBehavior alloc]init]
snapBehavior = [[UISnapBehavior alloc] init]
itemBehavior = [[UIDynamicItemBehavior alloc] init]
</pre>
3. 将物理仿真行为添加给仿真者实现仿真效果。

<pre>
 -(void)addBehavior:(UIDynamicBehavior *)behavior;
 -(void)removeBehavior:(UIDynamicBehavior *)behavior;
 -(void)removeAllBehaviors;
</pre>

<h3 id="UIGravityBehavior-重力行为"><a href="#UIGravityBehavior-重力行为" class="headerlink" title="UIGravityBehavior 重力行为"></a>UIGravityBehavior 重力行为</h3><ul>
<li>创建仿真者</li>
</ul>
<pre>
 self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];
</pre>

<ul>
<li>创建仿真行为</li>
</ul>
<pre>
-(UIGravityBehavior *)gravity{
    if (_gravity == nil) {
        _gravity = [[UIGravityBehavior alloc]init];
    }
    return _gravity;
}
-(UICollisionBehavior *)collision{
    if (_collision == nil) {
        _collision = [[UICollisionBehavior alloc]init];
    }
    return _collision;
}
</pre>

<ul>
<li>触碰屏幕生成重力小球</li>
</ul>
<pre>
-(void)touchesBegan:(NSSet<uitouch *=""> *)touches withEvent:(UIEvent *)event{
    UITouch * touch = touches.anyObject;
    CGPoint location = [touch locationInView:self.view];
    self.redView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, widthRed, widthRed)];
    self.redView.center = location;
    [self.view addSubview:self.redView];

    // 随机色方块
    self.redView.backgroundColor = randomColor;

    // 创建重力的物理仿真行为，并设置具体的items(需要仿真的view)
    [self.gravity addItem:self.redView];

    // 下落方向
    // [gravity setAngle:0.5];

    // 创建弹性的物理仿真行为，并设置具体的items(需要仿真的view)
    [self.collision addItem:self.redView];
    self.collision.translatesReferenceBoundsIntoBoundary = YES;

    // 将重力仿真行为添加给仿真者实现仿真效果，开始仿真
    [self.animator addBehavior:self.gravity];
    [self.animator addBehavior:self.collision];

}
</uitouch></pre>

<h3 id="UICollisionBehavior-碰撞行为"><a href="#UICollisionBehavior-碰撞行为" class="headerlink" title="UICollisionBehavior 碰撞行为"></a>UICollisionBehavior 碰撞行为</h3><ul>
<li>创建仿真者</li>
</ul>
<pre>
 self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];
</pre>

<ul>
<li>创建碰撞对象</li>
</ul>
<pre>
self.greenView = [[UIView alloc] initWithFrame:CGRectMake(100, 200, 100, 30)];
self.greenView.backgroundColor = [UIColor greenColor];
[self.view addSubview:self.greenView];

self.blueView = [[UIView alloc] initWithFrame:CGRectMake(120, 300, 100, 30)];
self.blueView.backgroundColor = [UIColor blueColor];
[self.view addSubview:self.blueView];

  //未绑定仿真对象  
self.blackView = [[UIView alloc] initWithFrame:CGRectMake(140, 400, 100, 30)];
self.blackView.backgroundColor = [UIColor blackColor];
[self.view addSubview:self.blackView];

  // 物体角度  
self.blueView.transform =  CGAffineTransformMakeRotation(M_PI_4);
self.greenView.transform = CGAffineTransformMakeRotation(-M_PI / 8);

</pre>

<ul>
<li>创建仿真行为</li>
</ul>
<pre>
-(UIGravityBehavior *)gravity{
    if (_gravity == nil) {
        _gravity = [[UIGravityBehavior alloc]init];
    }
    return _gravity;
}
-(UICollisionBehavior *)collision{
    if (_collision == nil) {
        _collision = [[UICollisionBehavior alloc]init];
    }
    return _collision;
}
</pre>

<ul>
<li>开始碰撞行为</li>
</ul>
<pre>
-(void)touchesBegan:(NSSet<uitouch *=""> *)touches withEvent:(UIEvent *)event{
    // 获取点击位置，生成仿真者
    UITouch * touch = touches.anyObject;
    CGPoint location = [touch locationInView:self.view];
    self.redView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, widthRed, widthRed)];
    self.redView.center = location;
    // pch中宏定义的随机色
    self.redView.backgroundColor = randomColor;
    [self.view addSubview:self.redView];
    [self.gravity addItem:self.redView];
    // 添加碰撞检测
    [self.collision addItem:self.redView];
    [self.collision addItem:self.greenView];
    [self.collision  addItem:self.blueView];
    self.collision.translatesReferenceBoundsIntoBoundary = YES;
    self.collision.collisionDelegate = self;


   __weak typeof(self) weakSelf = self;
        // 获取方块运动轨迹坐标
    self.collision.action = ^{
        NSLog(@"%@", NSStringFromCGRect(weakSelf.redView.frame));

    };

    CGFloat Y = self.view.frame.size.height;
    CGFloat X = self.view.frame.size.width;
    CGFloat height = self.view.frame.size.height;

    //设置红色的View为底边界,左边框跟右边框作为边界
    [self.collision addBoundaryWithIdentifier:@"collision1" fromPoint:CGPointMake(0,Y) toPoint:CGPointMake(X, Y)];
    [self.collision addBoundaryWithIdentifier:@"collision2" fromPoint:CGPointMake(0, 0) toPoint:CGPointMake(0, height)];
    [self.collision addBoundaryWithIdentifier:@"collision3" fromPoint:CGPointMake(X,0) toPoint:CGPointMake(X, height)];
    [self.animator addBehavior:self.collision];
    [self.animator addBehavior:self.gravity];  
}
</uitouch></pre>

<ul>
<li>碰撞开始时给被碰撞的物体添加重力仿真</li>
</ul>
<pre>
// UICollisionBehavior 代理行为
- (void)collisionBehavior:(UICollisionBehavior*)behavior beganContactForItem:(id <uidynamicitem>)item withBoundaryIdentifier:(nullable id <nscopying>)identifier atPoint:(CGPoint)p{

    if ([item isEqual:self.greenView]) {
        UIGravityBehavior * gravity = [[UIGravityBehavior alloc] initWithItems:@[self.greenView]];
        [self.animator addBehavior:gravity];
    }else if ([item isEqual:self.blueView]){
        UIGravityBehavior * gravity = [[UIGravityBehavior alloc] initWithItems:@[self.blueView]];
        [self.animator addBehavior:gravity];
    }

}
</nscopying></uidynamicitem></pre>

<h3 id="UISnapBehavior-吸附行为"><a href="#UISnapBehavior-吸附行为" class="headerlink" title="UISnapBehavior 吸附行为"></a>UISnapBehavior 吸附行为</h3><ul>
<li>创建仿真者</li>
</ul>
<pre>
self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];
</pre>

<ul>
<li>创建吸附对象</li>
</ul>
<pre>
-(UIView *)redView{
    if (_redView ==nil) {
        _redView = [[UIView alloc]initWithFrame:CGRectMake(p.x, p.y, 50, 50)];
        _redView.backgroundColor = [UIColor redColor];
        [self.view addSubview:_redView];
    }
    return _redView;
}
</pre>

<ul>
<li>开始吸附行为</li>
</ul>
<pre>
-(void)touchesBegan:(NSSet<uitouch *=""> *)touches withEvent:(UIEvent *)event{

    [self.animator removeAllBehaviors];
    UITouch * touch = touches.anyObject;
    CGPoint location = [touch locationInView:self.view];
    p = location;
    NSLog(@"%@",NSStringFromCGPoint(location));
     // 3 添加吸附事件
     UISnapBehavior *snap = [[UISnapBehavior alloc] initWithItem:self.redView snapToPoint:location];
    // 改变震动幅度，0表示振幅最大，1振幅最小
    snap.damping = 0.5;
    // 4. 将吸附事件添加到仿真者行为中
    [self.animator addBehavior:snap];

}
</uitouch></pre>

<h3 id="UIDynamicItemBehavior-迅猛移动弹跳摆动行为"><a href="#UIDynamicItemBehavior-迅猛移动弹跳摆动行为" class="headerlink" title="UIDynamicItemBehavior 迅猛移动弹跳摆动行为"></a>UIDynamicItemBehavior 迅猛移动弹跳摆动行为</h3><ul>
<li>创建仿真者</li>
</ul>
<pre>
self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];
</pre>

<ul>
<li>创建仿真行为</li>
</ul>
<pre>
-(UIGravityBehavior *)gravity{
    if (_gravity == nil) {
        _gravity = [[UIGravityBehavior alloc]init];
    }
    return _gravity;
}
-(UICollisionBehavior *)collision{
    if (_collision == nil) {
        _collision = [[UICollisionBehavior alloc]init];
         [_collision addBoundaryWithIdentifier:@"barrier" forPath:[UIBezierPath bezierPathWithRect:self.view.bounds]];
        _collision.translatesReferenceBoundsIntoBoundary = YES;
    }
    return _collision;
}
-(UIDynamicItemBehavior *)itemBehavior{
    if (_itemBehavior == nil) {
        _itemBehavior = [[UIDynamicItemBehavior alloc] init];
        _itemBehavior.elasticity = 1;
    }
    return _itemBehavior;
}
</pre>

<ul>
<li>生成小球，添加仿真事件</li>
</ul>
<pre>
-(void)touchesAddSquareView{
    float  viewWidth = 20;
    UIView * view = [[UIView alloc]initWithFrame:CGRectMake(p.x, p.y, viewWidth, viewWidth)];
    view.layer.cornerRadius = viewWidth / 2.0;
    view.backgroundColor = randomColor;
    [self performSelector:@selector(removeView:) withObject:view afterDelay:10];
    [self.view addSubview:view];
    [self.collision addItem:view];
    [self.itemBehavior addItem:view];
    [self.gravity addItem:view];
    [self.animator addBehavior:self.collision];
    [self.animator addBehavior:self.itemBehavior];
    [self.animator addBehavior:self.gravity];

}
</pre>

<ul>
<li>点触，移动和松开创建小球</li>
</ul>
<pre>
- (void)touchesBegan:(NSSet<uitouch *=""> *)touches withEvent:(UIEvent *)event
{
    UITouch * touch = touches.anyObject;
    CGPoint location = [touch locationInView:self.view];
    p = location;
    [self touchesAddSquareView];
}

- (void)touchesMoved:(NSSet<uitouch *=""> *)touches withEvent:(UIEvent *)event
{
    UITouch * touch = touches.anyObject;
    CGPoint location = [touch locationInView:self.view];
    p = location;
   [self touchesAddSquareView];
}
- (void)touchesEnded:(NSSet<uitouch *=""> *)touches withEvent:(UIEvent *)event
{
    [self touchesAddSquareView];
}
</uitouch></uitouch></uitouch></pre>

<ul>
<li>10s后删除小球和其物理仿真行为</li>
</ul>
<pre>
-(void)removeView:(UIView *)view{
    if (view == nil) {
        return;
    }
    [UIView animateWithDuration:.5 animations:^{
        view.alpha = 0;
    } completion:^(BOOL finished) {
        [view removeFromSuperview];
        [self.collision removeItem:view];
        [self.itemBehavior removeItem:view];
        [self.gravity removeItem:view];
    }];

}
</pre>

]]></content>
      
        <categories>
            
            <category> Ios </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 1 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Swift_popAnimation实例]]]></title>
      <url>/2017/08/28/Swift-popAnimation%E5%AE%9E%E4%BE%8B/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/hamburger" target="_blank" rel="external">github地址</a></p>
<p>情人节在写博客也是蛮拼的</p>
<ol>
<li>Pod pop 如 [Swift_popAnimation初级]</li>
</ol>
<h3 id="动画思路"><a href="#动画思路" class="headerlink" title="动画思路"></a>动画思路</h3><pre>
   三条杠变叉：中间杠的消失和两边杠的偏移。
   叉变三条杠：两边杠的偏移和中间杠的出现。
</pre>

<ol>
<li><p>三条杠用三个view来代替，添加在一个button上。声明全局属性</p>
<pre>
 var  hamburger = true
 var  hamburgerButton : UIButton?
 var  top:UIView?
 var  middle:UIView?
 var  bottom:UIView?
</pre>
</li>
<li><p>实例化对象</p>
<pre><code>self.hamburgerButton = UIButton()
self.hamburgerButton?.backgroundColor = UIColor.black
self.hamburgerButton?.frame = CGRect(x: 100, y: 200, width: 150, height: 150)     
self.hamburgerButton?.layer.cornerRadius = 75
self.view.addSubview(hamburgerButton!)
self.hamburgerButton?.addTarget(self, action:#selector(didTapHamburgerButton), for: UIControlEvents.touchUpInside)
//三道杠
let sectionWidth:CGFloat = 80.0
let sectionHeight:CGFloat = 11.0
//top
top = UIView(frame: CGRect(x: (self.hamburgerButton?.bounds.size.width)! / 2 - sectionWidth / 2, y: 40, width: sectionWidth, height: sectionHeight))
top?.backgroundColor = UIColor.white
top?.isUserInteractionEnabled = false
top?.layer.cornerRadius = sectionHeight / 2
self.hamburgerButton?.addSubview(top!)
//middle
middle = UIView(frame: CGRect(x: (self.hamburgerButton?.bounds.size.width)! / 2 - sectionWidth / 2, y: 69, width: sectionWidth, height: sectionHeight))
middle?.backgroundColor = UIColor.white
middle?.isUserInteractionEnabled = false
middle?.layer.cornerRadius = sectionHeight / 2
self.hamburgerButton?.addSubview(middle!)
//bottom
bottom = UIView(frame: CGRect(x: (self.hamburgerButton?.bounds.size.width)! / 2 - sectionWidth / 2, y: 99, width: sectionWidth, height: sectionHeight))
bottom?.backgroundColor = UIColor.white
bottom?.isUserInteractionEnabled = false
bottom?.layer.cornerRadius = sectionHeight / 2
self.hamburgerButton?.addSubview(bottom!)
</code></pre></li>
</ol>
<h3 id="pop对象复用"><a href="#pop对象复用" class="headerlink" title="pop对象复用"></a>pop对象复用</h3><ol>
<li>颜色动画：<pre>
     var topColor = self.top?.pop_animation(forKey: "topColor") as! POPSpringAnimation?
     var bottomColor = self.top?.pop_animation(forKey: "bottomColor") as! POPSpringAnimation?
</pre></li>
<li>旋转动画：<pre>
     var topRotate = self.top?.layer.pop_animation(forKey: "topRotate") as! POPSpringAnimation?
     var bottomRotate = self.top?.layer.pop_animation(forKey: "bottomRotate") as! POPSpringAnimation?
</pre></li>
<li>位置动画：<pre>
     var topPosition = self.top?.layer.pop_animation(forKey: "topPosition")as!POPSpringAnimation?
     var bottomPosition = self.top?.layer.pop_animation(forKey: "bottomPosition")as!POPSpringAnimation?
</pre>

</li>
</ol>
<h3 id="三道杠变红叉叉"><a href="#三道杠变红叉叉" class="headerlink" title="三道杠变红叉叉"></a>三道杠变红叉叉</h3><pre>
 hamburger = false
            UIView.animate(withDuration: 0.2, animations: {
                self.middle?.alpha = 0
            })
            //变色
            if topColor != nil {
                topColor?.toValue = UIColor.red
            }else{
                topColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor)
                topColor?.toValue = UIColor.red
                topColor?.springBounciness = 0
                topColor?.springSpeed = 18
                top?.pop_add(topColor, forKey: "topColor")
            }
            if bottomColor != nil {
                bottomColor?.toValue = UIColor.red
            }else{
                bottomColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor)
                bottomColor?.toValue = UIColor.red
                bottomColor?.springBounciness = 0
                bottomColor?.springSpeed = 18
                bottom?.pop_add(topColor, forKey: "bottomColor")
            }
            //旋转
            if topRotate != nil {
                topRotate?.toValue = -Double.pi / 4
            }else{
                topRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation)
                topRotate?.toValue = -Double.pi / 4
                topRotate?.springBounciness = 11
                topRotate?.springSpeed = 18
                top?.layer.pop_add(topRotate, forKey: "topRotate")
            }
            if bottomRotate != nil {
                bottomRotate?.toValue = Double.pi / 4
            }else{
                bottomRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation)
                bottomRotate?.toValue = Double.pi / 4
                bottomRotate?.springBounciness = 11
                bottomRotate?.springSpeed = 18
                bottom?.layer.pop_add(bottomRotate, forKey: "bottomRotate")
            }
            //移动
            if topPosition != nil {
                topPosition?.toValue = 29
            }else{
                topPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY)
                topPosition?.toValue = 29
                topPosition?.springBounciness = 11
                topPosition?.springSpeed = 18
                top?.layer.pop_add(topPosition, forKey: "topPosition")
            }
            if bottomPosition != nil {
                bottomPosition?.toValue = -29
            }else{
                bottomPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY)
                bottomPosition?.toValue = -29
                bottomPosition?.springBounciness = 11
                bottomPosition?.springSpeed = 18
                bottom?.layer.pop_add(bottomPosition, forKey: "bottomPosition")
            }

}
</pre>

<h3 id="红叉叉变三道杠-逆向-gt-就还原一起改变值"><a href="#红叉叉变三道杠-逆向-gt-就还原一起改变值" class="headerlink" title="红叉叉变三道杠:逆向-&gt;就还原一起改变值"></a>红叉叉变三道杠:逆向-&gt;就还原一起改变值</h3><pre>
   hamburger = true
            UIView.animate(withDuration: 0.2, animations: {
                self.middle?.alpha = 1
            })
            //变色
            if topColor != nil {
                topColor?.toValue = UIColor.white
            }else{
                topColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor)
                topColor?.toValue = UIColor.white
                topColor?.springBounciness = 0
                topColor?.springSpeed = 18
                top?.pop_add(topColor, forKey: "topColor")
            }
            if bottomColor != nil {
                bottomColor?.toValue = UIColor.white
            }else{
                bottomColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor)
                bottomColor?.toValue = UIColor.white
                bottomColor?.springBounciness = 0
                bottomColor?.springSpeed = 18
                bottom?.pop_add(topColor, forKey: "bottomColor")
            }
            //旋转
            if topRotate != nil {
                topRotate?.toValue = 0
            }else{
                topRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation)
                topRotate?.toValue = 0
                topRotate?.springBounciness = 11
                topRotate?.springSpeed = 18
                top?.layer.pop_add(topRotate, forKey: "topRotate")
            }
            if bottomRotate != nil {
                bottomRotate?.toValue = 0
            }else{
                bottomRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation)
                bottomRotate?.toValue = 0
                bottomRotate?.springBounciness = 11
                bottomRotate?.springSpeed = 18
                bottom?.layer.pop_add(bottomRotate, forKey: "bottomRotate")
            }
            //移动
            if topPosition != nil {
                topPosition?.toValue = 0
            }else{
                topPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY)
                topPosition?.toValue = 0
                topPosition?.springBounciness = 11
                topPosition?.springSpeed = 18
                top?.layer.pop_add(topPosition, forKey: "topPosition")
            }
            if bottomPosition != nil {
                bottomPosition?.toValue = 0
            }else{
                bottomPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY)
                bottomPosition?.toValue = 0
                bottomPosition?.springBounciness = 11
                bottomPosition?.springSpeed = 18
                bottom?.layer.pop_add(bottomPosition, forKey: "bottomPosition")
            }


        }

    }
</pre>

<p>so easy<br><img src="/2017/08/28/Swift-popAnimation实例/san.png" alt=""><br><img src="/2017/08/28/Swift-popAnimation实例/hong.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Swift </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Swift_popAnimation应用]]]></title>
      <url>/2017/08/25/Swift-popAnimation%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/TongPopInstall" target="_blank" rel="external">github地址</a></p>
<p><img src="/2017/08/25/Swift-popAnimation应用/PopInstall.gif" alt="GIF"></p>
<ol>
<li>Pod pop如上篇文章</li>
<li>创建UIbutton类对象与storyboard绑定</li>
<li>应用touchesBegan ，touchesEnded</li>
</ol>
<h3 id="开始点击"><a href="#开始点击" class="headerlink" title="开始点击"></a>开始点击</h3><ol>
<li>缩小0.5倍</li>
<li>旋转半圈</li>
</ol>
<pre>
  //缩放动画
        var scale = self.pop_animation(forKey: TLscale)as?POPSpringAnimation
        if scale != nil {
            scale?.toValue = NSValue(cgPoint:CGPoint(x: 0.5, y: 0.5))
        }else{
       scale = POPSpringAnimation(propertyNamed: kPOPViewScaleXY)
            scale?.toValue = NSValue(cgPoint:CGPoint(x: 0.5, y: 0.5))
            scale?.springBounciness = 20
            scale?.springSpeed = 5
            self.pop_add(scale, forKey: TLscale)

        }
  //旋转动画
        var rotate = self.layer.pop_animation(forKey: TLrotate)as? POPSpringAnimation
        if rotate != nil {
            rotate?.toValue = Double.pi / 2
        }else{
            rotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation)
            rotate?.toValue = Double.pi / 2
            rotate?.springBounciness = 20
            rotate?.springSpeed = 18
            self.layer.pop_add(rotate, forKey: TLrotate)
        }
</pre>

<h3 id="结束点击"><a href="#结束点击" class="headerlink" title="结束点击"></a>结束点击</h3><ol>
<li>缩放1.0倍回到起始状态</li>
<li>旋转到起始位置</li>
</ol>
<pre>
  //缩放动画
        var scale = self.pop_animation(forKey: TLscale)as?POPSpringAnimation
        if scale != nil {
            scale?.toValue = NSValue(cgPoint:CGPoint(x: 1, y: 1))
        }else{
            scale = POPSpringAnimation(propertyNamed: kPOPViewScaleXY)
            scale?.toValue = NSValue(cgPoint:CGPoint(x: 1, y: 1))
            scale?.springBounciness = 20
            scale?.springSpeed = 5
            self.pop_add(scale, forKey: TLscale)
             }
  //旋转动画
        var rotate = self.layer.pop_animation(forKey: TLrotate)as? POPSpringAnimation
        if rotate != nil {
            rotate?.toValue = 0
        }else{
            rotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation)
            rotate?.toValue = 0
            rotate?.springBounciness = 20
            rotate?.springSpeed = 18
            self.layer.pop_add(rotate, forKey: TLrotate)
</pre>
]]></content>
      
        <categories>
            
            <category> Swift </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Swift_popAnimation初级]]]></title>
      <url>/2017/08/25/popAnimation%E5%88%9D%E7%BA%A7/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/RedBall" target="_blank" rel="external">github地址</a></p>
<p><img src="/2017/08/25/popAnimation初级/redBall.gif" alt="GIF"></p>
<p>先初尝popAnimation一些环境配置和方法调用，下篇会写实例应用</p>
<h3 id="Pods-pop"><a href="#Pods-pop" class="headerlink" title="Pods pop"></a>Pods pop</h3><ol>
<li>vim podfile</li>
</ol>
<pre>
platform :ios,'8.0'

target "RedBall" do

pod 'pop'

end
</pre>

<ol>
<li>pod install</li>
</ol>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><ol>
<li>宏定义</li>
</ol>
<pre>
let TLspin = "spin"
let TLmove = "move"
let TLcolor = "color"
let TLscale = "scale"
</pre>

<ol>
<li>属性定义</li>
</ol>
<pre>
    let redBall = UIView(frame: CGRect(x: 100, y: 200, width: 100, height: 100))
    let scale = POPSpringAnimation(propertyNamed:kPOPViewScaleXY)
    let move = POPSpringAnimation(propertyNamed: kPOPLayerPositionY)
    let spin = POPSpringAnimation(propertyNamed: kPOPLayerRotation)
    let color = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor)

</pre>

<ol>
<li><p>segmentContol创建</p>
<pre><code>let array = [&quot;放大&quot;,&quot;旋转&quot;,&quot;移动&quot;,&quot;变色&quot;,&quot;归位&quot;]

let segmentedControl = UISegmentedControl.init(items:array)

segmentedControl.frame = CGRect(x:50,y:50,width:self.view.frame.size.width-100 ,height:30)

segmentedControl.tintColor = UIColor.green

segmentedControl.backgroundColor = UIColor.red

segmentedControl.addTarget(self, action:#selector(segmentedControlChanged(segmented:)), for: UIControlEvents.valueChanged)

self.view .addSubview(segmentedControl);
</code></pre></li>
<li><p>动画代码</p>
<ol>
<li>pop放大，旋转，移动，变色，还原动画</li>
<li>springBounciness: 弹性振幅，范围0-20</li>
<li>springSpeed: 震动速度</li>
<li>pop_add: 加载动画</li>
</ol>
</li>
</ol>
<pre> 
    func redBallScale()  {
        // 放大动画
        scale?.toValue = NSValue(cgPoint:CGPoint(x: 2, y: 2))
        scale?.springBounciness = 20
        scale?.springSpeed = 1
        redBall.pop_add(scale, forKey: TLscale)
    }
    func redBallSpin()  {
        //旋转动画
        spin?.toValue = Double.pi * 4
        spin?.springBounciness = 20
        spin?.springSpeed = 5
        redBall.layer.pop_add(spin, forKey: TLspin)

    }
    func redBallMove()  {
        //y坐标位移动画
        move?.toValue = 500
        move?.springBounciness = 20
        move?.springSpeed = 5
        redBall.layer.pop_add(move, forKey: TLmove)
    }
    func redBallColor()  {
        //背景颜色变化
        color?.toValue = UIColor.green
        color?.springBounciness = 20
        color?.springSpeed = 5
        redBall.pop_add(color, forKey: TLcolor)

    }
</pre>


]]></content>
      
        <categories>
            
            <category> Swift </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[iOS-绑定Amazon]]]></title>
      <url>/2017/08/23/iOS-%E7%BB%91%E5%AE%9AAmazon/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/iOS_Amazon" target="_blank" rel="external">github地址</a></p>
<p>为实现echo语音控制只能家居，所以需要绑定亚马逊账号</p>
<h3 id="Install-the-Login-with-Amazon-SDK-for-iOS"><a href="#Install-the-Login-with-Amazon-SDK-for-iOS" class="headerlink" title="Install the Login with Amazon SDK for iOS"></a>Install the Login with Amazon SDK for iOS</h3><ol>
<li>下载亚马逊SDK <a href="https://images-na.ssl-images-amazon.com/images/G/01/lwa/sdk/LoginWithAmazonSDKForiOS._TTH_.zip" target="_blank" rel="external">LoginWithAmazonSDKForiOS.zip</a> </li>
<li>工程中拖入SDK LoginWithAmazon.framework </li>
<li>Target - BuildPhases - Link Binary With Libraries中添加framework<br><img src="/2017/08/23/iOS-绑定Amazon/FrameWork.png" alt=""></li>
</ol>
<h3 id="Register-with-Login-with-Amazon"><a href="#Register-with-Login-with-Amazon" class="headerlink" title="Register with Login with Amazon"></a>Register with Login with Amazon</h3><h4 id="注册亚马逊账号"><a href="#注册亚马逊账号" class="headerlink" title="注册亚马逊账号"></a>注册亚马逊账号</h4><p><a href="https://www.amazon.com/ap/register?clientContext=168-8975905-4767102&amp;openid.pape.max_auth_age=18000&amp;openid.return_to=https%3A%2F%2Flogin.amazon.com%2Fap-post-redirect&amp;prevRID=8DS9KWNHYGC5AH3NEF6R&amp;openid.identity=http%3A%2F%2Fspecs.openid.net%2Fauth%2F2.0%2Fidentifier_select&amp;openid.assoc_handle=amzn_lwa_landing&amp;openid.mode=checkid_setup&amp;siteState=clientContext%3D146-3143884-7961460%2CsourceUrl%3Dhttps%253A%252F%252Flogin.amazon.com%252Fagreement%2Csignature%3DiKv2yHIcj2BRW7gb6EL42A4KfOU24j3D&amp;marketPlaceId=ATVPDKIKX0DER&amp;openid.claimed_id=http%3A%2F%2Fspecs.openid.net%2Fauth%2F2.0%2Fidentifier_select&amp;pageId=amzn_lwa_landing&amp;openid.ns=http%3A%2F%2Fspecs.openid.net%2Fauth%2F2.0" target="_blank" rel="external">亚马逊注册</a></p>
<p><img src="/2017/08/23/iOS-绑定Amazon/RegisterAmazon.png" alt=""></p>
<h4 id="登录亚马逊账号"><a href="#登录亚马逊账号" class="headerlink" title="登录亚马逊账号"></a>登录亚马逊账号</h4><p><a href="https://www.amazon.com/ap/signin?clientContext=168-8975905-4767102&amp;openid.return_to=https%3A%2F%2Flogin.amazon.com%2Fap-post-redirect&amp;openid.identity=http%3A%2F%2Fspecs.openid.net%2Fauth%2F2.0%2Fidentifier_select&amp;openid.assoc_handle=amzn_lwa_landing&amp;openid.mode=checkid_setup&amp;marketPlaceId=ATVPDKIKX0DER&amp;openid.claimed_id=http%3A%2F%2Fspecs.openid.net%2Fauth%2F2.0%2Fidentifier_select&amp;pageId=amzn_lwa_landing&amp;openid.ns=http%3A%2F%2Fspecs.openid.net%2Fauth%2F2.0&amp;openid.pape.max_auth_age=18000&amp;siteState=clientContext%3D146-3143884-7961460%2CsourceUrl%3Dhttps%253A%252F%252Flogin.amazon.com%252Fagreement%2Csignature%3DiKv2yHIcj2BRW7gb6EL42A4KfOU24j3D" target="_blank" rel="external">亚马逊登录</a></p>
<p><img src="/2017/08/23/iOS-绑定Amazon/LoginAmazon.png" alt=""></p>
<ol>
<li>输入App的名称，链接和App图标等</li>
<li>注册地址 <a href="https://login.amazon.com/agreement" target="_blank" rel="external">App Console</a>.前提是你有亚马逊账号<br><img src="/2017/08/23/iOS-绑定Amazon/Register.png" alt=""></li>
</ol>
<h3 id="Add-iOS-Settings-to-an-Application"><a href="#Add-iOS-Settings-to-an-Application" class="headerlink" title="Add iOS Settings to an Application"></a>Add iOS Settings to an Application</h3><ol>
<li><a href="https://developer.amazon.com" target="_blank" rel="external">亚马逊</a> App应用界面，点击iOS设置，如果你的iOS App已经注册好，点击 API Key </li>
<li>需要输入你的Bundle ID,target - General<br><img src="/2017/08/23/iOS-绑定Amazon/bunldID.png" alt=""></li>
</ol>
<h3 id="Add-Your-API-Key-to-Your-App-Property-List"><a href="#Add-Your-API-Key-to-Your-App-Property-List" class="headerlink" title="Add Your API Key to Your App Property List"></a>Add Your API Key to Your App Property List</h3><ol>
<li>选择 project - Info.plist 添加APIKey ，选择copy，别出错<br><img src="/2017/08/23/iOS-绑定Amazon/API.png" alt=""></li>
</ol>
<h3 id="Add-a-URL-Scheme-to-Your-App-Property-List"><a href="#Add-a-URL-Scheme-to-Your-App-Property-List" class="headerlink" title="Add a URL Scheme to Your App Property List"></a>Add a URL Scheme to Your App Property List</h3><ol>
<li>选择 project - Info.plist 添加URL types</li>
<li>Item 0 Document Role 填写Editor。 Shames 填写 prefs</li>
<li>Item 1 identifier 填写bundle ID。 Shames 填写amzn-bundle ID</li>
<li>其他填写如下图<br><img src="/2017/08/23/iOS-绑定Amazon/URL.png" alt=""></li>
</ol>
<h3 id="Using-the-SDK-for-iOS-APIs"><a href="#Using-the-SDK-for-iOS-APIs" class="headerlink" title="Using the SDK for iOS APIs"></a>Using the SDK for iOS APIs</h3><p>创建亚马逊类，导入 #import&lt; LoginWithAmazon/LoginWithAmazon.h&gt;</p>
<h4 id="Using-the-SDK-for-iOS-APIs-1"><a href="#Using-the-SDK-for-iOS-APIs-1" class="headerlink" title="Using the SDK for iOS APIs"></a>Using the SDK for iOS APIs</h4><ol>
<li>在 AppDelegate 导入import &lt; LoginWithAmazon/LoginWithAmazon.h&gt;.</li>
<li>添加以下方法,返回亚马逊URL</li>
</ol>
<pre>
- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation {
    #pragma unused(application,annotation)
    // Pass on the url to the SDK to parse authorization code from the url.
    BOOL isValidRedirectLogInURL = [AMZNAuthorizationManager handleOpenURL:url sourceApplication:(NSString *)sourceApplication];

    if(!isValidRedirectLogInURL){
        return NO;
    }
    // App may also want to handle url
    return YES;
}
</pre>


<h4 id="Handle-the-Login-Button-and-Get-Profile-Data"><a href="#Handle-the-Login-Button-and-Get-Profile-Data" class="headerlink" title="Handle the Login Button and Get Profile Data"></a>Handle the Login Button and Get Profile Data</h4><ol>
<li>发出登录请求 userID ，profile，postalCode</li>
<li>successful 成功登录返回数据result.token，result.user，user.userID</li>
<li>error 回复错误</li>
<li>userDidCancel 用户自动取消</li>
</ol>
<pre>
- (IBAction)onLogInButtonClicked:(id)sender {
  // Build an authorize request.
  AMZNAuthorizeRequest *request = [[AMZNAuthorizeRequest alloc] init];
        request.scopes = [NSArray arrayWithObjects: 
        [AMZNProfileScope userID],
        [AMZNProfileScope profile], 
        [AMZNProfileScope postalCode]];

  // Make an Authorize call to the Login with Amazon SDK.
  [[AMZNAuthorizationManager sharedManager] authorize:request
    withHandler:^(AMZNAuthorizeResult *result, BOOL 
    userDidCancel, NSError *error) {
          if (error) { 
              // Handle errors from the SDK or authorization server. 
          } else if (userDidCancel) {
              // Handle errors caused when user cancels login.
          } else {
              // Authentication was successful.
              // Obtain the access token and user profile data.
              NSString *accessToken = result.token;
              AMZNUser *user = result.user;
              NSString *userID = user.userID;
          }
  }];
}
</pre>

<h4 id="Fetch-User-Profile-Data"><a href="#Fetch-User-Profile-Data" class="headerlink" title="Fetch User Profile Data"></a>Fetch User Profile Data</h4><ol>
<li>获取登录信息 user.userID，user.name，user.email，user.postalCode</li>
<li>在error时可以添加重新登录方法</li>
</ol>
<pre>
AMZNUser fetch:^(AMZNUser *user, NSError *error) {
  if (error) {
    // Error from the SDK, or no user has authorized to the app.
  } else if (user) {
    NSString *userID = user.userID;
    //NSString *name = user.name;
    //NSString *email = user.email;
    //NSString *postalCode = user.postalCode;
  }
}];
</pre>

<h4 id="Check-for-User-Login-at-Startup"><a href="#Check-for-User-Login-at-Startup" class="headerlink" title="Check for User Login at Startup"></a>Check for User Login at Startup</h4><pre>
// Build an authorize request.
   AMZNAuthorizeRequest *request = [[AMZNAuthorizeRequest alloc] init];
    request.scopes = [NSArray arrayWithObjects: 
  // [AMZNProfileScope userID],
     [AMZNProfileScope profile], 
    [AMZNProfileScope postalCode]];

   request.interactiveStrategy = AMZNInteractiveStrategyNever;

   [[AMZNAuthorizationManager sharedManager] authorize:request
     withHandler:^(AMZNAuthorizeResult *result, BOOL 
      userDidCancel, NSError *error) {
        if (error) { 
             // Error from the SDK, indicating the user was not previously authorized to your app for the requested scopes. 
         } else {
             // The user was previously authorized to your app.
             // Obtain the access token and user profile data.
                 NSString *accessToken = result.token;
             AMZNUser *user = result.user;
             NSString *userID = user.userID;
             }
       }];
</pre>

<h4 id="Clear-Authorization-Data-and-Log-Out-a-User"><a href="#Clear-Authorization-Data-and-Log-Out-a-User" class="headerlink" title="Clear Authorization Data and Log Out a User"></a>Clear Authorization Data and Log Out a User</h4><ol>
<li>退出登录</li>
<li>清除亚马逊数据</li>
</ol>
<pre>
[[AMZNAuthorizationManager sharedManager] signOut:^(NSError * _Nullable error) {
  if (!error) {
    // error from the SDK or Login with Amazon authorization server.
  }
}];
</pre>

<p>注：亚马逊账号绑定在本地存储，所以多手机登录需要存储userID到自己服务器，实现多手机登录状态回显</p>
]]></content>
      
        <categories>
            
            <category> Ios </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 2 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[iOS-OpenGL图形绘制二]]]></title>
      <url>/2017/08/23/iOS-OpenGL%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h3 id="Welcome-to-my-blog-Thanks"><a href="#Welcome-to-my-blog-Thanks" class="headerlink" title="Welcome to my blog. Thanks."></a>Welcome to my blog. Thanks.</h3><p>Dome: <a href="https://github.com/princeSmall/iOS_OpenGL_layer" target="_blank" rel="external">github地址</a></p>
<p>本章讲如何用原生OpenGL绘制图形及渲染图片</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol>
<li><p>创建一个新的工程，点击target-&gt;Build Phases -&gt; Link Binary With Libraries添加库</p>
<ul>
<li>GLKit.framework</li>
<li>OpenGLES.framework</li>
</ul>
</li>
<li><p>导入头文件:</p>
<p>  #import &lt; OpenGLES/ES2/gl.h &gt;</p>
<p>  #import &lt; OpenGLES/ES2/glext.h &gt;</p>
</li>
</ol>
<h3 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h3><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><p>一个三角线</p>
<pre><code>const GLfloat Trianglevertices[] = {
0.0f,  0.5f, 0.0f,
-0.5f, -0.5f, 0.0f,
0.5f,  -0.5f, 0.0f };

const GLubyte Triangleindices[] = {
0,1,2
};
</code></pre><h4 id="VBO申请空间并绑定目标"><a href="#VBO申请空间并绑定目标" class="headerlink" title="VBO申请空间并绑定目标"></a>VBO申请空间并绑定目标</h4><pre><code>-(void)OneRenderVerticesAnColorsForTriangles{
GLuint vertexBuffer;
glGenBuffers(1, &amp;vertexBuffer);
// 绑定vertexBuffer到GL_ARRAY_BUFFER目标
glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
// 为VBO申请空间，初始化并传递数据
glBufferData(GL_ARRAY_BUFFER, sizeof(Trianglevertices), Trianglevertices, GL_STATIC_DRAW);

GLuint indexBuffer;
glGenBuffers(1, &amp;indexBuffer);
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Triangleindices), Triangleindices, GL_STATIC_DRAW);

// 使用VBO时，最后一个参数0为要获取参数在GL_ARRAY_BUFFER中的偏移量
glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 0, 0);
glEnableVertexAttribArray(_positionSlot);

glDrawElements(GL_TRIANGLES, sizeof(Triangleindices)/sizeof(Triangleindices[0]), GL_UNSIGNED_BYTE, 0);
}
</code></pre><h3 id="四边形"><a href="#四边形" class="headerlink" title="四边形"></a>四边形</h3><h4 id="宏定义-1"><a href="#宏定义-1" class="headerlink" title="宏定义"></a>宏定义</h4><p>定义一个Vertex结构, 其中包含了坐标和颜色</p>
<pre><code>typedef struct {
float Position[3];
float Color[4];
} Vertex;
</code></pre><p>顶点数组</p>
<pre><code>const Vertex Vertices[] = {
{{-1,-1,0}, {0,0,0,1}},// 左下，黑色
{{1,-1,0}, {1,0,0,1}}, // 右下，红色
{{-1,1,0}, {0,0,1,1}}, // 左上，蓝色
{{1,1,0}, {0,1,0,1}},  // 右上，绿色
};
</code></pre><p>索引数组</p>
<pre><code>const GLubyte Indices[] = {
0,1,2, // 三角形0
1,2,3  // 三角形1
};
</code></pre><h4 id="VBO申请空间并绑定目标-1"><a href="#VBO申请空间并绑定目标-1" class="headerlink" title="VBO申请空间并绑定目标"></a>VBO申请空间并绑定目标</h4><ol>
<li>取出Vertices数组中的坐标点值，赋给_positionSlot</li>
<li>取出Colors数组中的每个坐标点的颜色值，赋给_colorSlot</li>
<li>绘制两个三角形，不复用顶点，因此需要6个顶点坐标。</li>
<li>V0-V1-V2, V3-V4-V5</li>
</ol>
<h3 id="通用部分"><a href="#通用部分" class="headerlink" title="通用部分"></a>通用部分</h3><h4 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h4><pre><code>EAGLContext * _context;
CAEAGLLayer * _EALayer;
GLuint _colorBufferRender; // 渲染缓冲区
GLuint _frameBuffer;       // 帧缓冲区
GLuint _positionSlot;      // 用于绑定shader中的Position参数
GLuint _colorSlot;         // 用于绑定shader中的SourceColor参数
GLuint _glProgram;
</code></pre><h4 id="颜色和离屏渲染"><a href="#颜色和离屏渲染" class="headerlink" title="颜色和离屏渲染"></a>颜色和离屏渲染</h4><ol>
<li>生成一个renderBuffer，id是_colorRenderBuffer</li>
<li>设置为当前renderBuffer</li>
<li>为color renderbuffer 分配存储空间</li>
<li>FBO用于管理colorRenderBuffer，离屏渲染</li>
<li>设置为当前framebuffer</li>
<li><p>将 _colorRenderBuffer 装配到 GL_COLOR_ATTACHMENT0 这个装配点上</p>
<pre><code>-(void)setColorAndFrameBufferRender{
 if (_colorBufferRender) {
glDeleteRenderbuffers(1, &amp;_colorBufferRender);
_colorBufferRender = 0;
 } 
 if (_frameBuffer) {
glDeleteFramebuffers(1, &amp;_frameBuffer);
_frameBuffer = 0;
}
glGenRenderbuffers(1, &amp;_colorBufferRender);
glBindRenderbuffer(GL_RENDERBUFFER, _colorBufferRender);
[_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:_EALayer];
glGenFramebuffers(1, &amp;_frameBuffer);
glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);
glFramebufferRenderbuffer(GL_FRAMEBUFFER,
                      GL_COLOR_ATTACHMENT0,
                      GL_RENDERBUFFER,
                      _colorBufferRender);
 }
</code></pre></li>
</ol>
<h4 id="创建绘制对象"><a href="#创建绘制对象" class="headerlink" title="创建绘制对象"></a>创建绘制对象</h4><ol>
<li>setup context, 渲染上下文，管理所有绘制的状态，命令及资源信息。</li>
<li>setup layer, 必须要是CAEAGLLayer才行，才能在其上描绘OpenGL内容             </li>
<li>如果在viewController中，使用[self.view.layer addSublayer:eaglLayer];</li>
<li><p>如果在view中，可以直接重写UIView的layerClass类方法即可return [CAEAGLLayer class]。</p>
<pre><code>- (void)setContentViewAndCAEGLayer{
  _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];
 [EAGLContext setCurrentContext:_context];  
 _EALayer = (CAEAGLLayer*)self.view.layer;
 _EALayer.frame = self.view.frame;
 _EALayer.opaque = YES;
 _EALayer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithBool:YES],kEAGLDrawablePropertyRetainedBacking,kEAGLColorFormatRGBA8,kEAGLDrawablePropertyColorFormat, nil];
 }
</code></pre></li>
</ol>
<h4 id="设置清屏"><a href="#设置清屏" class="headerlink" title="设置清屏"></a>设置清屏</h4><ol>
<li>设置清屏颜色</li>
<li>用来指定要用清屏颜色来清除由mask指定的buffer，此处是color buffer</li>
<li><p>将指定renderBuffer渲染在屏幕上</p>
<pre><code>-(void)glClear{
glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
glClear(GL_COLOR_BUFFER_BIT);
glViewport(0, 0, self.view.frame.size.width , self.view.frame.size.height);
}
</code></pre></li>
</ol>
<h3 id="离屏渲染显示绘制图片"><a href="#离屏渲染显示绘制图片" class="headerlink" title="离屏渲染显示绘制图片"></a>离屏渲染显示绘制图片</h3><h3 id="创建glsl文件：建一个empty文件，修改后缀即可"><a href="#创建glsl文件：建一个empty文件，修改后缀即可" class="headerlink" title="创建glsl文件：建一个empty文件，修改后缀即可"></a>创建glsl文件：建一个empty文件，修改后缀即可</h3><p>三角形Fragment</p>
<pre><code>precision mediump float;
void main(void) {
gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); 
}
</code></pre><p>三角形Vertex</p>
<pre><code>attribute vec4 Position;
void main(void) {
gl_Position = Position;   
}
</code></pre><p>四边形Fragment</p>
<pre><code>varying lowp vec4 DestinationColor;
void main(void) {
gl_FragColor = DestinationColor; 
}
</code></pre><p>四边形Vertex</p>
<pre><code>attribute vec4 Position;  
attribute vec4 SourceColor;  
varying vec4 DestinationColor;
void main(void) {
   DestinationColor = SourceColor;
   gl_Position = Position;
}
</code></pre><h4 id="创建一个分类继承NSObject"><a href="#创建一个分类继承NSObject" class="headerlink" title="创建一个分类继承NSObject"></a>创建一个分类继承NSObject</h4><p>实现以下两个类方法</p>
<pre><code>+ (GLuint)compileShader:(NSString*)shaderName withType:(GLenum)shaderType;

+ (GLuint)compileShaders:(NSString *)shaderVertex shaderFragment:(NSString *)shaderFragment;
</code></pre><h4 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h4><p>四边形Shaders</p>
<pre><code>- (void)processShaders {
_glProgram = [TLShaderOperation compileShaders:@&quot;Vertex&quot; shaderFragment:@&quot;Fragment&quot;];
glUseProgram(_glProgram);
_positionSlot = glGetAttribLocation(_glProgram, &quot;Position&quot;);
_colorSlot = glGetAttribLocation(_glProgram, &quot;SourceColor&quot;);
}
</code></pre><p>三角形Shaders</p>
<pre><code>- (void)processTriangleShaders {
// 编译shaders
_glProgram = [TLShaderOperation compileShaders:@&quot;TriangleVertex&quot; shaderFragment:@&quot;TriangleFragment&quot;];
glUseProgram(_glProgram);
// 获取指向vertex shader传入变量的指针, 然后就通过该指针来使用
// 即将_positionSlot 与 shader中的Position参数绑定起来
glGetAttribLocation(_glProgram, &quot;Position&quot;);
}
</code></pre><h4 id="获取图片"><a href="#获取图片" class="headerlink" title="获取图片"></a>获取图片</h4><ol>
<li>unbind the shader</li>
<li>从FBO中读取图像数据，离屏渲染。</li>
<li>图像经过render之后，已经在FBO中了，即使不将其拿到RenderBuffer中，依然可以使用getResultImage取到图像数据。</li>
<li>用[_eaglContext presentRenderbuffer:GL_RENDERBUFFER];，实际上就是将FBO中的图像拿到RenderBuffer中（即屏幕上）</li>
</ol>
<pre>
- (UIImage *)getResultImage {

    CGSize currentFBOSize = self.view.frame.size;
    NSUInteger totalBytesForImage = (int)currentFBOSize.width * (int)currentFBOSize.height * 4;

    GLubyte *_rawImagePixelsTemp = (GLubyte *)malloc(totalBytesForImage);

    glReadPixels(0, 0, (int)currentFBOSize.width, (int)currentFBOSize.height, GL_RGBA, GL_UNSIGNED_BYTE, _rawImagePixelsTemp);
    glUseProgram(0);

    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, _rawImagePixelsTemp, totalBytesForImage, (CGDataProviderReleaseDataCallback)&freeData);
    CGColorSpaceRef defaultRGBColorSpace = CGColorSpaceCreateDeviceRGB();

    CGImageRef cgImageFromBytes = CGImageCreate((int)currentFBOSize.width, (int)currentFBOSize.height, 8, 32, 4 * (int)currentFBOSize.width, defaultRGBColorSpace, kCGBitmapByteOrderDefault, dataProvider, NULL, NO, kCGRenderingIntentDefault);
    UIImage *finalImage = [UIImage imageWithCGImage:cgImageFromBytes scale:1.0 orientation:UIImageOrientationDownMirrored];

    CGImageRelease(cgImageFromBytes);
    CGDataProviderRelease(dataProvider);
    CGColorSpaceRelease(defaultRGBColorSpace);

    return finalImage;
}
void freeData(void *info, const void *data, size_t size) {
    free((unsigned char *)data);
}
</pre>

<h4 id="用于显示图片"><a href="#用于显示图片" class="headerlink" title="用于显示图片"></a>用于显示图片</h4><pre><code>UIImage *image = [self getResultImage];

if (image) {
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100,  100, 100, 100)];
    imageView.backgroundColor = [UIColor whiteColor];
    imageView.contentMode = UIViewContentModeScaleAspectFit;
    imageView.image = image;
    [self.view addSubview:imageView];
}
</code></pre><p><img src="/2017/08/23/iOS-OpenGL图形绘制二/Triangle.png" alt="Triangle"><br><img src="/2017/08/23/iOS-OpenGL图形绘制二/Quadrangle.png" alt="Quadrangle"></p>
]]></content>
      
        <categories>
            
            <category> Ios </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 1 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[iOS_OpenGL环境搭建和图形绘制]]]></title>
      <url>/2017/08/22/iOS-OpenGL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="Welcome-to-my-blog-Thanks"><a href="#Welcome-to-my-blog-Thanks" class="headerlink" title="Welcome to my blog. Thanks."></a>Welcome to my blog. Thanks.</h3><p>Dome: <a href="https://github.com/princeSmall/iOS_OpenGL" target="_blank" rel="external">github地址</a></p>
<p>个人觉得OpenGl图形绘制很酷所以专研了一段时间，记录供以后自己使用和小白学习。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol>
<li><p>创建一个新的工程，点击target-&gt;Build Phases -&gt; Link Binary With Libraries添加库</p>
<ul>
<li>GLKit.framework</li>
<li>OpenGLES.framework</li>
</ul>
</li>
<li><p>导入 #import <glkit glkit.h=""> 头文件</glkit></p>
</li>
</ol>
<p>因为我用GLKBaseEffect绘制的，所以不需要导入更多的头文件</p>
<h3 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h3><h4 id="一个顶点数组对象会储存以下这些内容："><a href="#一个顶点数组对象会储存以下这些内容：" class="headerlink" title="一个顶点数组对象会储存以下这些内容："></a>一个顶点数组对象会储存以下这些内容：</h4><ul>
<li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</li>
<li>通过glVertexAttribPointer设置的顶点属性配置。</li>
<li>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</li>
</ul>
<h4 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h4><pre>
float vertices[] = {
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.0f,  0.5f, 0.0f
};
</pre>

<h4 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h4><pre>
typedef struct {
    GLfloat Positon[3];//位置
    GLfloat Color[4];//颜色

} Vertex;

顶点和颜色数组
const Vertex squareVertexData[] = {

    { 0.5f,  0.5f, -0.9f,  1.0f, 0.0f, 0.0f, 1.0f},  //0
    {-0.5f,  0.5f, -0.9f,  0.0f, 1.0f, 0.0f, 1.0f},  //1
    { 0.5f, -0.5f, -0.9f,  0.0f, 0.0f, 1.0f, 1.0f},  //2
    {-0.5f, -0.5f, -0.9f,  0.0f, 0.0f, 0.0f, 1.0f}   //3

};
三角形数组
const GLubyte Indices[] = {
    0, 1, 2,
    2, 1, 3
};
</pre>


<h3 id="顶点数组对象：Vertex-Array-Object，VBO"><a href="#顶点数组对象：Vertex-Array-Object，VBO" class="headerlink" title="顶点数组对象：Vertex Array Object，VBO"></a>顶点数组对象：Vertex Array Object，VBO</h3><ul>
<li><p>使用glGenBuffers函数和一个缓冲ID生成一个VBO对象：<br>unsigned int VBO;<br>glGenBuffers(1, &amp;VBO);</p>
</li>
<li><p>glBindBuffer函数把新创建的缓冲绑定到GL_ARRAY_BUFFER目标上：<br>glBindBuffer(GL_ARRAY_BUFFER, VBO);  </p>
</li>
<li><p>我们可以调用glBufferData函数，它会把之前定义的顶点数据复制到缓冲的内存中：<br>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);<br>glBufferData：</p>
</li>
</ul>
<ol>
<li>它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上</li>
<li>第二个参数指定传输数据的大小(以字节为单位)；用一个简单的sizeof计算出顶点数据大小就行</li>
<li>第三个参数是我们希望发送的实际数据。</li>
<li>第四个参数指定了我们希望显卡如何管理给定的数据<ul>
<li>GL_STATIC_DRAW ：数据不会或几乎不会改变。</li>
<li>GL_DYNAMIC_DRAW：数据会被改变很多。</li>
<li>GL_STREAM_DRAW ：数据每次绘制时都会改变。</li>
</ul>
</li>
</ol>
<p>现在我们已经把顶点数据储存在显卡的内存中，用VBO这个顶点缓冲对象管理</p>
<ul>
<li><p>创建一个VAO和创建一个VBO很类似：<br>unsigned int VAO;<br>glGenVertexArrays(1, &amp;VAO);</p>
</li>
<li><p>要想使用VAO，要做的只是使用glBindVertexArray绑定VAO</p>
<ol>
<li>绑定VAO<br>glBindVertexArray(VAO);</li>
<li>把顶点数组复制到缓冲中供OpenGL使用<br>glBindBuffer(GL_ARRAY_BUFFER, VBO);<br>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</li>
<li>设置顶点属性指针<br>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 <em> sizeof(float), (void</em>)0);<br>glEnableVertexAttribArray(0);</li>
</ol>
</li>
</ul>
<h4 id="三角形-1"><a href="#三角形-1" class="headerlink" title="三角形"></a>三角形</h4><ol>
<li>GL_ARRAY_BUFFER用于顶点数组</li>
<li>绑定vertexBuffer到GL_ARRAY_BUFFER</li>
<li>给VBO传递数据</li>
<li>取出地址</li>
<li>取出颜色</li>
<li>glVertexAttribPointer的最后一个参数是要获取的参数在GL_ARRAY_BUFFER（每一个Vertex）的偏移量</li>
</ol>
<pre>
- (void)setupVBOs{
    GLuint verticesBuffer;
    glGenBuffers(1, &verticesBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, verticesBuffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);
    glEnableVertexAttribArray(GLKVertexAttribPosition);
    glEnableVertexAttribArray(GLKVertexAttribColor);
    glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 6, (GLfloat *)NULL + 0);
    glVertexAttribPointer(GLKVertexAttribColor, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 6, (GLfloat *)NULL + 3);
}
</pre>

<h4 id="多边形-1"><a href="#多边形-1" class="headerlink" title="多边形"></a>多边形</h4><ol>
<li>申请一个标识符</li>
<li>把标识符绑定到GL_ARRAY_BUFFER上</li>
<li>把顶点数据从cpu内存复制到gpu内存</li>
<li>开启对应的顶点属性</li>
<li>设置合适的格式从buffer里面读取数据</li>
</ol>
<pre>
- (void)setupVBOs{
    GLuint buffer;
    glGenBuffers(1, &buffer);   
    glBindBuffer(GL_ARRAY_BUFFER, buffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(squareVertexData), squareVertexData, GL_STATIC_DRAW);
    GLuint elementBuffer;
    glGenBuffers(1, &elementBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW);  
    glEnableVertexAttribArray(GLKVertexAttribPosition);  
    glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), 0);
    glEnableVertexAttribArray(GLKVertexAttribNormal);
    glVertexAttribPointer(GLKVertexAttribNormal, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid *) (sizeof(GLfloat) * 3));
    glEnableVertexAttribArray(GLKVertexAttribColor);
    glVertexAttribPointer(GLKVertexAttribColor, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid *) (sizeof(GLfloat) * 6)); 
    glEnableVertexAttribArray(GLKVertexAttribTexCoord0); 
    glVertexAttribPointer(GLKVertexAttribTexCoord0, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid *) (sizeof(GLfloat) * 10));
}
</pre>

<h3 id="GLKViewDelegate"><a href="#GLKViewDelegate" class="headerlink" title="GLKViewDelegate"></a>GLKViewDelegate</h3><ol>
<li>启动着色器</li>
<li>添加背景颜色</li>
<li>绘制图形<pre>
-(void)glkView:(GLKView *)view drawInRect:(CGRect)rect
{
[TLEffect prepareToDraw];
glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
glDrawArrays(GL_TRIANGLES, 0, 3);    
}
</pre>

</li>
</ol>
<h3 id="在GLKView上绘制OpenGL内容"><a href="#在GLKView上绘制OpenGL内容" class="headerlink" title="在GLKView上绘制OpenGL内容"></a>在GLKView上绘制OpenGL内容</h3><pre>
- (void)setupContext{

    context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2];
    if (!context) {
        NSLog(@"Failed to initialize OpenGLES 2.0 context");
        exit(1);
    }
    [EAGLContext setCurrentContext:context];
    GLKView *view = [[GLKView alloc]init];
    view.delegate = self;
    view.frame = self.view.frame;
    view.context = context;

    view.drawableColorFormat = GLKViewDrawableColorFormatRGBA8888;
    if (![EAGLContext setCurrentContext:context]) {
        NSLog(@"Failed to set current OpenGL context");
        exit(1);
    }
    [self.view addSubview:view];
}
</pre>

<p><img src="/2017/08/22/iOS-OpenGL环境搭建和图形绘制/triangle.png" alt="T"><br><img src="/2017/08/22/iOS-OpenGL环境搭建和图形绘制/quadrangle.png" alt="Q"></p>
]]></content>
      
        <categories>
            
            <category> Ios </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 1 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[定时器timer]]]></title>
      <url>/2017/08/18/%E5%AE%9A%E6%97%B6%E5%99%A8timer/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/Timer" target="_blank" rel="external">github 地址</a></p>
<p> 项目中智能灯有个定时开关的功能，需要在界面上实现时间选择，动画走动然后就写了这个功能实现倒计时</p>
<h3 id="实现准备"><a href="#实现准备" class="headerlink" title="实现准备"></a>实现准备</h3><h4 id="时间数组："><a href="#时间数组：" class="headerlink" title="时间数组："></a>时间数组：</h4><pre>
1. hourArray   存放小时的数组
2. minuteArray 存放分钟的数组
 _hourArray = [NSMutableArray array];
    for (int i = 0; i < 24; i ++) {
        [_hourArray addObject:[NSString stringWithFormat:@"%d",i]];
    }
    _minuteArray = [NSMutableArray array];
    for (int i = 1; i < 60; i ++) {
        [_minuteArray addObject:[NSString stringWithFormat:@"%d",i]];
    }

</pre>

<h4 id="宏定义："><a href="#宏定义：" class="headerlink" title="宏定义："></a>宏定义：</h4><pre>
 #define WIN_WIDTH  [self.view.bounds.size.width]
 #define WIN_HEIGHT [self.view.bounds.size.height]
 #define BACKCOLOR  [UIColor colorWithRed:241/255.0 green:241/255.0 blue:241/255.0 alpha:1]
 #define BARCOLOR  [QPUtilities colorWithHexString:@"#242947" alpha:1.f]
</pre>

<h4 id="全局变量："><a href="#全局变量：" class="headerlink" title="全局变量："></a>全局变量：</h4><pre>
{
    BOOL OpenOrClose;
    dispatch_source_t _timer;
    int hours;
    int minites;
    int secondTotal;
    int delayTotal;
}
</pre>

<h3 id="时间选择器UIPickView"><a href="#时间选择器UIPickView" class="headerlink" title="时间选择器UIPickView"></a>时间选择器UIPickView</h3><h4 id="懒加载："><a href="#懒加载：" class="headerlink" title="懒加载："></a>懒加载：</h4><pre>
-(StellarTimeView *)dateTimeView{
    if (_dateTimeView == nil) {
        _dateTimeView =[[StellarTimeView alloc]initWithFrame:CGRectMake(0, 40, self.dateView.frame.size.width, self.view.bounds.size.height / 2 - 100)];
    }
    return _dateTimeView;
}
</pre>

<h4 id="pragma-mark-–-UIPickerViewDateSource"><a href="#pragma-mark-–-UIPickerViewDateSource" class="headerlink" title="pragma mark – UIPickerViewDateSource"></a>pragma mark – UIPickerViewDateSource</h4><pre>
- (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView {
    return 3;
}
-(NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component {
    if (component == 0) {
        return (unsigned)[_hourArray count];
    }else if (component == 1){
        return 1;
    }else
        return (unsigned)[_minuteArray count];
}
</pre>

<h4 id="pragma-mark-–-UIPickerViewDelegate"><a href="#pragma-mark-–-UIPickerViewDelegate" class="headerlink" title="pragma mark – UIPickerViewDelegate"></a>pragma mark – UIPickerViewDelegate</h4><pre>
-(CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent:(NSInteger)component {
    return 60;
}
-(CGSize)rowSizeForComponent:(NSInteger)component{  
    CGSize  size = CGSizeFromString(@"20");
    return  size;
}

-(void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component
{
    if (component == 0) {
        NSString  *_proNameStr = [_hourArray objectAtIndex:(unsigned)row];
        hours = [_proNameStr intValue];
    }else if (component == 1){

   }
   else {
        NSString  *_proTimeStr = [_minuteArray objectAtIndex:(unsigned)row];
        minites = [_proTimeStr intValue];
    }   
}
-(NSString*)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component
{
    if (component == 0) {
        return [_hourArray objectAtIndex:(unsigned)row];
    }else if (component == 1){
        return @":";
    }
    else {
        return [_minuteArray objectAtIndex:(unsigned)row];      
    }
}
</pre>

<h3 id="动画绘制"><a href="#动画绘制" class="headerlink" title="动画绘制"></a>动画绘制</h3><h4 id="懒加载：-1"><a href="#懒加载：-1" class="headerlink" title="懒加载："></a>懒加载：</h4><pre>
-(StellarTimeView *)dateTimeView{
    if (_dateTimeView == nil) {
        _dateTimeView =[[StellarTimeView alloc]initWithFrame:CGRectMake(0, 40, self.dateView.frame.size.width, self.view.bounds.size.height / 2 - 100)];
    }
    return _dateTimeView;
}
</pre>

<h4 id="添加一个navgationbar"><a href="#添加一个navgationbar" class="headerlink" title="添加一个navgationbar"></a>添加一个navgationbar</h4><pre>
- (void)setNavigationbar
{   
    CGRect screenRect = [[UIScreen mainScreen] bounds];
    UINavigationBar *navigationBar = [[UINavigationBar alloc] initWithFrame:CGRectMake(0, 0, screenRect.size.width, 49)];
    navigationBar.tintColor = [UIColor blackColor];
    navigationBar.backgroundColor = [UIColor greenColor];
    //创建 UINavigationItem
    UINavigationItem * navigationBarTitle = [[UINavigationItem alloc] initWithTitle:@"UINavigationBar"];
    [navigationBar pushNavigationItem: navigationBarTitle animated:YES];
    [self.view addSubview: navigationBar]; 

}
</pre>

<h4 id="注：-动画类已封装只需要传入Percent和progressView"><a href="#注：-动画类已封装只需要传入Percent和progressView" class="headerlink" title="注： 动画类已封装只需要传入Percent和progressView"></a>注： 动画类已封装只需要传入Percent和progressView</h4><h3 id="定时器的处理"><a href="#定时器的处理" class="headerlink" title="定时器的处理"></a>定时器的处理</h3><pre><code>- (void)timeHeadle{         
    if (_timer==nil) {
    __block int timeout = 0; //倒计时时间
        timeout = secondTotal;
        [self setIsTotalTimeSelect:secondTotal];
    if (timeout!=0) {
        dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
        _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);
        dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),(uint64_t) 1.0 * NSEC_PER_SEC, 0); //每秒执行
        dispatch_source_set_event_handler(_timer, ^{
            if(timeout&lt;=0){ //倒计时结束，关闭时界面显示

      dispatch_source_cancel(_timer);

    _timer = nil;

       dispatch_async(dispatch_get_main_queue(), ^{

     [self timeHide];

                });

            }
      else{
       int hour = (int)(timeout/3600);
       int minute = (int)(timeout-hour*3600)/60;                            
       int second = timeout-hour*3600-minute*60;

     dispatch_async(dispatch_get_main_queue(), ^{

                    if (secondTotal == 0) {
             int  total =[self isTotalTimeSelect];
                        self.dateTimeView.percent = (CGFloat)(total-delayTotal) / total + (CGFloat)(delayTotal- timeout) / total;
                    }
                else{
                        self.dateTimeView.percent = (CGFloat)(secondTotal-timeout)/(CGFloat)secondTotal;
                    }
                if (hour&lt;10) {
                     if (minute&lt;10) {
                          if (second&lt;10) {
                                self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:0%d&quot;,hour,minute,second];
                            }else{
                                self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:%d&quot;,hour,minute,second];
                            }
                        }else {
                            if (second&lt;10) {
                                self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:0%d&quot;,hour,minute,second];
                            }else{
                                self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:%d&quot;,hour,minute,second];
                            }
                        }
                    }else{
                        if (minute&lt;10) {
                            if (second&lt;10) {
                                self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:0%d&quot;,hour,minute,second];
                            }else{
                                self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:%d&quot;,hour,minute,second];
                            }
                        }else {
                            if (second&lt;10) {
                                self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:0%d&quot;,hour,minute,second];
                            }else{
                                self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:%d&quot;,hour,minute,second];
                            }
                        }
                    }
                });
                timeout--;
            }
        });
        dispatch_resume(_timer);
    }else{
        self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;00:00:00&quot;];
    }
    }
     }
</code></pre><p><img src="/2017/08/18/定时器timer/timeSelect.png" alt="时间选择"><br><img src="/2017/08/18/定时器timer/timeRun.png" alt="时间动画"></p>
]]></content>
      
        <categories>
            
            <category> Ios </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[[增删移]]]></title>
      <url>/2017/08/11/%E5%A2%9E%E5%88%A0%E7%A7%BB/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/CollectionViewCell.git" target="_blank" rel="external"> github 地址</a></p>
<p>   今日看到某娱乐项目选择增删移很好玩，周五上午没事就写了一个。<br>   利用CollectionViewCell，将数据持久化保存在infoplist。<br>   再也不怕回到解放前了。主要分[已添加]–[待添加]–[未添加]–[删除添加]</p>
<h3 id="CollectionViewCell"><a href="#CollectionViewCell" class="headerlink" title="CollectionViewCell"></a>CollectionViewCell</h3><pre>
 UIBarButtonItem * rightItem = [[UIBarButtonItem alloc]initWithTitle:@"新增加" style:UIBarButtonItemStylePlain target:self action:@selector(add)];
    self.navigationItem.rightBarButtonItem = rightItem;
    UICollectionViewFlowLayout * layout = [[UICollectionViewFlowLayout alloc]init];
    layout.itemSize = CGSizeMake(50, 50);
    layout.scrollDirection = UICollectionViewScrollDirectionVertical;
    self.collectionView = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height) collectionViewLayout:layout];
    self.collectionView.backgroundColor = [UIColor whiteColor];
    self.collectionView.delegate = self;
    self.collectionView.dataSource = self;
    [self.collectionView registerNib:[UINib nibWithNibName:@"CollectionViewCell" bundle:nil] forCellWithReuseIdentifier:identifier];
    [self.collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:headerId];
</pre> 

<h3 id="两个数组用来存放已添加的和待添加的"><a href="#两个数组用来存放已添加的和待添加的" class="headerlink" title="两个数组用来存放已添加的和待添加的"></a>两个数组用来存放已添加的和待添加的</h3><pre> 
   if ([[NSUserDefaults standardUserDefaults]objectForKey:@"one"] == nil) {
   self.oneArray = [NSMutableArray arrayWithObjects:@"0",@"1",@"2",@"3",@"4",@"5",@"6",@"7",@"8",@"9",@"10",@"11",@"12",@"13",@"14",@"15",@"16",@"17",@"18",@"19",nil];
    }else{
        id array = [[NSUserDefaults standardUserDefaults]objectForKey:@"one"];
        [self.oneArray addObjectsFromArray:array];
    }
    if ( [[NSUserDefaults standardUserDefaults]objectForKey:@"two"] == nil) {
        self.twoArray = [NSMutableArray arrayWithObjects:@"a",@"b",@"c",@"d",@"e",@"f",@"g",@"h",@"i",@"j", nil];
    }else{
        id array = [[NSUserDefaults standardUserDefaults]objectForKey:@"two"];
        [self.twoArray addObjectsFromArray:array];
    }
</pre>

<h3 id="每次改变后刷新要防止复用"><a href="#每次改变后刷新要防止复用" class="headerlink" title="每次改变后刷新要防止复用"></a>每次改变后刷新要防止复用</h3><pre>
 UICollectionReusableView *headerView = [self.collectionView dequeueReusableSupplementaryViewOfKind:kind withReuseIdentifier:headerId forIndexPath:indexPath];
    headerView.backgroundColor = [UIColor darkGrayColor];
    [headerView.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];
    _titleLab = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width - 50, 40)];
    _titleLab.textAlignment = NSTextAlignmentLeft;
    _titleLab.textColor = [UIColor whiteColor];
    [headerView addSubview:self.titleLab];
</pre>

<h3 id="编辑状态下进行移动和删除"><a href="#编辑状态下进行移动和删除" class="headerlink" title="编辑状态下进行移动和删除"></a>编辑状态下进行移动和删除</h3><pre>
-(void)edit{
    for (CollectionViewCell * cell in self.collectionView.visibleCells) {
        if (cell.edit == NO) {
            cell.layer.masksToBounds = NO;
            cell.layer.shadowOpacity = 0.7f;
            cell.layer.shadowColor = [UIColor darkGrayColor].CGColor;
            cell.layer.shadowOffset = CGSizeMake(1.f, 1.f);
            cell.deleteBtn.hidden = NO;
            [self.editBtn setTitle:@"完成" forState:UIControlStateNormal];
            cell.edit = YES;
        }else{
            cell.edit = NO;
            cell.deleteBtn.hidden = YES;
            cell.layer.masksToBounds = YES;
            [self.editBtn setTitle:@"编辑" forState:UIControlStateNormal];
        }
    }

}
</pre>

<h3 id="添加数据-持久化存储刷新界面"><a href="#添加数据-持久化存储刷新界面" class="headerlink" title="添加数据,持久化存储刷新界面"></a>添加数据,持久化存储刷新界面</h3><pre>
-(void)add{
    SCLAlertView * alert = [[SCLAlertView alloc]init];
    [alert setHorizontalButtons:YES];
    SCLTextView * textField = [alert addTextField:@"Enter your name"];
    [alert addButton:@"确定" actionBlock:^(void) {
        NSLog(@"Text value: %@", textField.text);
        [self.twoArray addObject:textField.text];
        [self.collectionView reloadData];
        [[NSUserDefaults standardUserDefaults]setObject:self.twoArray forKey:@"two"];
        [[NSUserDefaults standardUserDefaults]synchronize];

    }];   
  [alert showEdit:self title:nil subTitle:@"请输入名称" closeButtonTitle:@"取消" duration:0.0f];
</pre>

<h3 id="增删移随时保存数据"><a href="#增删移随时保存数据" class="headerlink" title="增删移随时保存数据"></a>增删移随时保存数据</h3><pre> 
    [[NSUserDefaults standardUserDefaults]setObject:self.oneArray forKey:@"one"];
    [[NSUserDefaults standardUserDefaults]setObject:self.twoArray forKey:@"two"];
    [[NSUserDefaults standardUserDefaults]synchronize];

</pre>



<p><img src="/2017/08/11/增删移/main.png" alt="mian"><br><img src="/2017/08/11/增删移/add.png" alt="add"><br><img src="/2017/08/11/增删移/remove.png" alt="remove"></p>
]]></content>
      
        <categories>
            
            <category> Ios </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[[自定义tarbar]]]></title>
      <url>/2017/08/03/%E8%87%AA%E5%AE%9A%E4%B9%89tarbar/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/REsideAndTarbar" target="_blank" rel="external"> github 地址</a></p>
<h3 id="pod-RESideMenu"><a href="#pod-RESideMenu" class="headerlink" title="pod RESideMenu"></a>pod RESideMenu</h3><ol>
<li><p>vim podfile</p>
<pre><code>platform :ios,&apos;8.0&apos;
target &apos;SideAndTarbar&apos; do
pod &apos;RESideMenu&apos;, &apos;~&gt; 4.0.7&apos;
</code></pre></li>
</ol>
<h3 id="AppDelegate-m"><a href="#AppDelegate-m" class="headerlink" title="AppDelegate.m"></a>AppDelegate.m</h3><pre><code>添加RESideMenuDelegate
</code></pre><ol>
<li><p>didFinishLaunchingWithOptions</p>
<pre><code>self.window = [[UIWindow alloc]initWithFrame:[[UIScreen mainScreen ]bounds]];
TableViewController * viewController =  [[TableViewController alloc]init];
TarBarViewController * barViewController = [[TarBarViewController alloc]init];
RESideMenu * sideMenu = [[RESideMenu alloc]initWithContentViewController:barViewController leftMenuViewController:viewController rightMenuViewController:nil];
sideMenu.delegate = self;
sideMenu.contentViewShadowEnabled = YES;
sideMenu.contentViewInPortraitOffsetCenterX = 100.f;
sideMenu.contentViewScaleValue = 1.0;
sideMenu.menuPreferredStatusBarStyle = UIStatusBarStyleLightContent;
sideMenu.bouncesHorizontally = NO;
self.window.rootViewController = sideMenu; 
</code></pre></li>
</ol>
<h3 id="自定义tabbar"><a href="#自定义tabbar" class="headerlink" title="自定义tabbar"></a>自定义tabbar</h3><ol>
<li><p>添加子控制器属性</p>
<ul>
<li>添加navgationbar</li>
<li>去除tabbar分割线</li>
<li>选中controller后图片和标题改变</li>
</ul>
</li>
</ol>
<pre>
-(void)addChildViewController:(UIViewController *)childController title:(NSString *)title image:(UIImage *)image selecteImage:(UIImage *)selectedImage{

    UINavigationController * controller = [[UINavigationController alloc]initWithRootViewController:childController];
    childController.view.backgroundColor = [UIColor whiteColor];
    childController.navigationItem.title = title;
    [[UITabBar appearance] setShadowImage:[UIImage new]]; [[UITabBar appearance] setBackgroundImage:[[UIImage alloc]init]];
    selectedImage = [selectedImage imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];
    self.tabBar.tintColor = [UIColor greenColor];  
    controller.tabBarItem = [[UITabBarItem alloc]initWithTitle:title image:image selectedImage:selectedImage];
    [self addChildViewController:controller];

}  
</pre>  

<ol>
<li>添加子控制器 <pre>
-(void)setNewBar{
OneViewController * one = [[OneViewController alloc]init];
[self addChildViewController:one title:@"MainOne" image:[UIImage imageNamed:@"icon_home_normal"] selecteImage:[UIImage imageNamed:@"icon_home_selected"]];
TwoViewController * two = [[TwoViewController alloc]init];
[self addChildViewController:two title:@"MainTwo" image:[UIImage imageNamed:@"icon_door_normal"] selecteImage:[UIImage imageNamed:@"icon_door_selected"]];
}
</pre>

</li>
</ol>
<h3 id="在各自类中进行操作就OK"><a href="#在各自类中进行操作就OK" class="headerlink" title="在各自类中进行操作就OK"></a>在各自类中进行操作就OK</h3><ol>
<li>例如：<pre>
self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc]initWithImage:[UIImage imageNamed:@"icon_sidebar"] style:UIBarButtonItemStylePlain target:self action:@selector(presentLeftMenuViewController:)];
 UIButton * button = [[UIButton alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];
 button.backgroundColor = [UIColor greenColor];
 [self.view addSubview:button];
</pre>

</li>
</ol>
<p><img src="/2017/08/03/自定义tarbar/main.png" alt=""><br><img src="/2017/08/03/自定义tarbar/mainTwo.png" alt=""><br><img src="/2017/08/03/自定义tarbar/left.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Ios </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo简单操作]]></title>
      <url>/2017/07/25/Hexo%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h3 id="Welcome-to-my-blog-Thanks"><a href="#Welcome-to-my-blog-Thanks" class="headerlink" title="Welcome to my blog. Thanks."></a>Welcome to my blog. Thanks.</h3><p>打开themes/next/source/css/_custom/custom.styl.<br>参考样式:<a href="https://princesmall.cn" target="_blank" rel="external">博客地址</a></p>
<p><img src="/2017/07/25/Hexo简单操作/css.png" alt="logo"></p>
<pre>/*标题  */
.post-title{
color: red;
}    
/*内容  */
.post-body{
color: green;
}
/*author  */
.author{
text-align: center;
color: red;
}
/*心photo  */
.with-love{
color: red;
}
/*乐乐  */
.theme-link{
color: red;
}
.busuanzi-value{
color: rebeccapurple;
}
</pre>

<h3 id="Next主题操作"><a href="#Next主题操作" class="headerlink" title="Next主题操作"></a>Next主题操作</h3><ol>
<li>生成新页面 <pre> hexo g</pre></li>
<li>发布代码  <pre> hexo d</pre></li>
<li>开启调试服务  <pre> hexo  s –debug</pre></li>
</ol>
<h3 id="为next主题的主页文章添加阴影效果"><a href="#为next主题的主页文章添加阴影效果" class="headerlink" title="为next主题的主页文章添加阴影效果"></a>为next主题的主页文章添加阴影效果</h3><ol>
<li>打开themes/next/source/css/_schemes/Mist/_posts-expanded.styl文件</li>
<li>找到类.posts-expand下面的.post<pre>
.post {
margin-top: 120px;
}
改成:
.post {
margin-top: 60px;
margin-bottom: 60px;
padding: 25px;
-webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);
-moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);
}
</pre>

</li>
</ol>
<h3 id="添加“Fork-me-on-Github”-ribbon"><a href="#添加“Fork-me-on-Github”-ribbon" class="headerlink" title="添加“Fork me on Github” ribbon"></a>添加“Fork me on Github” ribbon</h3><ol>
<li><p>打开themes\next\layout\layout.swig</p>
<pre><code>&lt;a href=&quot;你的地址&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; left: 0; border: 0;&quot; 
src=&quot;https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67&quot; 
alt=&quot;Fork me on GitHub&quot; 
data-canonical-src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png&quot;&gt;&lt;/a&gt;
</code></pre></li>
</ol>
<h3 id="404界面"><a href="#404界面" class="headerlink" title="404界面"></a>404界面</h3><ol>
<li>找到根目录-source<br><img src="/2017/07/25/Hexo简单操作/404.png" alt="logo"></li>
<li>创建HTML文件</li>
<li><p>打开：commonweal: /404.html</p>
<pre><code>&lt;html&gt;
&lt;body&gt;
&lt;script type=&quot;text/javascript&quot; 
src=&quot;http://www.qq.com/404/search_children.js&quot;         
charset=&quot;utf-8&quot; homePageUrl=&quot;http://www.princesmall.cn&quot;
 homePageName=&quot;回到乐乐的主页&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
注：如果返回的还是qq主页，请参考我网页源码，毕竟有些长，这只是不body。然后copy到你的404.html下
</code></pre></li>
</ol>
<h3 id="文章末尾追加版权信息"><a href="#文章末尾追加版权信息" class="headerlink" title="文章末尾追加版权信息"></a>文章末尾追加版权信息</h3><ol>
<li>找到themes/next/layout/_macro/reward.swig</li>
<li>在最上面添加如下代码：（最上面）<br><img src="/2017/07/25/Hexo简单操作/permalink.png" alt="permalink">   </li>
</ol>
<h3 id="Hexo插入图片"><a href="#Hexo插入图片" class="headerlink" title="Hexo插入图片"></a>Hexo插入图片</h3><ol>
<li>首先确认根目录下_config.yml 中有 post_asset_folder:true</li>
<li>在hexo的目录下执行npm install <a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="external">https://github.com/CodeFalling/hexo-asset-image</a> –save</li>
<li>创建文件hexo new “文件名”</li>
<li><p>在source下会生成一个和文件名一样的文件夹，图片放在该文件夹下</p>
<pre><code>例如：
  ![logo](文件名/logo.jpg)
  是不是so easy！
</code></pre></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 1 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/07/17/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
