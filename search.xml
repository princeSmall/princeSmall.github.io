<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[Animation_BasicAnimation]]]></title>
    <url>%2F2017%2F11%2F15%2FAnimation-BasicAnimation%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 由于下班的时候出了事故，导致卧病休息了一个月左右，天天根本没时间更新博客，觉得没有记录就没有进步，很难过。好歹前段时间完成了公司的任务，现在有时间整理点东西。关于Animation明天会陆续整理出来，今天就是最简单的BasicAnimation。 BasicAnimation 1、keyPath rotation 旋轉 scale 缩放 translation 平移 CGPoint Key Paths : (example)position.x 位移 CGRect Key Paths : (example)bounds.size.width 伸缩 origin 原点 size 大小 opacity 透明度 backgroundColor 背景 颜色 contents 内容 Shadow Key Path: 阴影 2、 duration：动画的持续时间 3、 repeatCount：动画的重复次数 4、 timingFunction：动画的时间节奏控制 5、Use case 0: animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.x&quot;]; //setFromValue不设置,默认以当前状态为准 [animation setToValue:@(2 * M_PI)]; break; case 1: animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.y&quot;]; //setFromValue不设置,默认以当前状态为准 [animation setToValue:@(2 * M_PI)]; break; case 2: animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;]; //setFromValue不设置,默认以当前状态为准 [animation setToValue:@(2 * M_PI)]; break; case 3: //平移 animation = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;]; //setFromValue不设置,默认以当前状态为准 [animation setToValue:[NSValue valueWithCGPoint:CGPointMake(self.redView.center.x, self.redView.center.y + 200)]]; break; case 4: animation = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;]; [animation setFromValue:@1.0]; [animation setToValue:@0.1]; break; case 5: animation = [CABasicAnimation animationWithKeyPath:@&quot;backgroundColor&quot;]; animation.fromValue = (__bridge id _Nullable)([UIColor redColor].CGColor); animation.toValue = (__bridge id _Nullable)([UIColor greenColor].CGColor); break; case 6: animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;]; [animation setFromValue:@1.0]; [animation setToValue:@0.1]; break; case 7: animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale.x&quot;]; [animation setFromValue:@1.0]; [animation setToValue:@0.1]; break; case 8: animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale.y&quot;]; [animation setFromValue:@1.0]; [animation setToValue:@0.1]; break; case 9: animation = [CABasicAnimation animationWithKeyPath:@&quot;bounds&quot;]; [animation setToValue:[NSValue valueWithCGRect:CGRectMake(self.redView.frame.origin.x, self.redView.frame.origin.y, 200, 200)]]; break; default: break; } [animation setDelegate:self];//代理回调 [animation setDuration:1];//设置动画时间，单次动画时间 [animation setRemovedOnCompletion:NO];//默认为YES,设置为NO时setFillMode有效 [animation setTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]]; [animation setAutoreverses:YES]; [animation setFillMode:kCAFillModeBoth]; [self.redView.layer addAnimation:animation forKey:@&quot;basicAnimation&quot;];]]></content>
      <categories>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS_零碎知识点整理]]]></title>
    <url>%2F2017%2F09%2F30%2FiOS-%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. 明天就十一，项目也告一段路，今天就把以前的零碎知识点整理下，备忘录好几页找都不好找了 iOS中属性@property的常用关键字strong，weak，assign，copy，nonatomic，retain ，atomic…. 属性 解析 strong 释放旧对象，将旧对象的值赋予输入对象，输入对象的索引计数加1 weak 不增加引用计数，不持有对象，因此也不能决定对象释放 assign 适用于基础数据类型（NSInteger CGFloat…），不增加引用计数 copy 建立一个索引计数为1 的对象然后释放旧对象，此属性只对那些实行了NSCopying协议的对象类型有效（NSString , Block） nonatomic 非原子性访问对于属性赋值的时候不加锁，多线程并发访问会提高性能，如果不加此属性则默认是两个访问方法都为原子型事务访问 retain 对象的引用计数+1。ARC下已经不再使用此关键字，用strong代替 atomic 和 nonatomic用来决定编译器生成的getter和setter是否为原子操作，atomic设置成员变量的@property属性时 默认为是atomic 提供线程安全 unsafe_unretained 跟weak类似，声明一个弱引用，但是当引用计数为0时，变量不会自动设置为nil ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？strong, atomic, readwrite copy 和 strong（1）因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.（2）如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性 ClassClass 是一个 objc_class 结构类型的指针；而 id（任意对象） 是一个 objc_object 结构类型的指针struct objc_class { struct objc_class* isa; struct objc_class* super_class; const char* name; long version; long info; long instance_size; struct objc_ivar_list* ivars; struct objc_method_list** methodLists; struct objc_cache* cache; struct objc_protocol_list* protocols; }; （1）isa：对象的isa指向类（class），类的isa指向元类（meta class），元类isa指向元类的根类（root meteClass）。isa 帮助一个对象找到它的方法 （2）super_class：指向该类的父类！如果该类已经是最顶层的根类，如 NSObject 或 NSProxy），那么 super_class 就为 NULL。 （3）name：一个 C 字符串，指示类的名称。 （4）version：类的版本信息，默认初始化为 0。我们可以在运行期对其进行修改（class_setVersion）或获取 （5）info：供运行期使用的一些位标识。有如下一些位掩码：CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含实例方法和变量；CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法；CLS_INITIALIZED (0x4L) 表示该类已经被运行期初始化了，这个标识位只被 objc_addClass 所设置；CLS_POSING (0x8L) 表示该类被 pose 成其他的类；（poseclass 在ObjC 2.0中被废弃了）；CLS_MAPPED (0x10L) 为ObjC运行期所使用CLS_FLUSH_CACHE (0x20L) 为ObjC运行期所使用CLS_GROW_CACHE (0x40L) 为ObjC运行期所使用CLS_NEED_BIND (0x80L) 为ObjC运行期所使用CLS_METHOD_ARRAY (0x100L) 该标志位指示 methodlists 是指向一个 objc_method_list 还是一个包含 objc_method_list 指针的数组； （6）instance_size：该类的实例变量大小（包括从父类继承下来的实例变量）。 （7）ivars：指向 objc_ivar_list 的指针，存储每个实例变量的内存地址，如果该类没有任何实例变量则为 NULL； （8）methodLists：与 info 的一些标志位有关，CLS_METHOD_ARRAY 标识位决定其指向的东西（是指向单个 objc_method_list还是一个 objc_method_list 指针数组），如果 info 设置了 CLS_CLASS 则 objc_method_list 存储实例方法，如果设置的是 CLS_META 则存储类方法； （9）cache：指向 objc_cache 的指针，用来缓存最近使用的方法，以提高效率。 （10）protocols：指向 objc_protocol_list 的指针，存储该类声明要遵守的正式协议。 IMPIMP本质上就是一个函数指针，指向方法的实现，在objc.h找到它的定义typedef void (IMP)(void / id, SEL, … */ ); #elsetypedef id (*IMP)(id, SEL, …); #endif objc_msgSendobjc_msgSend它具体是如何发送消息：首先根据receiver对象的isa指针获取它对应的class；优先在class的cache查找message方法，如果找不到，再到methodLists查找；如果没有在class找到，再到super_class查找；一旦找到message这个方法，就执行它实现的IMP。注：当objc_msgSend找不到实现的IMP时，程序并不会直接崩溃，而是给开发者一个plan b：方法决议与消息转发 iOS的一些小技巧控件 设置UILable行间距 NSMutableAttributedString* attrString = [[NSMutableAttributedString alloc] initWithString:label.text]; NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init]; [style setLineSpacing:20]; [attrString addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, label.text.length)]; label.attributedText = attrString; UILabel显示不同颜色字体 NSMutableAttributedString * string = [[NSMutableAttributedString alloc] initWithString:label.text]; [string addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0,5)]; [string addAttribute:NSForegroundColorAttributeName value:[UIColor greenColor] range:NSMakeRange(5,6)]; [string addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(11,5)]; label.attributedText = string; 动画修改label上的文字 方法一 CATransition * animation = [CATransition animation]; animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; animation.type = kCATransitionFade; animation.duration = 0.75; [self.label.layer addAnimation:animation forKey:@&quot;kCATransitionFade&quot;]; self.label.text = @&quot;New&quot;; 方法二 [UIView transitionWithView:self.label duration:0.25f options:UIViewAnimationOptionTransitionCrossDissolve animations:^{ self.label.text = @&quot;Well done!&quot;; } completion:nil]; 方法三 [UIView animateWithDuration:1.0 animations:^{ self.label.alpha = 0.0f; self.label.text = @&quot;newText&quot;; self.label.alpha = 1.0f; }]; 播放一张张连续的图片 加入现在有三张图片分别为animate_1、animate_2、animate_3 方法一： imageView.animationImages = @[[UIImage imageNamed:@&quot;animate_1&quot;], [UIImage imageNamed:@&quot;animate_2&quot;], [UIImage imageNamed:@&quot;animate_3&quot;]]; imageView.animationDuration = 1.0; 方法二： imageView.image = [UIImage animatedImageNamed:@&quot;animate_&quot; duration:1.0]; 方法二解释下： 这个方法会加载animate_为前缀的，后边0-1024，也就是animate_0、animate_1一直到animate_1024 修改UISearBar内部背景颜色 UITextField *textField = [_searchBar valueForKey:@&quot;_searchField&quot;]; textField.backgroundColor = [UIColor redColor]; 监听UISlider拖动状态 [slider addTarget:self action:@selector(sliderValurChanged:forEvent:) forControlEvents:UIControlEventValueChanged]; - (void)sliderValurChanged:(UISlider*)slider forEvent:(UIEvent*)event { UITouch *touchEvent = [[event allTouches] anyObject]; switch (touchEvent.phase) { case UITouchPhaseBegan: NSLog(@&quot;开始拖动&quot;); break; case UITouchPhaseMoved: NSLog(@&quot;正在拖动&quot;); break; case UITouchPhaseEnded: NSLog(@&quot;结束拖动&quot;); break; default: break; } } 加密 MD5加密 + (NSString *)md5:(NSString *)str { const char *concat_str = [str UTF8String]; unsigned char result[CC_MD5_DIGEST_LENGTH]; CC_MD5(concat_str, (unsigned int)strlen(concat_str), result); NSMutableString *hash = [NSMutableString string]; for (int i =0; i&lt;16; i++){ [hash appendFormat:@&quot;X&quot;, result[i]]; } return [hash uppercaseString]; } base64加密 @interface NSData (Base64) /** * @brief 字符串base64后转data */ + (NSData *)dataWithBase64EncodedString:(NSString *)string { if (![string length]) return nil; NSData *decoded = nil; #if __MAC_OS_X_VERSION_MIN_REQUIRED &lt; __MAC_10_9 || __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_7_0 if (![NSData instancesRespondToSelector:@selector(initWithBase64EncodedString:options:)]) { #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot; decoded = [[self alloc] initWithBase64Encoding:[string stringByReplacingOccurrencesOfString:@&quot;[^A-Za-z0-9+/=]&quot; withString:@&quot;&quot; options:NSRegularExpressionSearch range:NSMakeRange(0, [string length])]]; #pragma clang diagnostic pop } else #endif { decoded = [[self alloc] initWithBase64EncodedString:string options:NSDataBase64DecodingIgnoreUnknownCharacters]; } return [decoded length]? decoded: nil; } /** * @brief NSData转string * @param wrapWidth 换行长度 76 64 */ - (NSString *)base64EncodedStringWithWrapWidth:(NSUInteger)wrapWidth { if (![self length]) return nil; NSString *encoded = nil; #if __MAC_OS_X_VERSION_MIN_REQUIRED &lt; __MAC_10_9 || __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_7_0 if (![NSData instancesRespondToSelector:@selector(base64EncodedStringWithOptions:)]) { #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot; encoded = [self base64Encoding]; #pragma clang diagnostic pop } else #endif { switch (wrapWidth) { case 64: { return [self base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength]; } case 76: { return [self base64EncodedStringWithOptions:NSDataBase64Encoding76CharacterLineLength]; } default: { encoded = [self base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)0]; } } } if (!wrapWidth || wrapWidth &gt;= [encoded length]) { return encoded; } wrapWidth = (wrapWidth / 4) * 4; NSMutableString *result = [NSMutableString string]; for (NSUInteger i = 0; i &lt; [encoded length]; i+= wrapWidth) { if (i + wrapWidth &gt;= [encoded length]) { [result appendString:[encoded substringFromIndex:i]]; break; } [result appendString:[encoded substringWithRange:NSMakeRange(i, wrapWidth)]]; [result appendString:@&quot;\r\n&quot;]; } return result; } /** * @brief NSData转string 换行长度默认64 */ - (NSString *)base64EncodedString { return [self base64EncodedStringWithWrapWidth:0]; } 3DES加密 #import @interface NSData (3DES) /** * 利用3DES加密数据 */ - (NSData*)encryptedWith3DESUsingKey:(NSString*)key andIV:(NSData*)iv { NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding]; size_t dataMoved; NSMutableData *encryptedData = [NSMutableData dataWithLength:self.length + kCCBlockSize3DES]; CCCryptorStatus result = CCCrypt(kCCEncrypt,kCCAlgorithm3DES,kCCOptionPKCS7Padding,keyData.bytes,keyData.length,iv.bytes,self.bytes,self.length,encryptedData.mutableBytes,encryptedData.length,&amp;dataMoved); if (result == kCCSuccess) { encryptedData.length = dataMoved; return encryptedData; } return nil; } /** * @brief 利用3DES解密数据 */ - (NSData*)decryptedWith3DESUsingKey:(NSString*)key andIV:(NSData*)iv { NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding]; size_t dataMoved; NSMutableData *decryptedData = [NSMutableData dataWithLength:self.length + kCCBlockSize3DES]; CCCryptorStatus result = CCCrypt(kCCDecrypt,kCCAlgorithm3DES,kCCOptionPKCS7Padding,keyData.bytes,keyData.length,iv.bytes,self.bytes,self.length,decryptedData.mutableBytes,decryptedData.length,&amp;dataMoved); if (result == kCCSuccess) { decryptedData.length = dataMoved; return decryptedData; } return nil; } 零碎知识点 页面跳转实现翻转动画 modal方式 TestViewController *vc = [[TestViewController alloc] init]; vc.view.backgroundColor = [UIColor redColor]; vc.modalTransitionStyle = UIModalTransitionStyleCoverVertical; [self presentViewController:vc animated:YES completion:nil]; push方式: TestViewController *vc = [[TestViewController alloc] init]; vc.view.backgroundColor = [UIColor redColor]; [UIView beginAnimations:@&quot;View Flip&quot; context:nil]; [UIView setAnimationDuration:0.80]; [UIView setAnimationCurve:UIViewAnimationCurveEaseInOut]; [UIView setAnimationTransition:UIViewAnimationTransitionFlipFromRight forView:self.navigationController.view cache:NO]; [self.navigationController pushViewController:vc animated:YES]; [UIView commitAnimations]; 多网络请求： dispatch_group_t group = dispatch_group_create(); dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.wzb.test.www&quot;, DISPATCH_QUEUE_SERIAL); dispatch_group_enter(group); dispatch_group_async(group, serialQueue, ^{ // 网络请求一 [WebClick getDataSuccess:^(ResponseModel *model) { dispatch_group_leave(group); } failure:^(NSString *err) { dispatch_group_leave(group); }]; }); dispatch_group_enter(group); dispatch_group_async(group, serialQueue, ^{ // 网络请求二 [WebClick getDataSuccess:getBigTypeRM onSuccess:^(ResponseModel *model) { dispatch_group_leave(group); } failure:^(NSString *errorString) { dispatch_group_leave(group); }]; }); dispatch_group_enter(group); dispatch_group_async(group, serialQueue, ^{ // 网络请求三 [WebClick getDataSuccess:^{ dispatch_group_leave(group); } failure:^(NSString *errorString) { dispatch_group_leave(group); }]; }); // 所有网络请求结束后会来到这个方法 dispatch_group_notify(group, serialQueue, ^{ dispatch_async(dispatch_get_global_queue(0, 0), ^{ dispatch_async(dispatch_get_main_queue(), ^{ // 刷新UI }); }); }); 监听scrollView是否滚动到了顶部／底部 -(void)scrollViewDidScroll: (UIScrollView*)scrollView { float scrollViewHeight = scrollView.frame.size.height; float scrollContentSizeHeight = scrollView.contentSize.height; float scrollOffset = scrollView.contentOffset.y; if (scrollOffset == 0) { // 滚动到了顶部 } else if (scrollOffset + scrollViewHeight == scrollContentSizeHeight) { // 滚动到了底部 } } 过滤空格 -(NSString *)userName:(NSString *)name{ name = [name stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];//前后空格 name = [name stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];//中间空格 return name; } 获取邮箱用户部分和域名部分 - (BOOL)validateEmail:(NSString *)email { if ((0 != [email rangeOfString:@&quot;@&quot;].length) &amp;&amp; (0 != [email rangeOfString:@&quot;.&quot;].length)) { NSCharacterSet *tmpInvalidCharSet = [[NSCharacterSet alphanumericCharacterSet] invertedSet]; NSMutableCharacterSet *tmpInvalidMutableCharSet = [tmpInvalidCharSet mutableCopy]; [tmpInvalidMutableCharSet removeCharactersInString:@&quot;_-&quot;]; NSRange range1 = [email rangeOfString:@&quot;@&quot; options:NSCaseInsensitiveSearch]; //取得用户名部分 NSString *userNameString = [email substringToIndex:range1.location]; NSLog(@&quot;length---%ld&quot;,userNameString.length); if (userNameString.length &lt; 1 || userNameString.length &gt; 20) { return NO; }else //取得域名部分 NSString *domainString = [email substringFromIndex:range1.location + 1]; NSArray *domainArray = [domainString componentsSeparatedByString:@&quot;.&quot;]; for (NSString *string in domainArray) { NSRange rangeOfInavlidChars = [string rangeOfCharacterFromSet:tmpInvalidMutableCharSet]; if (rangeOfInavlidChars.length != 0 || [string isEqualToString:@&quot;&quot;]) return NO; } return YES; } else { return NO; } }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS_正则表达式]]]></title>
    <url>%2F2017%2F09%2F25%2FiOS-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. 新的项目用户名、邮箱和密码等要用到正则，所以就把以前整理的拿出来用了，不要太方便，索性就打个flag吧。嗯，我以前笔记做的还是比较清楚的 正则表达式记录表 元字符1、 \b : 单词的开始或结束 2、 .* : 任意数量的不包含换行的字符 . : 匹配除换行符以外的任意字符 3、 \d : 是新的元字符，匹配一位数字 \d{n} : 必须连续重复匹配n次 4、 \s : 匹配任意的空白符（空格，制表格，换行符，中文全角空格等） 5、 \w : 匹配字母或者数字或者下划线或者汉字等 6、 ^ : 匹配字符串的开始 ￥ : 匹配字符串的结束 注意： * 字符转义 如果你想查找元字符本身，比如.和* ，这时候你就应该使用\.和\* 重复 代码 | 说明 ------------- | ------------- * | 重复零次或更多次 + | 重复一次或更多次 ? | 重复零次或一次 {n} | 重复n次 {n,} | 重复n次或更多次 {n,m} | 重复n到m次 注意： *字符类 如果想匹配没有预定义的元字符集合，比如a，e，o。这时候你就要[aeo]就匹配任何一个英文元音的字母。[.?!]匹配任意一个标点符号 分枝条件 满足任意一种规则都应该当成匹配，用 | 把不同的规则分割开来 0\d{2}-\d{8}|0\d{3}-\d{7} 这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445) \(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔 使用分枝条件时，要注意个分枝的顺序 \d{5}-\d{4}|\d{5} 换成 \d{5}|\d{5}-\d{4}，那么就只会匹配5位的邮编。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了 重复多个字符，使用分组 (\d{1,3}\.){3}\d{1,3}是一个简单的IP地址匹配表达式 (\d{1,3}\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3}) 不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址 ((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。解析正确IP：01-09,0-255 1. 2[0-4]\d :（200-249) 2. 25[0-5] :(250-255) 3. [01]?\d\d? : (01-09,0-199) 反义 代码 |语法 --------------|------------------- \W |匹配任意不是字母，数字，下划线，汉字的字符 \S |匹配任意不是空白符的字符 \D |匹配任意非数字的字符 \B |匹配不是单词开头或结束的位置 [^x] |匹配除了x以外的任意字符 [^aeiou] |匹配除了aeiou这几个字母以外的任意字符 例如： \S+匹配不包含空白符的字符串。 &lt;a[^&gt;]+&gt;匹配用尖括号括起来的以a开头的字符串 后向引用常用分组语法 分类 |代码/语法 |说明 -----------|-------------|----------------- 捕获 | (exp) |匹配exp,并捕获文本到自动命名的组里 | (?&lt;name&gt;exp |匹配exp,并捕获文本到名称为name的组里，也可以写成(?&apos;name&apos;exp) | (?:exp) |匹配exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言 | (?=exp) | 匹配exp前面的位置 | (?&lt;=exp) |匹配exp后面的位置 | (?!exp) |匹配后面跟的不是exp的位置 | (?&lt;!exp) |匹配前面不是exp的位置 注释 | (?#comment) |这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 注意： 分组0对应整个正则表达式 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号 你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权 例如： \b(\w+)\b\s+\1\b可以用来匹配重复的单词：html html 零宽断言 &lt;?!w+&gt; ?&lt;!w+ \b\w*q[^u]\w*\b匹配包含后面不是字母u的字母q的单词。 你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w*\b将会匹配下一个单词，于是\b\w*q[^u]\w*\b就能匹配整个Iraq fighting 负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：\b\w*q(?!u)\w*\b 例如 \d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。 (?&lt;![a-z])\d{7}匹配前面不是小写字母的七位数字。 (?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)匹配不包含属性的简单HTML标签内里的内容：被尖括号括起来的单词(比如可能是&lt;b&gt;)，然后是.*(任意的字符串),最后是一个后缀(?=&lt;\/\1&gt;)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是&lt;b&gt;的话，后缀就是&lt;/b&gt;了。整个表达式匹配的是&lt;b&gt;和&lt;/b&gt;之间的内容(再次提醒，不包括前缀和后缀本身) 注释 代码 |语法 ------------------|----------------- (?&lt;= |# 断言要匹配的文本的前缀 &lt;(\w+)&gt; |# 查找尖括号括起来的字母或数字(即HTML/XML标签) ( | # 前缀结束 .* | # 匹配任意文本 (?= | # 断言要匹配的文本的后缀 &lt;\ / \1&gt; |# 查找尖括号括起来的内容：前面是一个&quot;/&quot;，后面是先前捕获的标签 ) | # 后缀结束 例如： 2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)。 贪婪和懒惰 a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。它会匹配整个字符串aabab。这被称为贪婪匹配 a.*?b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，匹配任意数量的重复，(但是在能使整个匹配成功的前提下)使用最少的重复,会匹配aab和ab。这被称为懒惰匹配 注意： 为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？ 简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高： 最先开始的匹配拥有最高的优先权 懒惰限定符 代码 |说明 -----------------|------------------------ *？ |重复任意次，但尽可能少重复 +？ |重复1次或更多次，但尽可能少重复 ？？ |重复0次或1次，但尽可能少重复 {n,m}? |重复n到m次，但尽可能少重复 {n,}? |重复n次以上，但尽可能少重复 处理选项注意: Regex regex = new Regex(@&quot;\ba\w{6}\b&quot;, RegexOptions.IgnoreCase); 常用的处理选项 名称 |说明 ---------------------------|-------------------------------- IgnoreCase |匹配时不区分大小写 Multiline |更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.) Singleline |更改.的含义，使它与每一个字符匹配（包括换行符\n） IgnorePatternWhitespace |忽略表达式中的非转义空白并启用由#标记的注释。 ExplicitCapture | 仅捕获已被显式命名的组。 常用事例 说明 |正则表达式 -----------------|---------------------------- 网址(url) |[a-zA-z]+://[^\s]* IP地址 |((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?) 电子邮件(email) |\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)* QQ号码 | [1-9]\d{4,} HTML标签 |&lt;(.*)(.*)&gt;.*&lt;\/\1&gt;|&lt;(.*) \/&gt; 密码(有数字/大写字母/小写字母/标点，8位以上) |(?=^.{8,}$)(?=.*\d)(?=.*\W+)(?=.*[A-Z])(?=.*[a-z])(?!.*\n).*$ 日期 |(\d{4}|\d{2})-((1[0-2])|(0?[1-9]))-(([12][0-9])|(3[01])|(0?[1-9])) 汉字 |[\u4e00-\u9fa5] 中文及全角标点符号 |[\u3000-\u301e\ufe10-\ufe19\ufe30-\ufe44\ufe50-\ufe6b\uff01-\uffee] 注意： ios 开发使用 RegexKit.framework 框架 使用规则： 昵称验证：(4-8)位汉字 + (BOOL) validateNickname:(NSString *)nickname { NSString *nicknameRegex = @&quot;^[\u4e00-\u9fa5]{4,8}$&quot;; NSPredicate *passWordPredicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,nicknameRegex]; return [passWordPredicate evaluateWithObject:nickname]; } 密码验证：(6-20)位英文不分大小写和数字 + (BOOL) validatePassword:(NSString *)passWord { NSString *passWordRegex = @&quot;^[a-zA-Z0-9]{6,20}+$&quot;; NSPredicate *passWordPredicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,passWordRegex]; return [passWordPredicate evaluateWithObject:passWord]; } 邮箱验证： + (BOOL) validateEmail:(NSString *)email { NSString *emailRegex = @&quot;[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}&quot;; NSPredicate *emailTest = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, emailRegex]; return [emailTest evaluateWithObject:email]; }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[GIT_版本库管理]]]></title>
    <url>%2F2017%2F09%2F22%2FGIT-%E7%89%88%E6%9C%AC%E5%BA%93%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[今天新同事不会用git，着实让我惊讶了，还好我有做笔记的习惯。就把我A long time ago 学习整理的git给他了，上手简单，很快就会成为git 大神，啊哈哈 Git 小技能多人开发Git版本库的管理是再好不过的了，首先你要会把远程仓库的代码clone到你的电脑里，其次建立本地你的分支，写上你的code，然后添加到暂存区，没有问题就提交到修改区。既然是同时开发，肯能你同事也修改了，那就要把他的code先从远程仓库pull下来，不管你知不知道他们是否提交，避免冲突，先pull再push。然后无误后在merge到master分支，一切一气呵成。 远程仓库管理 先克隆代码到桌面吧，这克隆的是master分支代码 cd desktop git clone (远程仓库地址) 如果你想克隆远程别的分支代码 git checkout -b (分支名) origin/(远程分支名) git checkout —track origin/(远程分支名) 添加远程仓库 git remote add origin (远程仓库地址)： 删除远程仓库 git remote remove origin (远程仓库地址) 显示远程分支 git remote show origin 代码管理 代码添加到暂存区 git add (文件名)：添加某个文件 git add . : 添加所有文件 git add -A : 添加所有文件夹和文件 代码添加到当前分支 git commit -m "提交描述" 拉取远程代码 git pull origin (远程分支) 同步本地代码 git push origin (远程分支) 分支管理 查看当前分支 git branch 创建新的分支 git checkout -b newBranch 删除旧的分支 git checkout -d newBranch 合并分支 git merge (要合并的分支) 提交管理 找到历史提交的commit id git log —pretty=oneline —abbrev-commit 取消暂存 git reset HEAD 文件名 放弃当前修改 git checkout -- (文件名)：（放弃当前文件修改） git checkout . :(放弃当前所有修改) 恢复commit_id对应的版本 git reset --hard commit_id 标签管理 查看标签 git tag 查看标签信息 git show v1.0 创建标签 git tag v1.0 : 创建1.0标签 git tag v2.0 (commit_id): 创建指定提交的标签 删除标签 git tag -d v1.0 :（删除1.0标签） git push origin :refs/tags/v0.9：（删除远程0.9标签） 推送本地标签 git push origin v1.0 ：（推送本地标签到远程） git push origin —tags：（推送所有本地标签到远程） 当然没有写Git冲突处理，因为我觉得冲突太简单了，打开项目包内容，定位到冲突的地方。保留正确的code，删除多余的运行就OK。如果一些乱七八糟的冲突，当然我也遇到过但是没有记录下来，很遗憾。 冲突解决]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[机器学习_CoreML_Inceptionv3]]]></title>
    <url>%2F2017%2F09%2F21%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-CoreML-Inceptionv3%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome:github地址 一直直接用图片给.mlmodel去识别，觉得没有直接调用相机来的方便，一直看的都是swift版本的，所以想写一个oc的，立个flag。 CoreML_Inceptionv3 相机调用 info.plist 添加调用相机请求 相机调用请求 相机数据输出的delegate 实例化对象 摄像显示区域 相机调用请求 相机数据输出 线程 数据显示 InceptionvModel InceptionvModel输出 @property (nonatomic,strong) AVCaptureVideoPreviewLayer *previewLayer; @property (nonatomic,strong) AVCaptureSession *session; @property (nonatomic,strong) AVCaptureVideoDataOutput *videoOutPut; @property (nonatomic,strong) AVCaptureConnection *videoConnection; @property (nonatomic,strong) dispatch_queue_t videoQueue; @property (nonatomic,strong) UILabel *resultLabel; @property (nonatomic,strong) Inceptionv3 *InceptionvModel; @property (nonatomic,strong) Inceptionv3Output *outPut; 相机调用请求 self.session = [[AVCaptureSession alloc] init]; //视频 AVCaptureDevice *videoDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; if (videoDevice.isFocusPointOfInterestSupported && [videoDevice isFocusModeSupported:AVCaptureFocusModeContinuousAutoFocus]) { [videoDevice lockForConfiguration:nil]; [videoDevice setFocusMode:AVCaptureFocusModeContinuousAutoFocus]; [videoDevice unlockForConfiguration]; } AVCaptureDeviceInput *cameraDeviceInput = [[AVCaptureDeviceInput alloc] initWithDevice:videoDevice error:nil]; if ([self.session canAddInput:cameraDeviceInput]) { [self.session addInput:cameraDeviceInput]; } //视频 self.videoOutPut = [[AVCaptureVideoDataOutput alloc] init]; NSDictionary * outputSettings = [[NSDictionary alloc] initWithObjectsAndKeys:[NSNumber numberWithInt:kCVPixelFormatType_32BGRA],(id)kCVPixelBufferPixelFormatTypeKey, nil]; [self.videoOutPut setVideoSettings:outputSettings]; if ([self.session canAddOutput:self.videoOutPut]) { [self.session addOutput:self.videoOutPut]; } self.videoConnection = [self.videoOutPut connectionWithMediaType:AVMediaTypeVideo]; self.videoConnection.enabled = NO; [self.videoConnection setVideoOrientation:AVCaptureVideoOrientationPortrait]; 初始化预览层 self.previewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:self.session]; [self.previewLayer setVideoGravity:AVLayerVideoGravityResizeAspectFill]; 打开相机 [self.session startRunning]; self.videoConnection.enabled = YES; self.videoQueue = dispatch_queue_create("videoQueue", NULL); [self.videoOutPut setSampleBufferDelegate:self queue:self.videoQueue]; 关闭相机 [self.videoOutPut setSampleBufferDelegate:nil queue:nil]; self.videoConnection.enabled = NO; self.videoQueue = nil; [self.session stopRunning]; CoreML数据输出 获取相机数据输出的CMSampleBufferRef 转换成UIImage大小为299.299 输出为Inceptionv3Output 下载Inceptionv3.mlmodel target-&gt;build phases-&gt;compile sources 添加Inceptionv3.mlmodel 导入头文件Inceptionv3.h 数据转换 -(UIImage *)image:(CGSize)resize{ UIGraphicsBeginImageContext(resize); [self drawInRect:CGRectMake(0, 0, resize.width, resize.height)]; UIImage * image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image; } 数据输出 -(void)imageOutput:(CMSampleBufferRef)sampleBuffer{ CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer); CIImage * ciImage = [CIImage imageWithCVImageBuffer:imageBuffer]; Inceptionv3Image * uiImage =[[Inceptionv3Image alloc]initWithCIImage:ciImage]; UIImage * uiimage = [uiImage image:CGSizeMake(299, 299)]; CGImageRef cgImage = uiimage.CGImage; CVPixelBufferRef pixelBuffer = [ImageConvert pixelBufferFromImage:cgImage]; self.InceptionvModel = [[Inceptionv3 alloc]init]; self.outPut = [self.InceptionvModel predictionFromImage:pixelBuffer error:nil]; } 在AVCaptureOutputDelegat回调方法中开启线程 把相机输出的数据转换成Inceptionv3接收的数据 在主线程刷新界面 dispatch_queue_t queue = dispatch_queue_create("CMSampleBufferRef", NULL); dispatch_sync(queue, ^{ [self imageOutput:sampleBuffer]; dispatch_async(dispatch_get_main_queue(), ^{ self.resultLabel.text = self.outPut.classLabel; }); });]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[机器学习_CoreML_MobileNet]]]></title>
    <url>%2F2017%2F09%2F20%2FPython-CoreML-MobileNet%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome:github地址 CoreML_MobileNet接着上面再写一个MobileNet.mlmodel,这次这个直接拿来用。 GoogLeNetPlaces.mlmodel 和 Resnet50都可以识别人物和静态物体。不过这个才24M，小多了，所以就简尔处理给张特定的image，然后输出结果 Download Core ML ModelGoogLeNetPlaces.mlmodel下载地址 导入头文件 #import < CoreML/CoreML.h> #import < Vision/Vision.h> #import "GoogLeNetPlaces.h" 图片识别 创建Resnet对象，加载CoreMLModel GoogLeNetPlaces *googleModel = [[GoogLeNetPlaces alloc] init]; VNCoreMLModel * vnCoreModel = [VNCoreMLModel modelForMLModel:googleModel.model error:nil]; 创建Vision请求，带有completion handle VNCoreMLRequest * vnCoreMlRequest = [[VNCoreMLRequest alloc] initWithModel:vnCoreModel completionHandler:^(VNRequest * _Nonnull request, NSError * _Nullable error) { CGFloat confidence = 0.0f; VNClassificationObservation * tempClassification = nil; for (VNClassificationObservation *classification in request.results) { if (classification.confidence > confidence) { confidence = classification.confidence; tempClassification = classification; } } }]; VNClassificationObservation对象两个属性 identifier：识别对象 confidence：识别率 发送图片识别请求 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ VNImageRequestHandler * vnImageRequestHandler = [[VNImageRequestHandler alloc] initWithCGImage:image.CGImage options:nil]; NSError *error = nil; [vnImageRequestHandler performRequests:@[vnCoreMlRequest] error:&error]; if (error) { NSLog(@"%@",error.localizedDescription); } }); 回调在主线程更新UI dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ self.resultLable.text = [NSString stringWithFormat:@"识别结果:%@",tempClassification.identifier]; self.confidenceLabel.text = [NSString stringWithFormat:@"匹配率:%@",@(tempClassification.confidence)]; }); 多次下来是不是很简单，大同小异，只要熟悉CoreML，一切就是那么easy]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[机器学习_CoreML_Resnet50]]]></title>
    <url>%2F2017%2F09%2F20%2FPython-CoreML-Resnet50%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome:github地址 CoreML_Resnet50把玩了几天的CoreML，现在上手就写很是方便啊，所以研究透之后再来些例子就简单了。这次用的是苹果提供的resnet50.mlmodel。 Download Core ML ModelResnet50.mlmodel下载地址 导入 把下载后的mlmodel放入Xcode里面，绑定target，会自动生成.h和.m文件 导入头文件 #import < CoreML/CoreML.h> #import < Vision/Vision.h> #import "Resnet50.h" 添加UIScrollView和UIPageControl self.scrollView = [[UIScrollView alloc]initWithFrame:CGRectMake(0, 0, viewWidth, 250)]; self.scrollView.delegate = self; self.scrollView.bounces = YES; self.scrollView.contentSize = CGSizeMake(5 * viewWidth, 250); self.scrollView.pagingEnabled = YES; self.scrollView.showsHorizontalScrollIndicator = NO; [self.view addSubview:self.scrollView]; self.pageControl = [[UIPageControl alloc]init]; [self.pageControl setCenter:CGPointMake(viewWidth / 2 - 20, 250 - 10)]; self.pageControl.numberOfPages = 5; self.pageControl.pageIndicatorTintColor = [UIColor blackColor]; self.pageControl.currentPageIndicatorTintColor = [UIColor redColor]; for (int i = 0; i < 5; i ++) { UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(i * viewWidth, 0, viewWidth, 250)]; imageView.image = [UIImage imageNamed:[NSString stringWithFormat:@"%d.jpg",i + 1]]; [self.scrollView addSubview:imageView]; } [self.view addSubview:self.pageControl]; 滚动到开头或末尾 if (scrollView.contentOffset.x > 4 * viewWidth) { self.scrollView.contentOffset = CGPointMake(0, 0); }else if (scrollView.contentOffset.x < 0){ self.scrollView.contentOffset = CGPointMake(4 * viewWidth, 0); } 滚动结束后识别图片 self.currentImage =[UIImage imageNamed:[NSString stringWithFormat:@"%d.jpg",(int)(self.pageControl.currentPage)]]; [self openResnet50]; 图片识别 创建Resnet对象，加载CoreMLModel Resnet50 *resnetModel = [[Resnet50 alloc] init]; VNCoreMLModel * vnCoreModel = [VNCoreMLModel modelForMLModel:resnetModel.model error:nil]; 创建Vision请求，带有completion handle VNCoreMLRequest * vnCoreMlRequest = [[VNCoreMLRequest alloc] initWithModel:vnCoreModel completionHandler:^(VNRequest * _Nonnull request, NSError * _Nullable error) { CGFloat confidence = 0.0f; VNClassificationObservation * tempClassification = nil; for (VNClassificationObservation *classification in request.results) { if (classification.confidence > confidence) { confidence = classification.confidence; tempClassification = classification; } } }]; VNClassificationObservation对象两个属性 identifier：识别对象 confidence：识别率 发送图片识别请求 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ VNImageRequestHandler * vnImageRequestHandler = [[VNImageRequestHandler alloc] initWithCGImage:image.CGImage options:nil]; NSError *error = nil; [vnImageRequestHandler performRequests:@[vnCoreMlRequest] error:&error]; if (error) { NSLog(@"%@",error.localizedDescription); } }); 回调在主线程更新UI dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ self.resultLable.text = [NSString stringWithFormat:@"识别结果:%@",tempClassification.identifier]; self.confidenceLabel.text = [NSString stringWithFormat:@"匹配率:%@",@(tempClassification.confidence)]; });]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[机器学习_Python_mlmodel]]]></title>
    <url>%2F2017%2F09%2F20%2FPython-mlmodel%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome:github地址 CoreMLModel把玩CoreML创建自己的.mlmodel的心酸历程，足足摆弄了半天，各种坑。立个flag [Permission denied]问题 pip install -U coremltools 从图也可以看出coremltools包含numpy,six,protobuf,coremltools。因为权限问题导致失败 sudo pip install -U coremltools 遇到[Permission denied]都要加sudo ImportError: No module named pkg_resources 问题 Step: 1 Login in root user. sudo su root Step: 2 Uninstall python-pip package if existing. apt-get purge -y python-pip Step: 3 Download files using wget command(File download in pwd ) wget https://bootstrap.pypa.io/get-pip.py Step: 4 Run python file. python ./get-pip.py Step: 5 Finaly exicute installation command. apt-get install python-pip Note: User must be root. 好吧，这两个问题遍布整个流程，期间各种小问题我已经不记得了，接下来就开始正文了 下载coremltools sudo pip install -U coremltools 下载pip.py文件 sudo python get-pip.py 下载scikit-learn sudo pip install -U numpy scipy scikit-learn 下载panda sudo pip install pandas 准备就绪，开工 创建csv文件 csv文件属性Square_Feet，Price 记录文件所存储位置，调用的时候需要 在终端输入生成.mlmodel文件 导入需要的类 调用csv文件 coremltools转换成.mlmodel文件 author,license,description描述 输入Square_Feet，输出Price，保存 import coremltools from sklearn.linear_model import LinearRegression import pandas as pd data = pd.read_csv(‘/Users/sansi/Desktop/CoreMLModel/input_data.csv’) model = LinearRegression() model.fit(data[[“Square_Feet”]], data[“Price”]) coreml_model = coremltools.converters.sklearn.convert(model, “Square_Feet”, “Price”) coreml_model.author = ‘tongle’ coreml_model.license = ‘BSD’ coreml_model.short_description = ‘Predicts the price of a house in the Seattle area.’ coreml_model.input_description[‘Square_Feet’] = ‘Size (in square feet)’ coreml_model.output_description[‘Price’] = ‘Price of the house’ coreml_model.save(‘HousePricer.mlmodel’) 如果没有一点python功底，我都要死在电脑前了，哈哈]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS_CellAnimation]]]></title>
    <url>%2F2017%2F09%2F12%2FiOS-CellAnimation%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 最近在用cell动画，就研究修改了别人的cell动画，整理了一下。 使用：导入Animation类，直接用类调用,输入要动画的tableview和动画type，即可 [Animation addAnimationWithTableView:tableView andRow:self.type]; UITableViewCell 出场动画：简而明了的说就是利用cell的contentView来做一下出场动画animation CGFloat width = [[UIScreen mainScreen] bounds].size.width - 40; UIView *view = [[UIView alloc] initWithFrame:CGRectMake(20, 10, width, 60)]; view.backgroundColor = [UIColor redColor]; view.layer.masksToBounds = YES; view.layer.cornerRadius = 9.0; [cell.contentView addSubview:view]; UIViewmove动画 + (void)moveAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i < cells.count; i++) { CGFloat totalTime = 0.4; UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i]; cell.transform = CGAffineTransformMakeTranslation(-XS_SCREEN_WIDTH, 0); [UIView animateWithDuration:0.4 delay:i*(totalTime/cells.count) usingSpringWithDamping:0.7 initialSpringVelocity:1/0.7 options:UIViewAnimationOptionCurveEaseIn animations:^{ cell.transform = CGAffineTransformIdentity; } completion:^(BOOL finished) { }]; } } alpha动画 + (void)alphaAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i]; cell.alpha = 0.0; [UIView animateWithDuration:0.3 delay:i*0.05 options:0 animations:^{ cell.alpha = 1.0; } completion:^(BOOL finished) { }]; } } fall动画 + (void)fallAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; NSTimeInterval totalTime = 0.8; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i]; cell.transform = CGAffineTransformMakeTranslation(0, - XS_SCREEN_HEIGHT); [UIView animateWithDuration:0.3 delay:(cells.count - i)*(totalTime/cells.count) options:0 animations:^{ cell.transform = CGAffineTransformIdentity; } completion:^(BOOL finished) { }]; } } shake动画 + (void)shakeAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; if (i%2 == 0) { cell.transform = CGAffineTransformMakeTranslation(-XS_SCREEN_WIDTH,0); }else { cell.transform = CGAffineTransformMakeTranslation(XS_SCREEN_WIDTH,0); } [UIView animateWithDuration:0.4 delay:i*0.03 usingSpringWithDamping:0.75 initialSpringVelocity:1/0.75 options:0 animations:^{ cell.transform = CGAffineTransformIdentity; } completion:^(BOOL finished) { }]; } } overTurn动画 + (void)overTurnAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; cell.layer.opacity = 0.0; cell.layer.transform = CATransform3DMakeRotation(M_PI, 1, 0, 0); NSTimeInterval totalTime = 0.7; [UIView animateWithDuration:0.3 delay:i*(totalTime/cells.count) options:0 animations:^{ cell.layer.opacity = 1.0; cell.layer.transform = CATransform3DIdentity; } completion:^(BOOL finished) { }]; } } toTop动画 + (void)toTopAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; NSTimeInterval totalTime = 0.8; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i]; cell.transform = CGAffineTransformMakeTranslation(0, XS_SCREEN_HEIGHT); [UIView animateWithDuration:0.35 delay:i*(totalTime/cells.count) options:UIViewAnimationOptionCurveEaseOut animations:^{ cell.transform = CGAffineTransformIdentity; } completion:^(BOOL finished) { }]; } } spring动画 + (void)springListAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; cell.layer.opacity = 0.7; cell.layer.transform = CATransform3DMakeTranslation(0, -XS_SCREEN_HEIGHT, 20); NSTimeInterval totalTime = 1.0; [UIView animateWithDuration:0.4 delay:i*(totalTime/cells.count) usingSpringWithDamping:0.65 initialSpringVelocity:1/0.65 options:UIViewAnimationOptionCurveEaseIn animations:^{ cell.layer.opacity = 1.0; cell.layer.transform = CATransform3DMakeTranslation(0, 0, 20); } completion:^(BOOL finished) { }]; } } shrink动画 + (void)shrinkToTopAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; CGRect rect = [cell convertRect:cell.bounds fromView:tableView]; cell.transform = CGAffineTransformMakeTranslation(0, -rect.origin.y); [UIView animateWithDuration:0.5 animations:^{ cell.transform = CGAffineTransformIdentity; }]; } } laydown动画 + (void)layDownAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; NSMutableArray *rectArr = [[NSMutableArray alloc] init]; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; CGRect rect = cell.frame; [rectArr addObject:[NSValue valueWithCGRect:rect]]; rect.origin.y = i * 10; cell.frame = rect; cell.layer.transform = CATransform3DMakeTranslation(0, 0, i*5); } NSTimeInterval totalTime = 0.8; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; CGRect rect = [[rectArr objectAtIndex:i] CGRectValue]; [UIView animateWithDuration:(totalTime/cells.count) * i animations:^{ cell.frame = rect; } completion:^(BOOL finished) { cell.layer.transform = CATransform3DIdentity; }]; } } rote动画 + (void)roteAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"transform.rotation.y"]; animation.fromValue = @(-M_PI); animation.toValue = 0; animation.duration = 0.3; animation.removedOnCompletion = NO; animation.repeatCount = 3; animation.fillMode = kCAFillModeForwards; animation.autoreverses = NO; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; cell.alpha = 0.0; [UIView animateWithDuration:0.1 delay:i*0.25 options:0 animations:^{ cell.alpha = 1.0; } completion:^(BOOL finished) { [cell.layer addAnimation:animation forKey:@"rotationYkey"]; }]; } }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS-QRCodeImage]]]></title>
    <url>%2F2017%2F09%2F11%2FiOS-QRCodeImage%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 好几天没写博客了，正好在忙二维码的生成，扫描就里一个flag吧 原始二维码通过滤镜CIFilter生成二维码 创建过滤器 给过滤器添加数据 设置滤镜inputMessage数据 输出二维码 + (CIImage *)qrCodeImageWithContent:(NSString *)content{ CIFilter *qrFilter = [CIFilter filterWithName:@"CIQRCodeGenerator"]; NSData *contentData = [content dataUsingEncoding:NSUTF8StringEncoding]; [qrFilter setValue:contentData forKey:@"inputMessage"]; [qrFilter setValue:@"H" forKey:@"inputCorrectionLevel"]; CIImage *image = qrFilter.outputImage; return image; } void ProviderReleaseData (void *info, const void *data, size_t size){ free((void*)data); } 生成制定大小的二维码 传入原始二维码数据 设置倍数scale 通过bitmapImage放大并保存 + (UIImage *)qrCodeImageWithContent:(NSString *)content codeImageSize:(CGFloat)size{ CIImage *image = [self qrCodeImageWithContent:content]; CGRect integralRect = CGRectIntegral(image.extent); CGFloat scale = MIN(size/CGRectGetWidth(integralRect), size/CGRectGetHeight(integralRect)); size_t width = CGRectGetWidth(integralRect)*scale; size_t height = CGRectGetHeight(integralRect)*scale; CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceGray(); CGContextRef bitmapRef = CGBitmapContextCreate(nil, width, height, 8, 0, colorSpaceRef, (CGBitmapInfo)kCGImageAlphaNone); CIContext *context = [CIContext contextWithOptions:nil]; CGImageRef bitmapImage = [context createCGImage:image fromRect:integralRect]; CGContextSetInterpolationQuality(bitmapRef, kCGInterpolationNone); CGContextScaleCTM(bitmapRef, scale, scale); CGContextDrawImage(bitmapRef, integralRect, bitmapImage); CGImageRef scaledImage = CGBitmapContextCreateImage(bitmapRef); CGContextRelease(bitmapRef); CGImageRelease(bitmapImage); return [UIImage imageWithCGImage:scaledImage]; } 原始条形码通过滤镜CIFilter生成二维码 创建过滤器 给过滤器添加数据 设置滤镜inputMessage数据 输出二维码 + (CIImage *)barcodeImageWithContent:(NSString *)content{ CIFilter *qrFilter = [CIFilter filterWithName:@"CICode128BarcodeGenerator"]; NSData *contentData = [content dataUsingEncoding:NSUTF8StringEncoding]; [qrFilter setValue:contentData forKey:@"inputMessage"]; [qrFilter setValue:@(0.00) forKey:@"inputQuietSpace"]; CIImage *image = qrFilter.outputImage; return image; } void ProviderReleaseData (void *info, const void *data, size_t size){ free((void*)data); } 生成定制大小的条形码 传入原始二维码数据 设置倍数scale 通过bitmapImage放大并保存 + (UIImage *)barcodeImageWithContent:(NSString *)content codeImageSize:(CGSize)size{ CIImage *image = [self barcodeImageWithContent:content]; CGRect integralRect = CGRectIntegral(image.extent); CGFloat scale = MIN(size.width/CGRectGetWidth(integralRect), size.height/CGRectGetHeight(integralRect)); size_t width = CGRectGetWidth(integralRect)*scale; size_t height = CGRectGetHeight(integralRect)*scale; CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceGray(); CGContextRef bitmapRef = CGBitmapContextCreate(nil, width, height, 8, 0, colorSpaceRef, (CGBitmapInfo)kCGImageAlphaNone); CIContext *context = [CIContext contextWithOptions:nil]; CGImageRef bitmapImage = [context createCGImage:image fromRect:integralRect]; CGContextSetInterpolationQuality(bitmapRef, kCGInterpolationNone); CGContextScaleCTM(bitmapRef, scale, scale); CGContextDrawImage(bitmapRef, integralRect, bitmapImage); CGImageRef scaledImage = CGBitmapContextCreateImage(bitmapRef); CGContextRelease(bitmapRef); CGImageRelease(bitmapImage); return [UIImage imageWithCGImage:scaledImage]; } 彩色二维码获取原始二维码改变像素点颜色 @param content 二维码数据 @param size 二维码大小 @param red 0 ~ 1.0 @param green 0 ~ 1.0 @param blue 0 ~ 1.0 + (UIImage *)qrCodeImageWithContent:(NSString *)content codeImageSize:(CGFloat)size red:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue{ UIImage *image = [self qrCodeImageWithContent:content codeImageSize:size]; int imageWidth = image.size.width; int imageHeight = image.size.height; size_t bytesPerRow = imageWidth * 4; uint32_t *rgbImageBuf = (uint32_t *)malloc(bytesPerRow * imageHeight); CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB(); CGContextRef context = CGBitmapContextCreate(rgbImageBuf, imageWidth, imageHeight, 8, bytesPerRow, colorSpaceRef, kCGBitmapByteOrder32Little|kCGImageAlphaNoneSkipLast); CGContextDrawImage(context, CGRectMake(0, 0, imageWidth, imageHeight), image.CGImage); //遍历像素, 改变像素点颜色 int pixelNum = imageWidth * imageHeight; uint32_t *pCurPtr = rgbImageBuf; for (int i = 0; i< pixelNum; i++, pCurPtr++) { if ((*pCurPtr & 0xFFFFFF00) < 0x99999900) { uint8_t* ptr = (uint8_t*)pCurPtr; ptr[3] = red*255; ptr[2] = green*255; ptr[1] = blue*255; }else{ uint8_t* ptr = (uint8_t*)pCurPtr; ptr[0] = 0; } } //取出图片 CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, rgbImageBuf, bytesPerRow * imageHeight, ProviderReleaseData); CGImageRef imageRef = CGImageCreate(imageWidth, imageHeight, 8, 32, bytesPerRow, colorSpaceRef, kCGImageAlphaLast | kCGBitmapByteOrder32Little, dataProvider, NULL, true, kCGRenderingIntentDefault); CGDataProviderRelease(dataProvider); UIImage *resultImage = [UIImage imageWithCGImage:imageRef]; CGImageRelease(imageRef); CGContextRelease(context); CGColorSpaceRelease(colorSpaceRef); return resultImage; } 给二维码添加中心logo + (UIImage *)qrCodeImageWithContent:(NSString *)content codeImageSize:(CGFloat)size logo:(UIImage *)logo logoFrame:(CGRect)logoFrame red:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue{ UIImage * image = [self qrCodeImageWithContent:content codeImageSize:size red:red green:green blue:blue]; if (logo != nil) { UIGraphicsBeginImageContext(image.size); [image drawInRect:CGRectMake(0, 0, image.size.width, image.size.height)]; [logo drawInRect:logoFrame]; UIImage *resultImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return resultImage; }else{ return image; } } 彩色条形码获取原始二维码改变像素点颜色 @param content 二维码数据 @param size 二维码大小 @param red 0 ~ 1.0 @param green 0 ~ 1.0 @param blue 0 ~ 1.0 + (UIImage *)barcodeImageWithContent:(NSString *)content codeImageSize:(CGSize)size red:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue{ UIImage *image = [self barcodeImageWithContent:content codeImageSize:size]; int imageWidth = image.size.width; int imageHeight = image.size.height; size_t bytesPerRow = imageWidth * 4; uint32_t *rgbImageBuf = (uint32_t *)malloc(bytesPerRow * imageHeight); CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB(); CGContextRef context = CGBitmapContextCreate(rgbImageBuf, imageWidth, imageHeight, 8, bytesPerRow, colorSpaceRef, kCGBitmapByteOrder32Little|kCGImageAlphaNoneSkipLast); CGContextDrawImage(context, CGRectMake(0, 0, imageWidth, imageHeight), image.CGImage); //遍历像素, 改变像素点颜色 int pixelNum = imageWidth * imageHeight; uint32_t *pCurPtr = rgbImageBuf; for (int i = 0; i< pixelNum; i++, pCurPtr++) { if ((*pCurPtr & 0xFFFFFF00) < 0x99999900) { uint8_t* ptr = (uint8_t*)pCurPtr; ptr[3] = red*255; ptr[2] = green*255; ptr[1] = blue*255; }else{ uint8_t* ptr = (uint8_t*)pCurPtr; ptr[0] = 0; } } //取出图片 CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, rgbImageBuf, bytesPerRow * imageHeight, ProviderReleaseData); CGImageRef imageRef = CGImageCreate(imageWidth, imageHeight, 8, 32, bytesPerRow, colorSpaceRef, kCGImageAlphaLast | kCGBitmapByteOrder32Little, dataProvider, NULL, true, kCGRenderingIntentDefault); CGDataProviderRelease(dataProvider); UIImage *resultImage = [UIImage imageWithCGImage:imageRef]; CGImageRelease(imageRef); CGContextRelease(context); CGColorSpaceRelease(colorSpaceRef); return resultImage; } 渐变二维码绘制黑白二维码 - (UIImage *)genQRCodeImageMask:(UIImage *)image { if (image != nil) { int bitsPerComponent = 8; int bytesPerPixel = 4; int width = image.size.width; int height = image.size.height; unsigned char * imageData = (unsigned char *)malloc(width * height * bytesPerPixel); // 将原始黑白二维码图片绘制到像素格式为ARGB的图片上，绘制后的像素数据在imageData中。 CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGContextRef imageContext = CGBitmapContextCreate(imageData, width, height, bitsPerComponent, bytesPerPixel * width, colorSpace, kCGImageAlphaPremultipliedFirst); UIGraphicsPushContext(imageContext); CGContextTranslateCTM(imageContext, 0, height); CGContextScaleCTM(imageContext, 1, -1); [image drawInRect:CGRectMake(0, 0, width, height)]; CGColorSpaceRelease(colorSpace); // 根据每个像素R通道的值修改Alpha通道的值，当Red大于100，则将Alpha置为0，反之置为255 for (int row = 0; row < height; ++row) { for (int col = 0; col < width; ++col) { int offset = row * width * bytesPerPixel + col * bytesPerPixel; unsigned char r = imageData[offset + 1]; unsigned char alpha = r > 100 ? 0 : 255; imageData[offset] = alpha; } } CGImageRef cgMaskImage = CGBitmapContextCreateImage(imageContext); UIImage *maskImage = [UIImage imageWithCGImage:cgMaskImage]; CFRelease(cgMaskImage); UIGraphicsPopContext(); CFRelease(imageContext); free(imageData); return maskImage; } return nil; } 设置蒙层的颜色 - (CAGradientLayer *)gradientLayer { if (_gradientLayer == nil) { _gradientLayer = [CAGradientLayer new]; _gradientLayer.colors = @[ (__bridge id)[UIColor colorWithRed: 0x2a / 255.0 green:0x9c / 255.0 blue: 0x1f / 255.0 alpha:1.0].CGColor, (__bridge id)[UIColor colorWithRed: 0xe6 / 255.0 green:0xcd / 255.0 blue: 0x27 / 255.0 alpha:1.0].CGColor, (__bridge id)[UIColor colorWithRed: 0xe6 / 255.0 green:0x27 / 255.0 blue: 0x57 / 255.0 alpha:1.0].CGColor ]; [self.layer addSublayer: _gradientLayer]; _gradientLayer.frame = self.bounds; } return _gradientLayer; } 添加蒙层，设置黑白二维码图片 - (void)setQRCodeImage:(UIImage *)qrcodeImage { UIImage *maskImage = [self genQRCodeImageMask: qrcodeImage]; self.maskLayer.contents = (__bridge id)maskImage.CGImage; self.maskLayer.frame = self.bounds; self.gradientLayer.mask = self.maskLayer; }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS物理动画引擎_UIDynamic]]]></title>
    <url>%2F2017%2F09%2F05%2FiOS%E7%89%A9%E7%90%86%E5%8A%A8%E7%94%BB%E5%BC%95%E6%93%8E-UIDynamic%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks.Dome: github地址 iOS物理动画引擎-UIDynamic UIDynamicBehavior 仿真行为 创建一个仿真者,用来仿真所有的物理行为 animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view] 2. 创建具体的物理仿真行为 gravity = [[UIGravityBehavior alloc]init] collision = [[UICollisionBehavior alloc]init] snapBehavior = [[UISnapBehavior alloc] init] itemBehavior = [[UIDynamicItemBehavior alloc] init] 3. 将物理仿真行为添加给仿真者实现仿真效果。 -(void)addBehavior:(UIDynamicBehavior *)behavior; -(void)removeBehavior:(UIDynamicBehavior *)behavior; -(void)removeAllBehaviors; UIGravityBehavior 重力行为 创建仿真者 self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view]; 创建仿真行为 -(UIGravityBehavior *)gravity{ if (_gravity == nil) { _gravity = [[UIGravityBehavior alloc]init]; } return _gravity; } -(UICollisionBehavior *)collision{ if (_collision == nil) { _collision = [[UICollisionBehavior alloc]init]; } return _collision; } 触碰屏幕生成重力小球 -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ UITouch * touch = touches.anyObject; CGPoint location = [touch locationInView:self.view]; self.redView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, widthRed, widthRed)]; self.redView.center = location; [self.view addSubview:self.redView]; // 随机色方块 self.redView.backgroundColor = randomColor; // 创建重力的物理仿真行为，并设置具体的items(需要仿真的view) [self.gravity addItem:self.redView]; // 下落方向 // [gravity setAngle:0.5]; // 创建弹性的物理仿真行为，并设置具体的items(需要仿真的view) [self.collision addItem:self.redView]; self.collision.translatesReferenceBoundsIntoBoundary = YES; // 将重力仿真行为添加给仿真者实现仿真效果，开始仿真 [self.animator addBehavior:self.gravity]; [self.animator addBehavior:self.collision]; } UICollisionBehavior 碰撞行为 创建仿真者 self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view]; 创建碰撞对象 self.greenView = [[UIView alloc] initWithFrame:CGRectMake(100, 200, 100, 30)]; self.greenView.backgroundColor = [UIColor greenColor]; [self.view addSubview:self.greenView]; self.blueView = [[UIView alloc] initWithFrame:CGRectMake(120, 300, 100, 30)]; self.blueView.backgroundColor = [UIColor blueColor]; [self.view addSubview:self.blueView]; //未绑定仿真对象 self.blackView = [[UIView alloc] initWithFrame:CGRectMake(140, 400, 100, 30)]; self.blackView.backgroundColor = [UIColor blackColor]; [self.view addSubview:self.blackView]; // 物体角度 self.blueView.transform = CGAffineTransformMakeRotation(M_PI_4); self.greenView.transform = CGAffineTransformMakeRotation(-M_PI / 8); 创建仿真行为 -(UIGravityBehavior *)gravity{ if (_gravity == nil) { _gravity = [[UIGravityBehavior alloc]init]; } return _gravity; } -(UICollisionBehavior *)collision{ if (_collision == nil) { _collision = [[UICollisionBehavior alloc]init]; } return _collision; } 开始碰撞行为 -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ // 获取点击位置，生成仿真者 UITouch * touch = touches.anyObject; CGPoint location = [touch locationInView:self.view]; self.redView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, widthRed, widthRed)]; self.redView.center = location; // pch中宏定义的随机色 self.redView.backgroundColor = randomColor; [self.view addSubview:self.redView]; [self.gravity addItem:self.redView]; // 添加碰撞检测 [self.collision addItem:self.redView]; [self.collision addItem:self.greenView]; [self.collision addItem:self.blueView]; self.collision.translatesReferenceBoundsIntoBoundary = YES; self.collision.collisionDelegate = self; __weak typeof(self) weakSelf = self; // 获取方块运动轨迹坐标 self.collision.action = ^{ NSLog(@"%@", NSStringFromCGRect(weakSelf.redView.frame)); }; CGFloat Y = self.view.frame.size.height; CGFloat X = self.view.frame.size.width; CGFloat height = self.view.frame.size.height; //设置红色的View为底边界,左边框跟右边框作为边界 [self.collision addBoundaryWithIdentifier:@"collision1" fromPoint:CGPointMake(0,Y) toPoint:CGPointMake(X, Y)]; [self.collision addBoundaryWithIdentifier:@"collision2" fromPoint:CGPointMake(0, 0) toPoint:CGPointMake(0, height)]; [self.collision addBoundaryWithIdentifier:@"collision3" fromPoint:CGPointMake(X,0) toPoint:CGPointMake(X, height)]; [self.animator addBehavior:self.collision]; [self.animator addBehavior:self.gravity]; } 碰撞开始时给被碰撞的物体添加重力仿真 // UICollisionBehavior 代理行为 - (void)collisionBehavior:(UICollisionBehavior*)behavior beganContactForItem:(id )item withBoundaryIdentifier:(nullable id )identifier atPoint:(CGPoint)p{ if ([item isEqual:self.greenView]) { UIGravityBehavior * gravity = [[UIGravityBehavior alloc] initWithItems:@[self.greenView]]; [self.animator addBehavior:gravity]; }else if ([item isEqual:self.blueView]){ UIGravityBehavior * gravity = [[UIGravityBehavior alloc] initWithItems:@[self.blueView]]; [self.animator addBehavior:gravity]; } } UISnapBehavior 吸附行为 创建仿真者 self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view]; 创建吸附对象 -(UIView *)redView{ if (_redView ==nil) { _redView = [[UIView alloc]initWithFrame:CGRectMake(p.x, p.y, 50, 50)]; _redView.backgroundColor = [UIColor redColor]; [self.view addSubview:_redView]; } return _redView; } 开始吸附行为 -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ [self.animator removeAllBehaviors]; UITouch * touch = touches.anyObject; CGPoint location = [touch locationInView:self.view]; p = location; NSLog(@"%@",NSStringFromCGPoint(location)); // 3 添加吸附事件 UISnapBehavior *snap = [[UISnapBehavior alloc] initWithItem:self.redView snapToPoint:location]; // 改变震动幅度，0表示振幅最大，1振幅最小 snap.damping = 0.5; // 4. 将吸附事件添加到仿真者行为中 [self.animator addBehavior:snap]; } UIDynamicItemBehavior 迅猛移动弹跳摆动行为 创建仿真者 self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view]; 创建仿真行为 -(UIGravityBehavior *)gravity{ if (_gravity == nil) { _gravity = [[UIGravityBehavior alloc]init]; } return _gravity; } -(UICollisionBehavior *)collision{ if (_collision == nil) { _collision = [[UICollisionBehavior alloc]init]; [_collision addBoundaryWithIdentifier:@"barrier" forPath:[UIBezierPath bezierPathWithRect:self.view.bounds]]; _collision.translatesReferenceBoundsIntoBoundary = YES; } return _collision; } -(UIDynamicItemBehavior *)itemBehavior{ if (_itemBehavior == nil) { _itemBehavior = [[UIDynamicItemBehavior alloc] init]; _itemBehavior.elasticity = 1; } return _itemBehavior; } 生成小球，添加仿真事件 -(void)touchesAddSquareView{ float viewWidth = 20; UIView * view = [[UIView alloc]initWithFrame:CGRectMake(p.x, p.y, viewWidth, viewWidth)]; view.layer.cornerRadius = viewWidth / 2.0; view.backgroundColor = randomColor; [self performSelector:@selector(removeView:) withObject:view afterDelay:10]; [self.view addSubview:view]; [self.collision addItem:view]; [self.itemBehavior addItem:view]; [self.gravity addItem:view]; [self.animator addBehavior:self.collision]; [self.animator addBehavior:self.itemBehavior]; [self.animator addBehavior:self.gravity]; } 点触，移动和松开创建小球 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { UITouch * touch = touches.anyObject; CGPoint location = [touch locationInView:self.view]; p = location; [self touchesAddSquareView]; } - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event { UITouch * touch = touches.anyObject; CGPoint location = [touch locationInView:self.view]; p = location; [self touchesAddSquareView]; } - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event { [self touchesAddSquareView]; } 10s后删除小球和其物理仿真行为 -(void)removeView:(UIView *)view{ if (view == nil) { return; } [UIView animateWithDuration:.5 animations:^{ view.alpha = 0; } completion:^(BOOL finished) { [view removeFromSuperview]; [self.collision removeItem:view]; [self.itemBehavior removeItem:view]; [self.gravity removeItem:view]; }]; }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift_popAnimation实例]]]></title>
    <url>%2F2017%2F08%2F28%2FSwift-popAnimation%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 情人节在写博客也是蛮拼的 Pod pop 如 [Swift_popAnimation初级] 动画思路 三条杠变叉：中间杠的消失和两边杠的偏移。 叉变三条杠：两边杠的偏移和中间杠的出现。 三条杠用三个view来代替，添加在一个button上。声明全局属性 var hamburger = true var hamburgerButton : UIButton? var top:UIView? var middle:UIView? var bottom:UIView? 实例化对象 self.hamburgerButton = UIButton() self.hamburgerButton?.backgroundColor = UIColor.black self.hamburgerButton?.frame = CGRect(x: 100, y: 200, width: 150, height: 150) self.hamburgerButton?.layer.cornerRadius = 75 self.view.addSubview(hamburgerButton!) self.hamburgerButton?.addTarget(self, action:#selector(didTapHamburgerButton), for: UIControlEvents.touchUpInside) //三道杠 let sectionWidth:CGFloat = 80.0 let sectionHeight:CGFloat = 11.0 //top top = UIView(frame: CGRect(x: (self.hamburgerButton?.bounds.size.width)! / 2 - sectionWidth / 2, y: 40, width: sectionWidth, height: sectionHeight)) top?.backgroundColor = UIColor.white top?.isUserInteractionEnabled = false top?.layer.cornerRadius = sectionHeight / 2 self.hamburgerButton?.addSubview(top!) //middle middle = UIView(frame: CGRect(x: (self.hamburgerButton?.bounds.size.width)! / 2 - sectionWidth / 2, y: 69, width: sectionWidth, height: sectionHeight)) middle?.backgroundColor = UIColor.white middle?.isUserInteractionEnabled = false middle?.layer.cornerRadius = sectionHeight / 2 self.hamburgerButton?.addSubview(middle!) //bottom bottom = UIView(frame: CGRect(x: (self.hamburgerButton?.bounds.size.width)! / 2 - sectionWidth / 2, y: 99, width: sectionWidth, height: sectionHeight)) bottom?.backgroundColor = UIColor.white bottom?.isUserInteractionEnabled = false bottom?.layer.cornerRadius = sectionHeight / 2 self.hamburgerButton?.addSubview(bottom!) pop对象复用 颜色动画： var topColor = self.top?.pop_animation(forKey: "topColor") as! POPSpringAnimation? var bottomColor = self.top?.pop_animation(forKey: "bottomColor") as! POPSpringAnimation? 旋转动画： var topRotate = self.top?.layer.pop_animation(forKey: "topRotate") as! POPSpringAnimation? var bottomRotate = self.top?.layer.pop_animation(forKey: "bottomRotate") as! POPSpringAnimation? 位置动画： var topPosition = self.top?.layer.pop_animation(forKey: "topPosition")as!POPSpringAnimation? var bottomPosition = self.top?.layer.pop_animation(forKey: "bottomPosition")as!POPSpringAnimation? 三道杠变红叉叉 hamburger = false UIView.animate(withDuration: 0.2, animations: { self.middle?.alpha = 0 }) //变色 if topColor != nil { topColor?.toValue = UIColor.red }else{ topColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor) topColor?.toValue = UIColor.red topColor?.springBounciness = 0 topColor?.springSpeed = 18 top?.pop_add(topColor, forKey: "topColor") } if bottomColor != nil { bottomColor?.toValue = UIColor.red }else{ bottomColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor) bottomColor?.toValue = UIColor.red bottomColor?.springBounciness = 0 bottomColor?.springSpeed = 18 bottom?.pop_add(topColor, forKey: "bottomColor") } //旋转 if topRotate != nil { topRotate?.toValue = -Double.pi / 4 }else{ topRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation) topRotate?.toValue = -Double.pi / 4 topRotate?.springBounciness = 11 topRotate?.springSpeed = 18 top?.layer.pop_add(topRotate, forKey: "topRotate") } if bottomRotate != nil { bottomRotate?.toValue = Double.pi / 4 }else{ bottomRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation) bottomRotate?.toValue = Double.pi / 4 bottomRotate?.springBounciness = 11 bottomRotate?.springSpeed = 18 bottom?.layer.pop_add(bottomRotate, forKey: "bottomRotate") } //移动 if topPosition != nil { topPosition?.toValue = 29 }else{ topPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY) topPosition?.toValue = 29 topPosition?.springBounciness = 11 topPosition?.springSpeed = 18 top?.layer.pop_add(topPosition, forKey: "topPosition") } if bottomPosition != nil { bottomPosition?.toValue = -29 }else{ bottomPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY) bottomPosition?.toValue = -29 bottomPosition?.springBounciness = 11 bottomPosition?.springSpeed = 18 bottom?.layer.pop_add(bottomPosition, forKey: "bottomPosition") } } 红叉叉变三道杠:逆向-&gt;就还原一起改变值 hamburger = true UIView.animate(withDuration: 0.2, animations: { self.middle?.alpha = 1 }) //变色 if topColor != nil { topColor?.toValue = UIColor.white }else{ topColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor) topColor?.toValue = UIColor.white topColor?.springBounciness = 0 topColor?.springSpeed = 18 top?.pop_add(topColor, forKey: "topColor") } if bottomColor != nil { bottomColor?.toValue = UIColor.white }else{ bottomColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor) bottomColor?.toValue = UIColor.white bottomColor?.springBounciness = 0 bottomColor?.springSpeed = 18 bottom?.pop_add(topColor, forKey: "bottomColor") } //旋转 if topRotate != nil { topRotate?.toValue = 0 }else{ topRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation) topRotate?.toValue = 0 topRotate?.springBounciness = 11 topRotate?.springSpeed = 18 top?.layer.pop_add(topRotate, forKey: "topRotate") } if bottomRotate != nil { bottomRotate?.toValue = 0 }else{ bottomRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation) bottomRotate?.toValue = 0 bottomRotate?.springBounciness = 11 bottomRotate?.springSpeed = 18 bottom?.layer.pop_add(bottomRotate, forKey: "bottomRotate") } //移动 if topPosition != nil { topPosition?.toValue = 0 }else{ topPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY) topPosition?.toValue = 0 topPosition?.springBounciness = 11 topPosition?.springSpeed = 18 top?.layer.pop_add(topPosition, forKey: "topPosition") } if bottomPosition != nil { bottomPosition?.toValue = 0 }else{ bottomPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY) bottomPosition?.toValue = 0 bottomPosition?.springBounciness = 11 bottomPosition?.springSpeed = 18 bottom?.layer.pop_add(bottomPosition, forKey: "bottomPosition") } } } so easy]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift_popAnimation应用]]]></title>
    <url>%2F2017%2F08%2F25%2FSwift-popAnimation%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 Pod pop如上篇文章 创建UIbutton类对象与storyboard绑定 应用touchesBegan ，touchesEnded 开始点击 缩小0.5倍 旋转半圈 //缩放动画 var scale = self.pop_animation(forKey: TLscale)as?POPSpringAnimation if scale != nil { scale?.toValue = NSValue(cgPoint:CGPoint(x: 0.5, y: 0.5)) }else{ scale = POPSpringAnimation(propertyNamed: kPOPViewScaleXY) scale?.toValue = NSValue(cgPoint:CGPoint(x: 0.5, y: 0.5)) scale?.springBounciness = 20 scale?.springSpeed = 5 self.pop_add(scale, forKey: TLscale) } //旋转动画 var rotate = self.layer.pop_animation(forKey: TLrotate)as? POPSpringAnimation if rotate != nil { rotate?.toValue = Double.pi / 2 }else{ rotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation) rotate?.toValue = Double.pi / 2 rotate?.springBounciness = 20 rotate?.springSpeed = 18 self.layer.pop_add(rotate, forKey: TLrotate) } 结束点击 缩放1.0倍回到起始状态 旋转到起始位置 //缩放动画 var scale = self.pop_animation(forKey: TLscale)as?POPSpringAnimation if scale != nil { scale?.toValue = NSValue(cgPoint:CGPoint(x: 1, y: 1)) }else{ scale = POPSpringAnimation(propertyNamed: kPOPViewScaleXY) scale?.toValue = NSValue(cgPoint:CGPoint(x: 1, y: 1)) scale?.springBounciness = 20 scale?.springSpeed = 5 self.pop_add(scale, forKey: TLscale) } //旋转动画 var rotate = self.layer.pop_animation(forKey: TLrotate)as? POPSpringAnimation if rotate != nil { rotate?.toValue = 0 }else{ rotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation) rotate?.toValue = 0 rotate?.springBounciness = 20 rotate?.springSpeed = 18 self.layer.pop_add(rotate, forKey: TLrotate)]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift_popAnimation初级]]]></title>
    <url>%2F2017%2F08%2F25%2FpopAnimation%E5%88%9D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 先初尝popAnimation一些环境配置和方法调用，下篇会写实例应用 Pods pop vim podfile platform :ios,'8.0' target "RedBall" do pod 'pop' end pod install 动画 宏定义 let TLspin = "spin" let TLmove = "move" let TLcolor = "color" let TLscale = "scale" 属性定义 let redBall = UIView(frame: CGRect(x: 100, y: 200, width: 100, height: 100)) let scale = POPSpringAnimation(propertyNamed:kPOPViewScaleXY) let move = POPSpringAnimation(propertyNamed: kPOPLayerPositionY) let spin = POPSpringAnimation(propertyNamed: kPOPLayerRotation) let color = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor) segmentContol创建 let array = [&quot;放大&quot;,&quot;旋转&quot;,&quot;移动&quot;,&quot;变色&quot;,&quot;归位&quot;] let segmentedControl = UISegmentedControl.init(items:array) segmentedControl.frame = CGRect(x:50,y:50,width:self.view.frame.size.width-100 ,height:30) segmentedControl.tintColor = UIColor.green segmentedControl.backgroundColor = UIColor.red segmentedControl.addTarget(self, action:#selector(segmentedControlChanged(segmented:)), for: UIControlEvents.valueChanged) self.view .addSubview(segmentedControl); 动画代码 pop放大，旋转，移动，变色，还原动画 springBounciness: 弹性振幅，范围0-20 springSpeed: 震动速度 pop_add: 加载动画 func redBallScale() { // 放大动画 scale?.toValue = NSValue(cgPoint:CGPoint(x: 2, y: 2)) scale?.springBounciness = 20 scale?.springSpeed = 1 redBall.pop_add(scale, forKey: TLscale) } func redBallSpin() { //旋转动画 spin?.toValue = Double.pi * 4 spin?.springBounciness = 20 spin?.springSpeed = 5 redBall.layer.pop_add(spin, forKey: TLspin) } func redBallMove() { //y坐标位移动画 move?.toValue = 500 move?.springBounciness = 20 move?.springSpeed = 5 redBall.layer.pop_add(move, forKey: TLmove) } func redBallColor() { //背景颜色变化 color?.toValue = UIColor.green color?.springBounciness = 20 color?.springSpeed = 5 redBall.pop_add(color, forKey: TLcolor) }]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS-绑定Amazon]]]></title>
    <url>%2F2017%2F08%2F23%2FiOS-%E7%BB%91%E5%AE%9AAmazon%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 为实现echo语音控制只能家居，所以需要绑定亚马逊账号 Install the Login with Amazon SDK for iOS 下载亚马逊SDK LoginWithAmazonSDKForiOS.zip 工程中拖入SDK LoginWithAmazon.framework Target - BuildPhases - Link Binary With Libraries中添加framework Register with Login with Amazon注册亚马逊账号亚马逊注册 登录亚马逊账号亚马逊登录 输入App的名称，链接和App图标等 注册地址 App Console.前提是你有亚马逊账号 Add iOS Settings to an Application 亚马逊 App应用界面，点击iOS设置，如果你的iOS App已经注册好，点击 API Key 需要输入你的Bundle ID,target - General Add Your API Key to Your App Property List 选择 project - Info.plist 添加APIKey ，选择copy，别出错 Add a URL Scheme to Your App Property List 选择 project - Info.plist 添加URL types Item 0 Document Role 填写Editor。 Shames 填写 prefs Item 1 identifier 填写bundle ID。 Shames 填写amzn-bundle ID 其他填写如下图 Using the SDK for iOS APIs创建亚马逊类，导入 #import&lt; LoginWithAmazon/LoginWithAmazon.h&gt; Using the SDK for iOS APIs 在 AppDelegate 导入import &lt; LoginWithAmazon/LoginWithAmazon.h&gt;. 添加以下方法,返回亚马逊URL - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation { #pragma unused(application,annotation) // Pass on the url to the SDK to parse authorization code from the url. BOOL isValidRedirectLogInURL = [AMZNAuthorizationManager handleOpenURL:url sourceApplication:(NSString *)sourceApplication]; if(!isValidRedirectLogInURL){ return NO; } // App may also want to handle url return YES; } Handle the Login Button and Get Profile Data 发出登录请求 userID ，profile，postalCode successful 成功登录返回数据result.token，result.user，user.userID error 回复错误 userDidCancel 用户自动取消 - (IBAction)onLogInButtonClicked:(id)sender { // Build an authorize request. AMZNAuthorizeRequest *request = [[AMZNAuthorizeRequest alloc] init]; request.scopes = [NSArray arrayWithObjects: [AMZNProfileScope userID], [AMZNProfileScope profile], [AMZNProfileScope postalCode]]; // Make an Authorize call to the Login with Amazon SDK. [[AMZNAuthorizationManager sharedManager] authorize:request withHandler:^(AMZNAuthorizeResult *result, BOOL userDidCancel, NSError *error) { if (error) { // Handle errors from the SDK or authorization server. } else if (userDidCancel) { // Handle errors caused when user cancels login. } else { // Authentication was successful. // Obtain the access token and user profile data. NSString *accessToken = result.token; AMZNUser *user = result.user; NSString *userID = user.userID; } }]; } Fetch User Profile Data 获取登录信息 user.userID，user.name，user.email，user.postalCode 在error时可以添加重新登录方法 AMZNUser fetch:^(AMZNUser *user, NSError *error) { if (error) { // Error from the SDK, or no user has authorized to the app. } else if (user) { NSString *userID = user.userID; //NSString *name = user.name; //NSString *email = user.email; //NSString *postalCode = user.postalCode; } }]; Check for User Login at Startup // Build an authorize request. AMZNAuthorizeRequest *request = [[AMZNAuthorizeRequest alloc] init]; request.scopes = [NSArray arrayWithObjects: // [AMZNProfileScope userID], [AMZNProfileScope profile], [AMZNProfileScope postalCode]]; request.interactiveStrategy = AMZNInteractiveStrategyNever; [[AMZNAuthorizationManager sharedManager] authorize:request withHandler:^(AMZNAuthorizeResult *result, BOOL userDidCancel, NSError *error) { if (error) { // Error from the SDK, indicating the user was not previously authorized to your app for the requested scopes. } else { // The user was previously authorized to your app. // Obtain the access token and user profile data. NSString *accessToken = result.token; AMZNUser *user = result.user; NSString *userID = user.userID; } }]; Clear Authorization Data and Log Out a User 退出登录 清除亚马逊数据 [[AMZNAuthorizationManager sharedManager] signOut:^(NSError * _Nullable error) { if (!error) { // error from the SDK or Login with Amazon authorization server. } }]; 注：亚马逊账号绑定在本地存储，所以多手机登录需要存储userID到自己服务器，实现多手机登录状态回显]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS-OpenGL图形绘制二]]]></title>
    <url>%2F2017%2F08%2F23%2FiOS-OpenGL%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks.Dome: github地址 本章讲如何用原生OpenGL绘制图形及渲染图片 环境搭建 创建一个新的工程，点击target-&gt;Build Phases -&gt; Link Binary With Libraries添加库 GLKit.framework OpenGLES.framework 导入头文件: #import &lt; OpenGLES/ES2/gl.h &gt; #import &lt; OpenGLES/ES2/glext.h &gt; 三角形宏定义一个三角线 const GLfloat Trianglevertices[] = { 0.0f, 0.5f, 0.0f, -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f }; const GLubyte Triangleindices[] = { 0,1,2 }; VBO申请空间并绑定目标-(void)OneRenderVerticesAnColorsForTriangles{ GLuint vertexBuffer; glGenBuffers(1, &amp;vertexBuffer); // 绑定vertexBuffer到GL_ARRAY_BUFFER目标 glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer); // 为VBO申请空间，初始化并传递数据 glBufferData(GL_ARRAY_BUFFER, sizeof(Trianglevertices), Trianglevertices, GL_STATIC_DRAW); GLuint indexBuffer; glGenBuffers(1, &amp;indexBuffer); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Triangleindices), Triangleindices, GL_STATIC_DRAW); // 使用VBO时，最后一个参数0为要获取参数在GL_ARRAY_BUFFER中的偏移量 glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(_positionSlot); glDrawElements(GL_TRIANGLES, sizeof(Triangleindices)/sizeof(Triangleindices[0]), GL_UNSIGNED_BYTE, 0); } 四边形宏定义定义一个Vertex结构, 其中包含了坐标和颜色 typedef struct { float Position[3]; float Color[4]; } Vertex; 顶点数组 const Vertex Vertices[] = { {{-1,-1,0}, {0,0,0,1}},// 左下，黑色 {{1,-1,0}, {1,0,0,1}}, // 右下，红色 {{-1,1,0}, {0,0,1,1}}, // 左上，蓝色 {{1,1,0}, {0,1,0,1}}, // 右上，绿色 }; 索引数组 const GLubyte Indices[] = { 0,1,2, // 三角形0 1,2,3 // 三角形1 }; VBO申请空间并绑定目标 取出Vertices数组中的坐标点值，赋给_positionSlot 取出Colors数组中的每个坐标点的颜色值，赋给_colorSlot 绘制两个三角形，不复用顶点，因此需要6个顶点坐标。 V0-V1-V2, V3-V4-V5 通用部分定义属性EAGLContext * _context; CAEAGLLayer * _EALayer; GLuint _colorBufferRender; // 渲染缓冲区 GLuint _frameBuffer; // 帧缓冲区 GLuint _positionSlot; // 用于绑定shader中的Position参数 GLuint _colorSlot; // 用于绑定shader中的SourceColor参数 GLuint _glProgram; 颜色和离屏渲染 生成一个renderBuffer，id是_colorRenderBuffer 设置为当前renderBuffer 为color renderbuffer 分配存储空间 FBO用于管理colorRenderBuffer，离屏渲染 设置为当前framebuffer 将 _colorRenderBuffer 装配到 GL_COLOR_ATTACHMENT0 这个装配点上 -(void)setColorAndFrameBufferRender{ if (_colorBufferRender) { glDeleteRenderbuffers(1, &amp;_colorBufferRender); _colorBufferRender = 0; } if (_frameBuffer) { glDeleteFramebuffers(1, &amp;_frameBuffer); _frameBuffer = 0; } glGenRenderbuffers(1, &amp;_colorBufferRender); glBindRenderbuffer(GL_RENDERBUFFER, _colorBufferRender); [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:_EALayer]; glGenFramebuffers(1, &amp;_frameBuffer); glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer); glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _colorBufferRender); } 创建绘制对象 setup context, 渲染上下文，管理所有绘制的状态，命令及资源信息。 setup layer, 必须要是CAEAGLLayer才行，才能在其上描绘OpenGL内容 如果在viewController中，使用[self.view.layer addSublayer:eaglLayer]; 如果在view中，可以直接重写UIView的layerClass类方法即可return [CAEAGLLayer class]。 - (void)setContentViewAndCAEGLayer{ _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2]; [EAGLContext setCurrentContext:_context]; _EALayer = (CAEAGLLayer*)self.view.layer; _EALayer.frame = self.view.frame; _EALayer.opaque = YES; _EALayer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithBool:YES],kEAGLDrawablePropertyRetainedBacking,kEAGLColorFormatRGBA8,kEAGLDrawablePropertyColorFormat, nil]; } 设置清屏 设置清屏颜色 用来指定要用清屏颜色来清除由mask指定的buffer，此处是color buffer 将指定renderBuffer渲染在屏幕上 -(void)glClear{ glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); glViewport(0, 0, self.view.frame.size.width , self.view.frame.size.height); } 离屏渲染显示绘制图片创建glsl文件：建一个empty文件，修改后缀即可三角形Fragment precision mediump float; void main(void) { gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); } 三角形Vertex attribute vec4 Position; void main(void) { gl_Position = Position; } 四边形Fragment varying lowp vec4 DestinationColor; void main(void) { gl_FragColor = DestinationColor; } 四边形Vertex attribute vec4 Position; attribute vec4 SourceColor; varying vec4 DestinationColor; void main(void) { DestinationColor = SourceColor; gl_Position = Position; } 创建一个分类继承NSObject实现以下两个类方法 + (GLuint)compileShader:(NSString*)shaderName withType:(GLenum)shaderType; + (GLuint)compileShaders:(NSString *)shaderVertex shaderFragment:(NSString *)shaderFragment; Shader四边形Shaders - (void)processShaders { _glProgram = [TLShaderOperation compileShaders:@&quot;Vertex&quot; shaderFragment:@&quot;Fragment&quot;]; glUseProgram(_glProgram); _positionSlot = glGetAttribLocation(_glProgram, &quot;Position&quot;); _colorSlot = glGetAttribLocation(_glProgram, &quot;SourceColor&quot;); } 三角形Shaders - (void)processTriangleShaders { // 编译shaders _glProgram = [TLShaderOperation compileShaders:@&quot;TriangleVertex&quot; shaderFragment:@&quot;TriangleFragment&quot;]; glUseProgram(_glProgram); // 获取指向vertex shader传入变量的指针, 然后就通过该指针来使用 // 即将_positionSlot 与 shader中的Position参数绑定起来 glGetAttribLocation(_glProgram, &quot;Position&quot;); } 获取图片 unbind the shader 从FBO中读取图像数据，离屏渲染。 图像经过render之后，已经在FBO中了，即使不将其拿到RenderBuffer中，依然可以使用getResultImage取到图像数据。 用[_eaglContext presentRenderbuffer:GL_RENDERBUFFER];，实际上就是将FBO中的图像拿到RenderBuffer中（即屏幕上） - (UIImage *)getResultImage { CGSize currentFBOSize = self.view.frame.size; NSUInteger totalBytesForImage = (int)currentFBOSize.width * (int)currentFBOSize.height * 4; GLubyte *_rawImagePixelsTemp = (GLubyte *)malloc(totalBytesForImage); glReadPixels(0, 0, (int)currentFBOSize.width, (int)currentFBOSize.height, GL_RGBA, GL_UNSIGNED_BYTE, _rawImagePixelsTemp); glUseProgram(0); glBindFramebuffer(GL_FRAMEBUFFER, 0); CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, _rawImagePixelsTemp, totalBytesForImage, (CGDataProviderReleaseDataCallback)&freeData); CGColorSpaceRef defaultRGBColorSpace = CGColorSpaceCreateDeviceRGB(); CGImageRef cgImageFromBytes = CGImageCreate((int)currentFBOSize.width, (int)currentFBOSize.height, 8, 32, 4 * (int)currentFBOSize.width, defaultRGBColorSpace, kCGBitmapByteOrderDefault, dataProvider, NULL, NO, kCGRenderingIntentDefault); UIImage *finalImage = [UIImage imageWithCGImage:cgImageFromBytes scale:1.0 orientation:UIImageOrientationDownMirrored]; CGImageRelease(cgImageFromBytes); CGDataProviderRelease(dataProvider); CGColorSpaceRelease(defaultRGBColorSpace); return finalImage; } void freeData(void *info, const void *data, size_t size) { free((unsigned char *)data); } 用于显示图片UIImage *image = [self getResultImage]; if (image) { UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)]; imageView.backgroundColor = [UIColor whiteColor]; imageView.contentMode = UIViewContentModeScaleAspectFit; imageView.image = image; [self.view addSubview:imageView]; }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS_OpenGL环境搭建和图形绘制]]]></title>
    <url>%2F2017%2F08%2F22%2FiOS-OpenGL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks.Dome: github地址 个人觉得OpenGl图形绘制很酷所以专研了一段时间，记录供以后自己使用和小白学习。 环境搭建 创建一个新的工程，点击target-&gt;Build Phases -&gt; Link Binary With Libraries添加库 GLKit.framework OpenGLES.framework 导入 #import 头文件 因为我用GLKBaseEffect绘制的，所以不需要导入更多的头文件 顶点输入一个顶点数组对象会储存以下这些内容： glEnableVertexAttribArray和glDisableVertexAttribArray的调用。 通过glVertexAttribPointer设置的顶点属性配置。 通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。 三角形 float vertices[] = { -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f }; 多边形 typedef struct { GLfloat Positon[3];//位置 GLfloat Color[4];//颜色 } Vertex; 顶点和颜色数组 const Vertex squareVertexData[] = { { 0.5f, 0.5f, -0.9f, 1.0f, 0.0f, 0.0f, 1.0f}, //0 {-0.5f, 0.5f, -0.9f, 0.0f, 1.0f, 0.0f, 1.0f}, //1 { 0.5f, -0.5f, -0.9f, 0.0f, 0.0f, 1.0f, 1.0f}, //2 {-0.5f, -0.5f, -0.9f, 0.0f, 0.0f, 0.0f, 1.0f} //3 }; 三角形数组 const GLubyte Indices[] = { 0, 1, 2, 2, 1, 3 }; 顶点数组对象：Vertex Array Object，VBO 使用glGenBuffers函数和一个缓冲ID生成一个VBO对象：unsigned int VBO;glGenBuffers(1, &amp;VBO); glBindBuffer函数把新创建的缓冲绑定到GL_ARRAY_BUFFER目标上：glBindBuffer(GL_ARRAY_BUFFER, VBO); 我们可以调用glBufferData函数，它会把之前定义的顶点数据复制到缓冲的内存中：glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);glBufferData： 它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上 第二个参数指定传输数据的大小(以字节为单位)；用一个简单的sizeof计算出顶点数据大小就行 第三个参数是我们希望发送的实际数据。 第四个参数指定了我们希望显卡如何管理给定的数据 GL_STATIC_DRAW ：数据不会或几乎不会改变。 GL_DYNAMIC_DRAW：数据会被改变很多。 GL_STREAM_DRAW ：数据每次绘制时都会改变。 现在我们已经把顶点数据储存在显卡的内存中，用VBO这个顶点缓冲对象管理 创建一个VAO和创建一个VBO很类似：unsigned int VAO;glGenVertexArrays(1, &amp;VAO); 要想使用VAO，要做的只是使用glBindVertexArray绑定VAO 绑定VAOglBindVertexArray(VAO); 把顶点数组复制到缓冲中供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); 设置顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 sizeof(float), (void)0);glEnableVertexAttribArray(0); 三角形 GL_ARRAY_BUFFER用于顶点数组 绑定vertexBuffer到GL_ARRAY_BUFFER 给VBO传递数据 取出地址 取出颜色 glVertexAttribPointer的最后一个参数是要获取的参数在GL_ARRAY_BUFFER（每一个Vertex）的偏移量 - (void)setupVBOs{ GLuint verticesBuffer; glGenBuffers(1, &verticesBuffer); glBindBuffer(GL_ARRAY_BUFFER, verticesBuffer); glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW); glEnableVertexAttribArray(GLKVertexAttribPosition); glEnableVertexAttribArray(GLKVertexAttribColor); glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 6, (GLfloat *)NULL + 0); glVertexAttribPointer(GLKVertexAttribColor, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 6, (GLfloat *)NULL + 3); } 多边形 申请一个标识符 把标识符绑定到GL_ARRAY_BUFFER上 把顶点数据从cpu内存复制到gpu内存 开启对应的顶点属性 设置合适的格式从buffer里面读取数据 - (void)setupVBOs{ GLuint buffer; glGenBuffers(1, &buffer); glBindBuffer(GL_ARRAY_BUFFER, buffer); glBufferData(GL_ARRAY_BUFFER, sizeof(squareVertexData), squareVertexData, GL_STATIC_DRAW); GLuint elementBuffer; glGenBuffers(1, &elementBuffer); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBuffer); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW); glEnableVertexAttribArray(GLKVertexAttribPosition); glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), 0); glEnableVertexAttribArray(GLKVertexAttribNormal); glVertexAttribPointer(GLKVertexAttribNormal, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid *) (sizeof(GLfloat) * 3)); glEnableVertexAttribArray(GLKVertexAttribColor); glVertexAttribPointer(GLKVertexAttribColor, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid *) (sizeof(GLfloat) * 6)); glEnableVertexAttribArray(GLKVertexAttribTexCoord0); glVertexAttribPointer(GLKVertexAttribTexCoord0, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid *) (sizeof(GLfloat) * 10)); } GLKViewDelegate 启动着色器 添加背景颜色 绘制图形 -(void)glkView:(GLKView *)view drawInRect:(CGRect)rect { [TLEffect prepareToDraw]; glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glDrawArrays(GL_TRIANGLES, 0, 3); } 在GLKView上绘制OpenGL内容 - (void)setupContext{ context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2]; if (!context) { NSLog(@"Failed to initialize OpenGLES 2.0 context"); exit(1); } [EAGLContext setCurrentContext:context]; GLKView *view = [[GLKView alloc]init]; view.delegate = self; view.frame = self.view.frame; view.context = context; view.drawableColorFormat = GLKViewDrawableColorFormatRGBA8888; if (![EAGLContext setCurrentContext:context]) { NSLog(@"Failed to set current OpenGL context"); exit(1); } [self.view addSubview:view]; }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS_定时器动画的使用]]]></title>
    <url>%2F2017%2F08%2F18%2F%E5%AE%9A%E6%97%B6%E5%99%A8timer%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github 地址 项目中智能灯有个定时开关的功能，需要在界面上实现时间选择，动画走动然后就写了这个功能实现倒计时 实现准备时间数组： 1. hourArray 存放小时的数组 2. minuteArray 存放分钟的数组 _hourArray = [NSMutableArray array]; for (int i = 0; i < 24; i ++) { [_hourArray addObject:[NSString stringWithFormat:@"%d",i]]; } _minuteArray = [NSMutableArray array]; for (int i = 1; i < 60; i ++) { [_minuteArray addObject:[NSString stringWithFormat:@"%d",i]]; } 宏定义： #define WIN_WIDTH [self.view.bounds.size.width] #define WIN_HEIGHT [self.view.bounds.size.height] #define BACKCOLOR [UIColor colorWithRed:241/255.0 green:241/255.0 blue:241/255.0 alpha:1] #define BARCOLOR [QPUtilities colorWithHexString:@"#242947" alpha:1.f] 全局变量： { BOOL OpenOrClose; dispatch_source_t _timer; int hours; int minites; int secondTotal; int delayTotal; } 时间选择器UIPickView懒加载： -(StellarTimeView *)dateTimeView{ if (_dateTimeView == nil) { _dateTimeView =[[StellarTimeView alloc]initWithFrame:CGRectMake(0, 40, self.dateView.frame.size.width, self.view.bounds.size.height / 2 - 100)]; } return _dateTimeView; } pragma mark – UIPickerViewDateSource - (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView { return 3; } -(NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component { if (component == 0) { return (unsigned)[_hourArray count]; }else if (component == 1){ return 1; }else return (unsigned)[_minuteArray count]; } pragma mark – UIPickerViewDelegate -(CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent:(NSInteger)component { return 60; } -(CGSize)rowSizeForComponent:(NSInteger)component{ CGSize size = CGSizeFromString(@"20"); return size; } -(void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component { if (component == 0) { NSString *_proNameStr = [_hourArray objectAtIndex:(unsigned)row]; hours = [_proNameStr intValue]; }else if (component == 1){ } else { NSString *_proTimeStr = [_minuteArray objectAtIndex:(unsigned)row]; minites = [_proTimeStr intValue]; } } -(NSString*)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component { if (component == 0) { return [_hourArray objectAtIndex:(unsigned)row]; }else if (component == 1){ return @":"; } else { return [_minuteArray objectAtIndex:(unsigned)row]; } } 动画绘制懒加载： -(StellarTimeView *)dateTimeView{ if (_dateTimeView == nil) { _dateTimeView =[[StellarTimeView alloc]initWithFrame:CGRectMake(0, 40, self.dateView.frame.size.width, self.view.bounds.size.height / 2 - 100)]; } return _dateTimeView; } 添加一个navgationbar - (void)setNavigationbar { CGRect screenRect = [[UIScreen mainScreen] bounds]; UINavigationBar *navigationBar = [[UINavigationBar alloc] initWithFrame:CGRectMake(0, 0, screenRect.size.width, 49)]; navigationBar.tintColor = [UIColor blackColor]; navigationBar.backgroundColor = [UIColor greenColor]; //创建 UINavigationItem UINavigationItem * navigationBarTitle = [[UINavigationItem alloc] initWithTitle:@"UINavigationBar"]; [navigationBar pushNavigationItem: navigationBarTitle animated:YES]; [self.view addSubview: navigationBar]; } 注： 动画类已封装只需要传入Percent和progressView定时器的处理- (void)timeHeadle{ if (_timer==nil) { __block int timeout = 0; //倒计时时间 timeout = secondTotal; [self setIsTotalTimeSelect:secondTotal]; if (timeout!=0) { dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue); dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),(uint64_t) 1.0 * NSEC_PER_SEC, 0); //每秒执行 dispatch_source_set_event_handler(_timer, ^{ if(timeout&lt;=0){ //倒计时结束，关闭时界面显示 dispatch_source_cancel(_timer); _timer = nil; dispatch_async(dispatch_get_main_queue(), ^{ [self timeHide]; }); } else{ int hour = (int)(timeout/3600); int minute = (int)(timeout-hour*3600)/60; int second = timeout-hour*3600-minute*60; dispatch_async(dispatch_get_main_queue(), ^{ if (secondTotal == 0) { int total =[self isTotalTimeSelect]; self.dateTimeView.percent = (CGFloat)(total-delayTotal) / total + (CGFloat)(delayTotal- timeout) / total; } else{ self.dateTimeView.percent = (CGFloat)(secondTotal-timeout)/(CGFloat)secondTotal; } if (hour&lt;10) { if (minute&lt;10) { if (second&lt;10) { self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:0%d&quot;,hour,minute,second]; }else{ self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:%d&quot;,hour,minute,second]; } }else { if (second&lt;10) { self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:0%d&quot;,hour,minute,second]; }else{ self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:%d&quot;,hour,minute,second]; } } }else{ if (minute&lt;10) { if (second&lt;10) { self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:0%d&quot;,hour,minute,second]; }else{ self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:%d&quot;,hour,minute,second]; } }else { if (second&lt;10) { self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:0%d&quot;,hour,minute,second]; }else{ self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:%d&quot;,hour,minute,second]; } } } }); timeout--; } }); dispatch_resume(_timer); }else{ self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;00:00:00&quot;]; } } }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[iOS_CollectionViewCell的增删移]]]></title>
    <url>%2F2017%2F08%2F11%2F%E5%A2%9E%E5%88%A0%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github 地址 今日看到某娱乐项目选择增删移很好玩，周五上午没事就写了一个。 利用CollectionViewCell，将数据持久化保存在infoplist。 再也不怕回到解放前了。主要分[已添加]–[待添加]–[未添加]–[删除添加] CollectionViewCell UIBarButtonItem * rightItem = [[UIBarButtonItem alloc]initWithTitle:@"新增加" style:UIBarButtonItemStylePlain target:self action:@selector(add)]; self.navigationItem.rightBarButtonItem = rightItem; UICollectionViewFlowLayout * layout = [[UICollectionViewFlowLayout alloc]init]; layout.itemSize = CGSizeMake(50, 50); layout.scrollDirection = UICollectionViewScrollDirectionVertical; self.collectionView = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height) collectionViewLayout:layout]; self.collectionView.backgroundColor = [UIColor whiteColor]; self.collectionView.delegate = self; self.collectionView.dataSource = self; [self.collectionView registerNib:[UINib nibWithNibName:@"CollectionViewCell" bundle:nil] forCellWithReuseIdentifier:identifier]; [self.collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:headerId]; 两个数组用来存放已添加的和待添加的 if ([[NSUserDefaults standardUserDefaults]objectForKey:@"one"] == nil) { self.oneArray = [NSMutableArray arrayWithObjects:@"0",@"1",@"2",@"3",@"4",@"5",@"6",@"7",@"8",@"9",@"10",@"11",@"12",@"13",@"14",@"15",@"16",@"17",@"18",@"19",nil]; }else{ id array = [[NSUserDefaults standardUserDefaults]objectForKey:@"one"]; [self.oneArray addObjectsFromArray:array]; } if ( [[NSUserDefaults standardUserDefaults]objectForKey:@"two"] == nil) { self.twoArray = [NSMutableArray arrayWithObjects:@"a",@"b",@"c",@"d",@"e",@"f",@"g",@"h",@"i",@"j", nil]; }else{ id array = [[NSUserDefaults standardUserDefaults]objectForKey:@"two"]; [self.twoArray addObjectsFromArray:array]; } 每次改变后刷新要防止复用 UICollectionReusableView *headerView = [self.collectionView dequeueReusableSupplementaryViewOfKind:kind withReuseIdentifier:headerId forIndexPath:indexPath]; headerView.backgroundColor = [UIColor darkGrayColor]; [headerView.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)]; _titleLab = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width - 50, 40)]; _titleLab.textAlignment = NSTextAlignmentLeft; _titleLab.textColor = [UIColor whiteColor]; [headerView addSubview:self.titleLab]; 编辑状态下进行移动和删除 -(void)edit{ for (CollectionViewCell * cell in self.collectionView.visibleCells) { if (cell.edit == NO) { cell.layer.masksToBounds = NO; cell.layer.shadowOpacity = 0.7f; cell.layer.shadowColor = [UIColor darkGrayColor].CGColor; cell.layer.shadowOffset = CGSizeMake(1.f, 1.f); cell.deleteBtn.hidden = NO; [self.editBtn setTitle:@"完成" forState:UIControlStateNormal]; cell.edit = YES; }else{ cell.edit = NO; cell.deleteBtn.hidden = YES; cell.layer.masksToBounds = YES; [self.editBtn setTitle:@"编辑" forState:UIControlStateNormal]; } } } 添加数据,持久化存储刷新界面 -(void)add{ SCLAlertView * alert = [[SCLAlertView alloc]init]; [alert setHorizontalButtons:YES]; SCLTextView * textField = [alert addTextField:@"Enter your name"]; [alert addButton:@"确定" actionBlock:^(void) { NSLog(@"Text value: %@", textField.text); [self.twoArray addObject:textField.text]; [self.collectionView reloadData]; [[NSUserDefaults standardUserDefaults]setObject:self.twoArray forKey:@"two"]; [[NSUserDefaults standardUserDefaults]synchronize]; }]; [alert showEdit:self title:nil subTitle:@"请输入名称" closeButtonTitle:@"取消" duration:0.0f]; 增删移随时保存数据 [[NSUserDefaults standardUserDefaults]setObject:self.oneArray forKey:@"one"]; [[NSUserDefaults standardUserDefaults]setObject:self.twoArray forKey:@"two"]; [[NSUserDefaults standardUserDefaults]synchronize];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[iOS_自定义tarbar和侧边栏]]]></title>
    <url>%2F2017%2F08%2F03%2F%E8%87%AA%E5%AE%9A%E4%B9%89tarbar%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github 地址 pod RESideMenu vim podfile platform :ios,&apos;8.0&apos; target &apos;SideAndTarbar&apos; do pod &apos;RESideMenu&apos;, &apos;~&gt; 4.0.7&apos; AppDelegate.m添加RESideMenuDelegate didFinishLaunchingWithOptions self.window = [[UIWindow alloc]initWithFrame:[[UIScreen mainScreen ]bounds]]; TableViewController * viewController = [[TableViewController alloc]init]; TarBarViewController * barViewController = [[TarBarViewController alloc]init]; RESideMenu * sideMenu = [[RESideMenu alloc]initWithContentViewController:barViewController leftMenuViewController:viewController rightMenuViewController:nil]; sideMenu.delegate = self; sideMenu.contentViewShadowEnabled = YES; sideMenu.contentViewInPortraitOffsetCenterX = 100.f; sideMenu.contentViewScaleValue = 1.0; sideMenu.menuPreferredStatusBarStyle = UIStatusBarStyleLightContent; sideMenu.bouncesHorizontally = NO; self.window.rootViewController = sideMenu; 自定义tabbar 添加子控制器属性 添加navgationbar 去除tabbar分割线 选中controller后图片和标题改变 -(void)addChildViewController:(UIViewController *)childController title:(NSString *)title image:(UIImage *)image selecteImage:(UIImage *)selectedImage{ UINavigationController * controller = [[UINavigationController alloc]initWithRootViewController:childController]; childController.view.backgroundColor = [UIColor whiteColor]; childController.navigationItem.title = title; [[UITabBar appearance] setShadowImage:[UIImage new]]; [[UITabBar appearance] setBackgroundImage:[[UIImage alloc]init]]; selectedImage = [selectedImage imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]; self.tabBar.tintColor = [UIColor greenColor]; controller.tabBarItem = [[UITabBarItem alloc]initWithTitle:title image:image selectedImage:selectedImage]; [self addChildViewController:controller]; } 添加子控制器 -(void)setNewBar{ OneViewController * one = [[OneViewController alloc]init]; [self addChildViewController:one title:@"MainOne" image:[UIImage imageNamed:@"icon_home_normal"] selecteImage:[UIImage imageNamed:@"icon_home_selected"]]; TwoViewController * two = [[TwoViewController alloc]init]; [self addChildViewController:two title:@"MainTwo" image:[UIImage imageNamed:@"icon_door_normal"] selecteImage:[UIImage imageNamed:@"icon_door_selected"]]; } 在各自类中进行操作就OK 例如： self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc]initWithImage:[UIImage imageNamed:@"icon_sidebar"] style:UIBarButtonItemStylePlain target:self action:@selector(presentLeftMenuViewController:)]; UIButton * button = [[UIButton alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; button.backgroundColor = [UIColor greenColor]; [self.view addSubview:button];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo简单操作]]></title>
    <url>%2F2017%2F07%2F25%2FHexo%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks.打开themes/next/source/css/_custom/custom.styl.参考样式:博客地址 /*标题 */ .post-title{ color: red; } /*内容 */ .post-body{ color: green; } /*author */ .author{ text-align: center; color: red; } /*心photo */ .with-love{ color: red; } /*乐乐 */ .theme-link{ color: red; } .busuanzi-value{ color: rebeccapurple; } Next主题操作 生成新页面 hexo g 发布代码 hexo d 开启调试服务 hexo s –debug 为next主题的主页文章添加阴影效果 打开themes/next/source/css/_schemes/Mist/_posts-expanded.styl文件 找到类.posts-expand下面的.post .post { margin-top: 120px; } 改成: .post { margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); } 添加“Fork me on Github” ribbon 打开themes\next\layout\layout.swig &lt;a href=&quot;你的地址&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; left: 0; border: 0;&quot; src=&quot;https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67&quot; alt=&quot;Fork me on GitHub&quot; data-canonical-src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png&quot;&gt;&lt;/a&gt; 404界面 找到根目录-source 创建HTML文件 打开：commonweal: /404.html &lt;html&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;http://www.princesmall.cn&quot; homePageName=&quot;回到乐乐的主页&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注：如果返回的还是qq主页，请参考我网页源码，毕竟有些长，这只是不body。然后copy到你的404.html下 文章末尾追加版权信息 找到themes/next/layout/_macro/reward.swig 在最上面添加如下代码：（最上面） Hexo插入图片 首先确认根目录下_config.yml 中有 post_asset_folder:true 在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image –save 创建文件hexo new “文件名” 在source下会生成一个和文件名一样的文件夹，图片放在该文件夹下 例如： ![logo](文件名/logo.jpg) 是不是so easy！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>