<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[GIT_版本库管理]]]></title>
    <url>%2F2017%2F09%2F22%2FGIT-%E7%89%88%E6%9C%AC%E5%BA%93%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[今天新同事不会用git，着实让我惊讶了，还好我有做笔记的习惯。就把我A long time ago 学习整理的git给他了，上手简单，很快就会成为git 大神，啊哈哈 Git 小技能多人开发Git版本库的管理是再好不过的了，首先你要会把远程仓库的代码clone到你的电脑里，其次建立本地你的分支，写上你的code，然后添加到暂存区，没有问题就提交到修改区。既然是同时开发，肯能你同事也修改了，那就要把他的code先从远程仓库pull下来，不管你知不知道他们是否提交，避免冲突，先pull再push。然后无误后在merge到master分支，一切一气呵成。 远程仓库管理 先克隆代码到桌面吧，这克隆的是master分支代码 cd desktop git clone (远程仓库地址) 如果你想克隆远程别的分支代码 git checkout -b (分支名) origin/(远程分支名) git checkout —track origin/(远程分支名) 添加远程仓库 git remote add origin (远程仓库地址)： 删除远程仓库 git remote remove origin (远程仓库地址) 显示远程分支 git remote show origin 代码管理 代码添加到暂存区 git add (文件名)：添加某个文件 git add . : 添加所有文件 git add -A : 添加所有文件夹和文件 代码添加到当前分支 git commit -m "提交描述" 拉取远程代码 git pull origin (远程分支) 同步本地代码 git push origin (远程分支) 分支管理 查看当前分支 git branch 创建新的分支 git checkout -b newBranch 删除旧的分支 git checkout -d newBranch 合并分支 git merge (要合并的分支) 提交管理 找到历史提交的commit id git log —pretty=oneline —abbrev-commit 取消暂存 git reset HEAD 文件名 放弃当前修改 git checkout -- (文件名)：（放弃当前文件修改） git checkout . :(放弃当前所有修改) 恢复commit_id对应的版本 git reset --hard commit_id 标签管理 查看标签 git tag 查看标签信息 git show v1.0 创建标签 git tag v1.0 : 创建1.0标签 git tag v2.0 (commit_id): 创建指定提交的标签 删除标签 git tag -d v1.0 :（删除1.0标签） git push origin :refs/tags/v0.9：（删除远程0.9标签） 推送本地标签 git push origin v1.0 ：（推送本地标签到远程） git push origin —tags：（推送所有本地标签到远程） 当然没有写Git冲突处理，因为我觉得冲突太简单了，打开项目包内容，定位到冲突的地方。保留正确的code，删除多余的运行就OK。如果一些乱七八糟的冲突，当然我也遇到过但是没有记录下来，很遗憾。 冲突解决]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[机器学习_CoreML_Inceptionv3]]]></title>
    <url>%2F2017%2F09%2F21%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-CoreML-Inceptionv3%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome:github地址 一直直接用图片给.mlmodel去识别，觉得没有直接调用相机来的方便，一直看的都是swift版本的，所以想写一个oc的，立个flag。 CoreML_Inceptionv3 相机调用 info.plist 添加调用相机请求 相机调用请求 相机数据输出的delegate 实例化对象 摄像显示区域 相机调用请求 相机数据输出 线程 数据显示 InceptionvModel InceptionvModel输出 @property (nonatomic,strong) AVCaptureVideoPreviewLayer *previewLayer; @property (nonatomic,strong) AVCaptureSession *session; @property (nonatomic,strong) AVCaptureVideoDataOutput *videoOutPut; @property (nonatomic,strong) AVCaptureConnection *videoConnection; @property (nonatomic,strong) dispatch_queue_t videoQueue; @property (nonatomic,strong) UILabel *resultLabel; @property (nonatomic,strong) Inceptionv3 *InceptionvModel; @property (nonatomic,strong) Inceptionv3Output *outPut; 相机调用请求 self.session = [[AVCaptureSession alloc] init]; //视频 AVCaptureDevice *videoDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; if (videoDevice.isFocusPointOfInterestSupported && [videoDevice isFocusModeSupported:AVCaptureFocusModeContinuousAutoFocus]) { [videoDevice lockForConfiguration:nil]; [videoDevice setFocusMode:AVCaptureFocusModeContinuousAutoFocus]; [videoDevice unlockForConfiguration]; } AVCaptureDeviceInput *cameraDeviceInput = [[AVCaptureDeviceInput alloc] initWithDevice:videoDevice error:nil]; if ([self.session canAddInput:cameraDeviceInput]) { [self.session addInput:cameraDeviceInput]; } //视频 self.videoOutPut = [[AVCaptureVideoDataOutput alloc] init]; NSDictionary * outputSettings = [[NSDictionary alloc] initWithObjectsAndKeys:[NSNumber numberWithInt:kCVPixelFormatType_32BGRA],(id)kCVPixelBufferPixelFormatTypeKey, nil]; [self.videoOutPut setVideoSettings:outputSettings]; if ([self.session canAddOutput:self.videoOutPut]) { [self.session addOutput:self.videoOutPut]; } self.videoConnection = [self.videoOutPut connectionWithMediaType:AVMediaTypeVideo]; self.videoConnection.enabled = NO; [self.videoConnection setVideoOrientation:AVCaptureVideoOrientationPortrait]; 初始化预览层 self.previewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:self.session]; [self.previewLayer setVideoGravity:AVLayerVideoGravityResizeAspectFill]; 打开相机 [self.session startRunning]; self.videoConnection.enabled = YES; self.videoQueue = dispatch_queue_create("videoQueue", NULL); [self.videoOutPut setSampleBufferDelegate:self queue:self.videoQueue]; 关闭相机 [self.videoOutPut setSampleBufferDelegate:nil queue:nil]; self.videoConnection.enabled = NO; self.videoQueue = nil; [self.session stopRunning]; CoreML数据输出 获取相机数据输出的CMSampleBufferRef 转换成UIImage大小为299.299 输出为Inceptionv3Output 下载Inceptionv3.mlmodel target-&gt;build phases-&gt;compile sources 添加Inceptionv3.mlmodel 导入头文件Inceptionv3.h 数据转换 -(UIImage *)image:(CGSize)resize{ UIGraphicsBeginImageContext(resize); [self drawInRect:CGRectMake(0, 0, resize.width, resize.height)]; UIImage * image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image; } 数据输出 -(void)imageOutput:(CMSampleBufferRef)sampleBuffer{ CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer); CIImage * ciImage = [CIImage imageWithCVImageBuffer:imageBuffer]; Inceptionv3Image * uiImage =[[Inceptionv3Image alloc]initWithCIImage:ciImage]; UIImage * uiimage = [uiImage image:CGSizeMake(299, 299)]; CGImageRef cgImage = uiimage.CGImage; CVPixelBufferRef pixelBuffer = [ImageConvert pixelBufferFromImage:cgImage]; self.InceptionvModel = [[Inceptionv3 alloc]init]; self.outPut = [self.InceptionvModel predictionFromImage:pixelBuffer error:nil]; } 在AVCaptureOutputDelegat回调方法中开启线程 把相机输出的数据转换成Inceptionv3接收的数据 在主线程刷新界面 dispatch_queue_t queue = dispatch_queue_create("CMSampleBufferRef", NULL); dispatch_sync(queue, ^{ [self imageOutput:sampleBuffer]; dispatch_async(dispatch_get_main_queue(), ^{ self.resultLabel.text = self.outPut.classLabel; }); });]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[机器学习_CoreML_MobileNet]]]></title>
    <url>%2F2017%2F09%2F20%2FPython-CoreML-MobileNet%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome:github地址 CoreML_MobileNet接着上面再写一个MobileNet.mlmodel,这次这个直接拿来用。 GoogLeNetPlaces.mlmodel 和 Resnet50都可以识别人物和静态物体。不过这个才24M，小多了，所以就简尔处理给张特定的image，然后输出结果 Download Core ML ModelGoogLeNetPlaces.mlmodel下载地址 导入头文件 #import < CoreML/CoreML.h> #import < Vision/Vision.h> #import "GoogLeNetPlaces.h" 图片识别 创建Resnet对象，加载CoreMLModel GoogLeNetPlaces *googleModel = [[GoogLeNetPlaces alloc] init]; VNCoreMLModel * vnCoreModel = [VNCoreMLModel modelForMLModel:googleModel.model error:nil]; 创建Vision请求，带有completion handle VNCoreMLRequest * vnCoreMlRequest = [[VNCoreMLRequest alloc] initWithModel:vnCoreModel completionHandler:^(VNRequest * _Nonnull request, NSError * _Nullable error) { CGFloat confidence = 0.0f; VNClassificationObservation * tempClassification = nil; for (VNClassificationObservation *classification in request.results) { if (classification.confidence > confidence) { confidence = classification.confidence; tempClassification = classification; } } }]; VNClassificationObservation对象两个属性 identifier：识别对象 confidence：识别率 发送图片识别请求 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ VNImageRequestHandler * vnImageRequestHandler = [[VNImageRequestHandler alloc] initWithCGImage:image.CGImage options:nil]; NSError *error = nil; [vnImageRequestHandler performRequests:@[vnCoreMlRequest] error:&error]; if (error) { NSLog(@"%@",error.localizedDescription); } }); 回调在主线程更新UI dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ self.resultLable.text = [NSString stringWithFormat:@"识别结果:%@",tempClassification.identifier]; self.confidenceLabel.text = [NSString stringWithFormat:@"匹配率:%@",@(tempClassification.confidence)]; }); 多次下来是不是很简单，大同小异，只要熟悉CoreML，一切就是那么easy]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[机器学习_CoreML_Resnet50]]]></title>
    <url>%2F2017%2F09%2F20%2FPython-CoreML-Resnet50%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome:github地址 CoreML_Resnet50把玩了几天的CoreML，现在上手就写很是方便啊，所以研究透之后再来些例子就简单了。这次用的是苹果提供的resnet50.mlmodel。 Download Core ML ModelResnet50.mlmodel下载地址 导入 把下载后的mlmodel放入Xcode里面，绑定target，会自动生成.h和.m文件 导入头文件 #import < CoreML/CoreML.h> #import < Vision/Vision.h> #import "Resnet50.h" 添加UIScrollView和UIPageControl self.scrollView = [[UIScrollView alloc]initWithFrame:CGRectMake(0, 0, viewWidth, 250)]; self.scrollView.delegate = self; self.scrollView.bounces = YES; self.scrollView.contentSize = CGSizeMake(5 * viewWidth, 250); self.scrollView.pagingEnabled = YES; self.scrollView.showsHorizontalScrollIndicator = NO; [self.view addSubview:self.scrollView]; self.pageControl = [[UIPageControl alloc]init]; [self.pageControl setCenter:CGPointMake(viewWidth / 2 - 20, 250 - 10)]; self.pageControl.numberOfPages = 5; self.pageControl.pageIndicatorTintColor = [UIColor blackColor]; self.pageControl.currentPageIndicatorTintColor = [UIColor redColor]; for (int i = 0; i < 5; i ++) { UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(i * viewWidth, 0, viewWidth, 250)]; imageView.image = [UIImage imageNamed:[NSString stringWithFormat:@"%d.jpg",i + 1]]; [self.scrollView addSubview:imageView]; } [self.view addSubview:self.pageControl]; 滚动到开头或末尾 if (scrollView.contentOffset.x > 4 * viewWidth) { self.scrollView.contentOffset = CGPointMake(0, 0); }else if (scrollView.contentOffset.x < 0){ self.scrollView.contentOffset = CGPointMake(4 * viewWidth, 0); } 滚动结束后识别图片 self.currentImage =[UIImage imageNamed:[NSString stringWithFormat:@"%d.jpg",(int)(self.pageControl.currentPage)]]; [self openResnet50]; 图片识别 创建Resnet对象，加载CoreMLModel Resnet50 *resnetModel = [[Resnet50 alloc] init]; VNCoreMLModel * vnCoreModel = [VNCoreMLModel modelForMLModel:resnetModel.model error:nil]; 创建Vision请求，带有completion handle VNCoreMLRequest * vnCoreMlRequest = [[VNCoreMLRequest alloc] initWithModel:vnCoreModel completionHandler:^(VNRequest * _Nonnull request, NSError * _Nullable error) { CGFloat confidence = 0.0f; VNClassificationObservation * tempClassification = nil; for (VNClassificationObservation *classification in request.results) { if (classification.confidence > confidence) { confidence = classification.confidence; tempClassification = classification; } } }]; VNClassificationObservation对象两个属性 identifier：识别对象 confidence：识别率 发送图片识别请求 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ VNImageRequestHandler * vnImageRequestHandler = [[VNImageRequestHandler alloc] initWithCGImage:image.CGImage options:nil]; NSError *error = nil; [vnImageRequestHandler performRequests:@[vnCoreMlRequest] error:&error]; if (error) { NSLog(@"%@",error.localizedDescription); } }); 回调在主线程更新UI dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ self.resultLable.text = [NSString stringWithFormat:@"识别结果:%@",tempClassification.identifier]; self.confidenceLabel.text = [NSString stringWithFormat:@"匹配率:%@",@(tempClassification.confidence)]; });]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[机器学习_Python_mlmodel]]]></title>
    <url>%2F2017%2F09%2F20%2FPython-mlmodel%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome:github地址 CoreMLModel把玩CoreML创建自己的.mlmodel的心酸历程，足足摆弄了半天，各种坑。立个flag [Permission denied]问题 pip install -U coremltools 从图也可以看出coremltools包含numpy,six,protobuf,coremltools。因为权限问题导致失败 sudo pip install -U coremltools 遇到[Permission denied]都要加sudo ImportError: No module named pkg_resources 问题 Step: 1 Login in root user. sudo su root Step: 2 Uninstall python-pip package if existing. apt-get purge -y python-pip Step: 3 Download files using wget command(File download in pwd ) wget https://bootstrap.pypa.io/get-pip.py Step: 4 Run python file. python ./get-pip.py Step: 5 Finaly exicute installation command. apt-get install python-pip Note: User must be root. 好吧，这两个问题遍布整个流程，期间各种小问题我已经不记得了，接下来就开始正文了 下载coremltools sudo pip install -U coremltools 下载pip.py文件 sudo python get-pip.py 下载scikit-learn sudo pip install -U numpy scipy scikit-learn 下载panda sudo pip install pandas 准备就绪，开工 创建csv文件 csv文件属性Square_Feet，Price 记录文件所存储位置，调用的时候需要 在终端输入生成.mlmodel文件 导入需要的类 调用csv文件 coremltools转换成.mlmodel文件 author,license,description描述 输入Square_Feet，输出Price，保存 import coremltools from sklearn.linear_model import LinearRegression import pandas as pd data = pd.read_csv(‘/Users/sansi/Desktop/CoreMLModel/input_data.csv’) model = LinearRegression() model.fit(data[[“Square_Feet”]], data[“Price”]) coreml_model = coremltools.converters.sklearn.convert(model, “Square_Feet”, “Price”) coreml_model.author = ‘tongle’ coreml_model.license = ‘BSD’ coreml_model.short_description = ‘Predicts the price of a house in the Seattle area.’ coreml_model.input_description[‘Square_Feet’] = ‘Size (in square feet)’ coreml_model.output_description[‘Price’] = ‘Price of the house’ coreml_model.save(‘HousePricer.mlmodel’) 如果没有一点python功底，我都要死在电脑前了，哈哈]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS_CellAnimation]]]></title>
    <url>%2F2017%2F09%2F12%2FiOS-CellAnimation%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 最近在用cell动画，就研究修改了别人的cell动画，整理了一下。 使用：导入Animation类，直接用类调用,输入要动画的tableview和动画type，即可 [Animation addAnimationWithTableView:tableView andRow:self.type]; UITableViewCell 出场动画：简而明了的说就是利用cell的contentView来做一下出场动画animation CGFloat width = [[UIScreen mainScreen] bounds].size.width - 40; UIView *view = [[UIView alloc] initWithFrame:CGRectMake(20, 10, width, 60)]; view.backgroundColor = [UIColor redColor]; view.layer.masksToBounds = YES; view.layer.cornerRadius = 9.0; [cell.contentView addSubview:view]; UIViewmove动画 + (void)moveAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i < cells.count; i++) { CGFloat totalTime = 0.4; UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i]; cell.transform = CGAffineTransformMakeTranslation(-XS_SCREEN_WIDTH, 0); [UIView animateWithDuration:0.4 delay:i*(totalTime/cells.count) usingSpringWithDamping:0.7 initialSpringVelocity:1/0.7 options:UIViewAnimationOptionCurveEaseIn animations:^{ cell.transform = CGAffineTransformIdentity; } completion:^(BOOL finished) { }]; } } alpha动画 + (void)alphaAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i]; cell.alpha = 0.0; [UIView animateWithDuration:0.3 delay:i*0.05 options:0 animations:^{ cell.alpha = 1.0; } completion:^(BOOL finished) { }]; } } fall动画 + (void)fallAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; NSTimeInterval totalTime = 0.8; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i]; cell.transform = CGAffineTransformMakeTranslation(0, - XS_SCREEN_HEIGHT); [UIView animateWithDuration:0.3 delay:(cells.count - i)*(totalTime/cells.count) options:0 animations:^{ cell.transform = CGAffineTransformIdentity; } completion:^(BOOL finished) { }]; } } shake动画 + (void)shakeAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; if (i%2 == 0) { cell.transform = CGAffineTransformMakeTranslation(-XS_SCREEN_WIDTH,0); }else { cell.transform = CGAffineTransformMakeTranslation(XS_SCREEN_WIDTH,0); } [UIView animateWithDuration:0.4 delay:i*0.03 usingSpringWithDamping:0.75 initialSpringVelocity:1/0.75 options:0 animations:^{ cell.transform = CGAffineTransformIdentity; } completion:^(BOOL finished) { }]; } } overTurn动画 + (void)overTurnAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; cell.layer.opacity = 0.0; cell.layer.transform = CATransform3DMakeRotation(M_PI, 1, 0, 0); NSTimeInterval totalTime = 0.7; [UIView animateWithDuration:0.3 delay:i*(totalTime/cells.count) options:0 animations:^{ cell.layer.opacity = 1.0; cell.layer.transform = CATransform3DIdentity; } completion:^(BOOL finished) { }]; } } toTop动画 + (void)toTopAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; NSTimeInterval totalTime = 0.8; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i]; cell.transform = CGAffineTransformMakeTranslation(0, XS_SCREEN_HEIGHT); [UIView animateWithDuration:0.35 delay:i*(totalTime/cells.count) options:UIViewAnimationOptionCurveEaseOut animations:^{ cell.transform = CGAffineTransformIdentity; } completion:^(BOOL finished) { }]; } } spring动画 + (void)springListAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; cell.layer.opacity = 0.7; cell.layer.transform = CATransform3DMakeTranslation(0, -XS_SCREEN_HEIGHT, 20); NSTimeInterval totalTime = 1.0; [UIView animateWithDuration:0.4 delay:i*(totalTime/cells.count) usingSpringWithDamping:0.65 initialSpringVelocity:1/0.65 options:UIViewAnimationOptionCurveEaseIn animations:^{ cell.layer.opacity = 1.0; cell.layer.transform = CATransform3DMakeTranslation(0, 0, 20); } completion:^(BOOL finished) { }]; } } shrink动画 + (void)shrinkToTopAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; CGRect rect = [cell convertRect:cell.bounds fromView:tableView]; cell.transform = CGAffineTransformMakeTranslation(0, -rect.origin.y); [UIView animateWithDuration:0.5 animations:^{ cell.transform = CGAffineTransformIdentity; }]; } } laydown动画 + (void)layDownAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; NSMutableArray *rectArr = [[NSMutableArray alloc] init]; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; CGRect rect = cell.frame; [rectArr addObject:[NSValue valueWithCGRect:rect]]; rect.origin.y = i * 10; cell.frame = rect; cell.layer.transform = CATransform3DMakeTranslation(0, 0, i*5); } NSTimeInterval totalTime = 0.8; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; CGRect rect = [[rectArr objectAtIndex:i] CGRectValue]; [UIView animateWithDuration:(totalTime/cells.count) * i animations:^{ cell.frame = rect; } completion:^(BOOL finished) { cell.layer.transform = CATransform3DIdentity; }]; } } rote动画 + (void)roteAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"transform.rotation.y"]; animation.fromValue = @(-M_PI); animation.toValue = 0; animation.duration = 0.3; animation.removedOnCompletion = NO; animation.repeatCount = 3; animation.fillMode = kCAFillModeForwards; animation.autoreverses = NO; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; cell.alpha = 0.0; [UIView animateWithDuration:0.1 delay:i*0.25 options:0 animations:^{ cell.alpha = 1.0; } completion:^(BOOL finished) { [cell.layer addAnimation:animation forKey:@"rotationYkey"]; }]; } }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS-QRCodeImage]]]></title>
    <url>%2F2017%2F09%2F11%2FiOS-QRCodeImage%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 好几天没写博客了，正好在忙二维码的生成，扫描就里一个flag吧 原始二维码通过滤镜CIFilter生成二维码 创建过滤器 给过滤器添加数据 设置滤镜inputMessage数据 输出二维码 + (CIImage *)qrCodeImageWithContent:(NSString *)content{ CIFilter *qrFilter = [CIFilter filterWithName:@"CIQRCodeGenerator"]; NSData *contentData = [content dataUsingEncoding:NSUTF8StringEncoding]; [qrFilter setValue:contentData forKey:@"inputMessage"]; [qrFilter setValue:@"H" forKey:@"inputCorrectionLevel"]; CIImage *image = qrFilter.outputImage; return image; } void ProviderReleaseData (void *info, const void *data, size_t size){ free((void*)data); } 生成制定大小的二维码 传入原始二维码数据 设置倍数scale 通过bitmapImage放大并保存 + (UIImage *)qrCodeImageWithContent:(NSString *)content codeImageSize:(CGFloat)size{ CIImage *image = [self qrCodeImageWithContent:content]; CGRect integralRect = CGRectIntegral(image.extent); CGFloat scale = MIN(size/CGRectGetWidth(integralRect), size/CGRectGetHeight(integralRect)); size_t width = CGRectGetWidth(integralRect)*scale; size_t height = CGRectGetHeight(integralRect)*scale; CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceGray(); CGContextRef bitmapRef = CGBitmapContextCreate(nil, width, height, 8, 0, colorSpaceRef, (CGBitmapInfo)kCGImageAlphaNone); CIContext *context = [CIContext contextWithOptions:nil]; CGImageRef bitmapImage = [context createCGImage:image fromRect:integralRect]; CGContextSetInterpolationQuality(bitmapRef, kCGInterpolationNone); CGContextScaleCTM(bitmapRef, scale, scale); CGContextDrawImage(bitmapRef, integralRect, bitmapImage); CGImageRef scaledImage = CGBitmapContextCreateImage(bitmapRef); CGContextRelease(bitmapRef); CGImageRelease(bitmapImage); return [UIImage imageWithCGImage:scaledImage]; } 原始条形码通过滤镜CIFilter生成二维码 创建过滤器 给过滤器添加数据 设置滤镜inputMessage数据 输出二维码 + (CIImage *)barcodeImageWithContent:(NSString *)content{ CIFilter *qrFilter = [CIFilter filterWithName:@"CICode128BarcodeGenerator"]; NSData *contentData = [content dataUsingEncoding:NSUTF8StringEncoding]; [qrFilter setValue:contentData forKey:@"inputMessage"]; [qrFilter setValue:@(0.00) forKey:@"inputQuietSpace"]; CIImage *image = qrFilter.outputImage; return image; } void ProviderReleaseData (void *info, const void *data, size_t size){ free((void*)data); } 生成定制大小的条形码 传入原始二维码数据 设置倍数scale 通过bitmapImage放大并保存 + (UIImage *)barcodeImageWithContent:(NSString *)content codeImageSize:(CGSize)size{ CIImage *image = [self barcodeImageWithContent:content]; CGRect integralRect = CGRectIntegral(image.extent); CGFloat scale = MIN(size.width/CGRectGetWidth(integralRect), size.height/CGRectGetHeight(integralRect)); size_t width = CGRectGetWidth(integralRect)*scale; size_t height = CGRectGetHeight(integralRect)*scale; CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceGray(); CGContextRef bitmapRef = CGBitmapContextCreate(nil, width, height, 8, 0, colorSpaceRef, (CGBitmapInfo)kCGImageAlphaNone); CIContext *context = [CIContext contextWithOptions:nil]; CGImageRef bitmapImage = [context createCGImage:image fromRect:integralRect]; CGContextSetInterpolationQuality(bitmapRef, kCGInterpolationNone); CGContextScaleCTM(bitmapRef, scale, scale); CGContextDrawImage(bitmapRef, integralRect, bitmapImage); CGImageRef scaledImage = CGBitmapContextCreateImage(bitmapRef); CGContextRelease(bitmapRef); CGImageRelease(bitmapImage); return [UIImage imageWithCGImage:scaledImage]; } 彩色二维码获取原始二维码改变像素点颜色 @param content 二维码数据 @param size 二维码大小 @param red 0 ~ 1.0 @param green 0 ~ 1.0 @param blue 0 ~ 1.0 + (UIImage *)qrCodeImageWithContent:(NSString *)content codeImageSize:(CGFloat)size red:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue{ UIImage *image = [self qrCodeImageWithContent:content codeImageSize:size]; int imageWidth = image.size.width; int imageHeight = image.size.height; size_t bytesPerRow = imageWidth * 4; uint32_t *rgbImageBuf = (uint32_t *)malloc(bytesPerRow * imageHeight); CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB(); CGContextRef context = CGBitmapContextCreate(rgbImageBuf, imageWidth, imageHeight, 8, bytesPerRow, colorSpaceRef, kCGBitmapByteOrder32Little|kCGImageAlphaNoneSkipLast); CGContextDrawImage(context, CGRectMake(0, 0, imageWidth, imageHeight), image.CGImage); //遍历像素, 改变像素点颜色 int pixelNum = imageWidth * imageHeight; uint32_t *pCurPtr = rgbImageBuf; for (int i = 0; i< pixelNum; i++, pCurPtr++) { if ((*pCurPtr & 0xFFFFFF00) < 0x99999900) { uint8_t* ptr = (uint8_t*)pCurPtr; ptr[3] = red*255; ptr[2] = green*255; ptr[1] = blue*255; }else{ uint8_t* ptr = (uint8_t*)pCurPtr; ptr[0] = 0; } } //取出图片 CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, rgbImageBuf, bytesPerRow * imageHeight, ProviderReleaseData); CGImageRef imageRef = CGImageCreate(imageWidth, imageHeight, 8, 32, bytesPerRow, colorSpaceRef, kCGImageAlphaLast | kCGBitmapByteOrder32Little, dataProvider, NULL, true, kCGRenderingIntentDefault); CGDataProviderRelease(dataProvider); UIImage *resultImage = [UIImage imageWithCGImage:imageRef]; CGImageRelease(imageRef); CGContextRelease(context); CGColorSpaceRelease(colorSpaceRef); return resultImage; } 给二维码添加中心logo + (UIImage *)qrCodeImageWithContent:(NSString *)content codeImageSize:(CGFloat)size logo:(UIImage *)logo logoFrame:(CGRect)logoFrame red:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue{ UIImage * image = [self qrCodeImageWithContent:content codeImageSize:size red:red green:green blue:blue]; if (logo != nil) { UIGraphicsBeginImageContext(image.size); [image drawInRect:CGRectMake(0, 0, image.size.width, image.size.height)]; [logo drawInRect:logoFrame]; UIImage *resultImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return resultImage; }else{ return image; } } 彩色条形码获取原始二维码改变像素点颜色 @param content 二维码数据 @param size 二维码大小 @param red 0 ~ 1.0 @param green 0 ~ 1.0 @param blue 0 ~ 1.0 + (UIImage *)barcodeImageWithContent:(NSString *)content codeImageSize:(CGSize)size red:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue{ UIImage *image = [self barcodeImageWithContent:content codeImageSize:size]; int imageWidth = image.size.width; int imageHeight = image.size.height; size_t bytesPerRow = imageWidth * 4; uint32_t *rgbImageBuf = (uint32_t *)malloc(bytesPerRow * imageHeight); CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB(); CGContextRef context = CGBitmapContextCreate(rgbImageBuf, imageWidth, imageHeight, 8, bytesPerRow, colorSpaceRef, kCGBitmapByteOrder32Little|kCGImageAlphaNoneSkipLast); CGContextDrawImage(context, CGRectMake(0, 0, imageWidth, imageHeight), image.CGImage); //遍历像素, 改变像素点颜色 int pixelNum = imageWidth * imageHeight; uint32_t *pCurPtr = rgbImageBuf; for (int i = 0; i< pixelNum; i++, pCurPtr++) { if ((*pCurPtr & 0xFFFFFF00) < 0x99999900) { uint8_t* ptr = (uint8_t*)pCurPtr; ptr[3] = red*255; ptr[2] = green*255; ptr[1] = blue*255; }else{ uint8_t* ptr = (uint8_t*)pCurPtr; ptr[0] = 0; } } //取出图片 CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, rgbImageBuf, bytesPerRow * imageHeight, ProviderReleaseData); CGImageRef imageRef = CGImageCreate(imageWidth, imageHeight, 8, 32, bytesPerRow, colorSpaceRef, kCGImageAlphaLast | kCGBitmapByteOrder32Little, dataProvider, NULL, true, kCGRenderingIntentDefault); CGDataProviderRelease(dataProvider); UIImage *resultImage = [UIImage imageWithCGImage:imageRef]; CGImageRelease(imageRef); CGContextRelease(context); CGColorSpaceRelease(colorSpaceRef); return resultImage; } 渐变二维码绘制黑白二维码 - (UIImage *)genQRCodeImageMask:(UIImage *)image { if (image != nil) { int bitsPerComponent = 8; int bytesPerPixel = 4; int width = image.size.width; int height = image.size.height; unsigned char * imageData = (unsigned char *)malloc(width * height * bytesPerPixel); // 将原始黑白二维码图片绘制到像素格式为ARGB的图片上，绘制后的像素数据在imageData中。 CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGContextRef imageContext = CGBitmapContextCreate(imageData, width, height, bitsPerComponent, bytesPerPixel * width, colorSpace, kCGImageAlphaPremultipliedFirst); UIGraphicsPushContext(imageContext); CGContextTranslateCTM(imageContext, 0, height); CGContextScaleCTM(imageContext, 1, -1); [image drawInRect:CGRectMake(0, 0, width, height)]; CGColorSpaceRelease(colorSpace); // 根据每个像素R通道的值修改Alpha通道的值，当Red大于100，则将Alpha置为0，反之置为255 for (int row = 0; row < height; ++row) { for (int col = 0; col < width; ++col) { int offset = row * width * bytesPerPixel + col * bytesPerPixel; unsigned char r = imageData[offset + 1]; unsigned char alpha = r > 100 ? 0 : 255; imageData[offset] = alpha; } } CGImageRef cgMaskImage = CGBitmapContextCreateImage(imageContext); UIImage *maskImage = [UIImage imageWithCGImage:cgMaskImage]; CFRelease(cgMaskImage); UIGraphicsPopContext(); CFRelease(imageContext); free(imageData); return maskImage; } return nil; } 设置蒙层的颜色 - (CAGradientLayer *)gradientLayer { if (_gradientLayer == nil) { _gradientLayer = [CAGradientLayer new]; _gradientLayer.colors = @[ (__bridge id)[UIColor colorWithRed: 0x2a / 255.0 green:0x9c / 255.0 blue: 0x1f / 255.0 alpha:1.0].CGColor, (__bridge id)[UIColor colorWithRed: 0xe6 / 255.0 green:0xcd / 255.0 blue: 0x27 / 255.0 alpha:1.0].CGColor, (__bridge id)[UIColor colorWithRed: 0xe6 / 255.0 green:0x27 / 255.0 blue: 0x57 / 255.0 alpha:1.0].CGColor ]; [self.layer addSublayer: _gradientLayer]; _gradientLayer.frame = self.bounds; } return _gradientLayer; } 添加蒙层，设置黑白二维码图片 - (void)setQRCodeImage:(UIImage *)qrcodeImage { UIImage *maskImage = [self genQRCodeImageMask: qrcodeImage]; self.maskLayer.contents = (__bridge id)maskImage.CGImage; self.maskLayer.frame = self.bounds; self.gradientLayer.mask = self.maskLayer; }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS物理动画引擎_UIDynamic]]]></title>
    <url>%2F2017%2F09%2F05%2FiOS%E7%89%A9%E7%90%86%E5%8A%A8%E7%94%BB%E5%BC%95%E6%93%8E-UIDynamic%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks.Dome: github地址 iOS物理动画引擎-UIDynamic UIDynamicBehavior 仿真行为 创建一个仿真者,用来仿真所有的物理行为 animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view] 2. 创建具体的物理仿真行为 gravity = [[UIGravityBehavior alloc]init] collision = [[UICollisionBehavior alloc]init] snapBehavior = [[UISnapBehavior alloc] init] itemBehavior = [[UIDynamicItemBehavior alloc] init] 3. 将物理仿真行为添加给仿真者实现仿真效果。 -(void)addBehavior:(UIDynamicBehavior *)behavior; -(void)removeBehavior:(UIDynamicBehavior *)behavior; -(void)removeAllBehaviors; UIGravityBehavior 重力行为 创建仿真者 self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view]; 创建仿真行为 -(UIGravityBehavior *)gravity{ if (_gravity == nil) { _gravity = [[UIGravityBehavior alloc]init]; } return _gravity; } -(UICollisionBehavior *)collision{ if (_collision == nil) { _collision = [[UICollisionBehavior alloc]init]; } return _collision; } 触碰屏幕生成重力小球 -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ UITouch * touch = touches.anyObject; CGPoint location = [touch locationInView:self.view]; self.redView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, widthRed, widthRed)]; self.redView.center = location; [self.view addSubview:self.redView]; // 随机色方块 self.redView.backgroundColor = randomColor; // 创建重力的物理仿真行为，并设置具体的items(需要仿真的view) [self.gravity addItem:self.redView]; // 下落方向 // [gravity setAngle:0.5]; // 创建弹性的物理仿真行为，并设置具体的items(需要仿真的view) [self.collision addItem:self.redView]; self.collision.translatesReferenceBoundsIntoBoundary = YES; // 将重力仿真行为添加给仿真者实现仿真效果，开始仿真 [self.animator addBehavior:self.gravity]; [self.animator addBehavior:self.collision]; } UICollisionBehavior 碰撞行为 创建仿真者 self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view]; 创建碰撞对象 self.greenView = [[UIView alloc] initWithFrame:CGRectMake(100, 200, 100, 30)]; self.greenView.backgroundColor = [UIColor greenColor]; [self.view addSubview:self.greenView]; self.blueView = [[UIView alloc] initWithFrame:CGRectMake(120, 300, 100, 30)]; self.blueView.backgroundColor = [UIColor blueColor]; [self.view addSubview:self.blueView]; //未绑定仿真对象 self.blackView = [[UIView alloc] initWithFrame:CGRectMake(140, 400, 100, 30)]; self.blackView.backgroundColor = [UIColor blackColor]; [self.view addSubview:self.blackView]; // 物体角度 self.blueView.transform = CGAffineTransformMakeRotation(M_PI_4); self.greenView.transform = CGAffineTransformMakeRotation(-M_PI / 8); 创建仿真行为 -(UIGravityBehavior *)gravity{ if (_gravity == nil) { _gravity = [[UIGravityBehavior alloc]init]; } return _gravity; } -(UICollisionBehavior *)collision{ if (_collision == nil) { _collision = [[UICollisionBehavior alloc]init]; } return _collision; } 开始碰撞行为 -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ // 获取点击位置，生成仿真者 UITouch * touch = touches.anyObject; CGPoint location = [touch locationInView:self.view]; self.redView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, widthRed, widthRed)]; self.redView.center = location; // pch中宏定义的随机色 self.redView.backgroundColor = randomColor; [self.view addSubview:self.redView]; [self.gravity addItem:self.redView]; // 添加碰撞检测 [self.collision addItem:self.redView]; [self.collision addItem:self.greenView]; [self.collision addItem:self.blueView]; self.collision.translatesReferenceBoundsIntoBoundary = YES; self.collision.collisionDelegate = self; __weak typeof(self) weakSelf = self; // 获取方块运动轨迹坐标 self.collision.action = ^{ NSLog(@"%@", NSStringFromCGRect(weakSelf.redView.frame)); }; CGFloat Y = self.view.frame.size.height; CGFloat X = self.view.frame.size.width; CGFloat height = self.view.frame.size.height; //设置红色的View为底边界,左边框跟右边框作为边界 [self.collision addBoundaryWithIdentifier:@"collision1" fromPoint:CGPointMake(0,Y) toPoint:CGPointMake(X, Y)]; [self.collision addBoundaryWithIdentifier:@"collision2" fromPoint:CGPointMake(0, 0) toPoint:CGPointMake(0, height)]; [self.collision addBoundaryWithIdentifier:@"collision3" fromPoint:CGPointMake(X,0) toPoint:CGPointMake(X, height)]; [self.animator addBehavior:self.collision]; [self.animator addBehavior:self.gravity]; } 碰撞开始时给被碰撞的物体添加重力仿真 // UICollisionBehavior 代理行为 - (void)collisionBehavior:(UICollisionBehavior*)behavior beganContactForItem:(id )item withBoundaryIdentifier:(nullable id )identifier atPoint:(CGPoint)p{ if ([item isEqual:self.greenView]) { UIGravityBehavior * gravity = [[UIGravityBehavior alloc] initWithItems:@[self.greenView]]; [self.animator addBehavior:gravity]; }else if ([item isEqual:self.blueView]){ UIGravityBehavior * gravity = [[UIGravityBehavior alloc] initWithItems:@[self.blueView]]; [self.animator addBehavior:gravity]; } } UISnapBehavior 吸附行为 创建仿真者 self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view]; 创建吸附对象 -(UIView *)redView{ if (_redView ==nil) { _redView = [[UIView alloc]initWithFrame:CGRectMake(p.x, p.y, 50, 50)]; _redView.backgroundColor = [UIColor redColor]; [self.view addSubview:_redView]; } return _redView; } 开始吸附行为 -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ [self.animator removeAllBehaviors]; UITouch * touch = touches.anyObject; CGPoint location = [touch locationInView:self.view]; p = location; NSLog(@"%@",NSStringFromCGPoint(location)); // 3 添加吸附事件 UISnapBehavior *snap = [[UISnapBehavior alloc] initWithItem:self.redView snapToPoint:location]; // 改变震动幅度，0表示振幅最大，1振幅最小 snap.damping = 0.5; // 4. 将吸附事件添加到仿真者行为中 [self.animator addBehavior:snap]; } UIDynamicItemBehavior 迅猛移动弹跳摆动行为 创建仿真者 self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view]; 创建仿真行为 -(UIGravityBehavior *)gravity{ if (_gravity == nil) { _gravity = [[UIGravityBehavior alloc]init]; } return _gravity; } -(UICollisionBehavior *)collision{ if (_collision == nil) { _collision = [[UICollisionBehavior alloc]init]; [_collision addBoundaryWithIdentifier:@"barrier" forPath:[UIBezierPath bezierPathWithRect:self.view.bounds]]; _collision.translatesReferenceBoundsIntoBoundary = YES; } return _collision; } -(UIDynamicItemBehavior *)itemBehavior{ if (_itemBehavior == nil) { _itemBehavior = [[UIDynamicItemBehavior alloc] init]; _itemBehavior.elasticity = 1; } return _itemBehavior; } 生成小球，添加仿真事件 -(void)touchesAddSquareView{ float viewWidth = 20; UIView * view = [[UIView alloc]initWithFrame:CGRectMake(p.x, p.y, viewWidth, viewWidth)]; view.layer.cornerRadius = viewWidth / 2.0; view.backgroundColor = randomColor; [self performSelector:@selector(removeView:) withObject:view afterDelay:10]; [self.view addSubview:view]; [self.collision addItem:view]; [self.itemBehavior addItem:view]; [self.gravity addItem:view]; [self.animator addBehavior:self.collision]; [self.animator addBehavior:self.itemBehavior]; [self.animator addBehavior:self.gravity]; } 点触，移动和松开创建小球 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { UITouch * touch = touches.anyObject; CGPoint location = [touch locationInView:self.view]; p = location; [self touchesAddSquareView]; } - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event { UITouch * touch = touches.anyObject; CGPoint location = [touch locationInView:self.view]; p = location; [self touchesAddSquareView]; } - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event { [self touchesAddSquareView]; } 10s后删除小球和其物理仿真行为 -(void)removeView:(UIView *)view{ if (view == nil) { return; } [UIView animateWithDuration:.5 animations:^{ view.alpha = 0; } completion:^(BOOL finished) { [view removeFromSuperview]; [self.collision removeItem:view]; [self.itemBehavior removeItem:view]; [self.gravity removeItem:view]; }]; }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift_popAnimation实例]]]></title>
    <url>%2F2017%2F08%2F28%2FSwift-popAnimation%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 情人节在写博客也是蛮拼的 Pod pop 如 [Swift_popAnimation初级] 动画思路 三条杠变叉：中间杠的消失和两边杠的偏移。 叉变三条杠：两边杠的偏移和中间杠的出现。 三条杠用三个view来代替，添加在一个button上。声明全局属性 var hamburger = true var hamburgerButton : UIButton? var top:UIView? var middle:UIView? var bottom:UIView? 实例化对象 self.hamburgerButton = UIButton() self.hamburgerButton?.backgroundColor = UIColor.black self.hamburgerButton?.frame = CGRect(x: 100, y: 200, width: 150, height: 150) self.hamburgerButton?.layer.cornerRadius = 75 self.view.addSubview(hamburgerButton!) self.hamburgerButton?.addTarget(self, action:#selector(didTapHamburgerButton), for: UIControlEvents.touchUpInside) //三道杠 let sectionWidth:CGFloat = 80.0 let sectionHeight:CGFloat = 11.0 //top top = UIView(frame: CGRect(x: (self.hamburgerButton?.bounds.size.width)! / 2 - sectionWidth / 2, y: 40, width: sectionWidth, height: sectionHeight)) top?.backgroundColor = UIColor.white top?.isUserInteractionEnabled = false top?.layer.cornerRadius = sectionHeight / 2 self.hamburgerButton?.addSubview(top!) //middle middle = UIView(frame: CGRect(x: (self.hamburgerButton?.bounds.size.width)! / 2 - sectionWidth / 2, y: 69, width: sectionWidth, height: sectionHeight)) middle?.backgroundColor = UIColor.white middle?.isUserInteractionEnabled = false middle?.layer.cornerRadius = sectionHeight / 2 self.hamburgerButton?.addSubview(middle!) //bottom bottom = UIView(frame: CGRect(x: (self.hamburgerButton?.bounds.size.width)! / 2 - sectionWidth / 2, y: 99, width: sectionWidth, height: sectionHeight)) bottom?.backgroundColor = UIColor.white bottom?.isUserInteractionEnabled = false bottom?.layer.cornerRadius = sectionHeight / 2 self.hamburgerButton?.addSubview(bottom!) pop对象复用 颜色动画： var topColor = self.top?.pop_animation(forKey: "topColor") as! POPSpringAnimation? var bottomColor = self.top?.pop_animation(forKey: "bottomColor") as! POPSpringAnimation? 旋转动画： var topRotate = self.top?.layer.pop_animation(forKey: "topRotate") as! POPSpringAnimation? var bottomRotate = self.top?.layer.pop_animation(forKey: "bottomRotate") as! POPSpringAnimation? 位置动画： var topPosition = self.top?.layer.pop_animation(forKey: "topPosition")as!POPSpringAnimation? var bottomPosition = self.top?.layer.pop_animation(forKey: "bottomPosition")as!POPSpringAnimation? 三道杠变红叉叉 hamburger = false UIView.animate(withDuration: 0.2, animations: { self.middle?.alpha = 0 }) //变色 if topColor != nil { topColor?.toValue = UIColor.red }else{ topColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor) topColor?.toValue = UIColor.red topColor?.springBounciness = 0 topColor?.springSpeed = 18 top?.pop_add(topColor, forKey: "topColor") } if bottomColor != nil { bottomColor?.toValue = UIColor.red }else{ bottomColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor) bottomColor?.toValue = UIColor.red bottomColor?.springBounciness = 0 bottomColor?.springSpeed = 18 bottom?.pop_add(topColor, forKey: "bottomColor") } //旋转 if topRotate != nil { topRotate?.toValue = -Double.pi / 4 }else{ topRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation) topRotate?.toValue = -Double.pi / 4 topRotate?.springBounciness = 11 topRotate?.springSpeed = 18 top?.layer.pop_add(topRotate, forKey: "topRotate") } if bottomRotate != nil { bottomRotate?.toValue = Double.pi / 4 }else{ bottomRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation) bottomRotate?.toValue = Double.pi / 4 bottomRotate?.springBounciness = 11 bottomRotate?.springSpeed = 18 bottom?.layer.pop_add(bottomRotate, forKey: "bottomRotate") } //移动 if topPosition != nil { topPosition?.toValue = 29 }else{ topPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY) topPosition?.toValue = 29 topPosition?.springBounciness = 11 topPosition?.springSpeed = 18 top?.layer.pop_add(topPosition, forKey: "topPosition") } if bottomPosition != nil { bottomPosition?.toValue = -29 }else{ bottomPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY) bottomPosition?.toValue = -29 bottomPosition?.springBounciness = 11 bottomPosition?.springSpeed = 18 bottom?.layer.pop_add(bottomPosition, forKey: "bottomPosition") } } 红叉叉变三道杠:逆向-&gt;就还原一起改变值 hamburger = true UIView.animate(withDuration: 0.2, animations: { self.middle?.alpha = 1 }) //变色 if topColor != nil { topColor?.toValue = UIColor.white }else{ topColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor) topColor?.toValue = UIColor.white topColor?.springBounciness = 0 topColor?.springSpeed = 18 top?.pop_add(topColor, forKey: "topColor") } if bottomColor != nil { bottomColor?.toValue = UIColor.white }else{ bottomColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor) bottomColor?.toValue = UIColor.white bottomColor?.springBounciness = 0 bottomColor?.springSpeed = 18 bottom?.pop_add(topColor, forKey: "bottomColor") } //旋转 if topRotate != nil { topRotate?.toValue = 0 }else{ topRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation) topRotate?.toValue = 0 topRotate?.springBounciness = 11 topRotate?.springSpeed = 18 top?.layer.pop_add(topRotate, forKey: "topRotate") } if bottomRotate != nil { bottomRotate?.toValue = 0 }else{ bottomRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation) bottomRotate?.toValue = 0 bottomRotate?.springBounciness = 11 bottomRotate?.springSpeed = 18 bottom?.layer.pop_add(bottomRotate, forKey: "bottomRotate") } //移动 if topPosition != nil { topPosition?.toValue = 0 }else{ topPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY) topPosition?.toValue = 0 topPosition?.springBounciness = 11 topPosition?.springSpeed = 18 top?.layer.pop_add(topPosition, forKey: "topPosition") } if bottomPosition != nil { bottomPosition?.toValue = 0 }else{ bottomPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY) bottomPosition?.toValue = 0 bottomPosition?.springBounciness = 11 bottomPosition?.springSpeed = 18 bottom?.layer.pop_add(bottomPosition, forKey: "bottomPosition") } } } so easy]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift_popAnimation应用]]]></title>
    <url>%2F2017%2F08%2F25%2FSwift-popAnimation%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 Pod pop如上篇文章 创建UIbutton类对象与storyboard绑定 应用touchesBegan ，touchesEnded 开始点击 缩小0.5倍 旋转半圈 //缩放动画 var scale = self.pop_animation(forKey: TLscale)as?POPSpringAnimation if scale != nil { scale?.toValue = NSValue(cgPoint:CGPoint(x: 0.5, y: 0.5)) }else{ scale = POPSpringAnimation(propertyNamed: kPOPViewScaleXY) scale?.toValue = NSValue(cgPoint:CGPoint(x: 0.5, y: 0.5)) scale?.springBounciness = 20 scale?.springSpeed = 5 self.pop_add(scale, forKey: TLscale) } //旋转动画 var rotate = self.layer.pop_animation(forKey: TLrotate)as? POPSpringAnimation if rotate != nil { rotate?.toValue = Double.pi / 2 }else{ rotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation) rotate?.toValue = Double.pi / 2 rotate?.springBounciness = 20 rotate?.springSpeed = 18 self.layer.pop_add(rotate, forKey: TLrotate) } 结束点击 缩放1.0倍回到起始状态 旋转到起始位置 //缩放动画 var scale = self.pop_animation(forKey: TLscale)as?POPSpringAnimation if scale != nil { scale?.toValue = NSValue(cgPoint:CGPoint(x: 1, y: 1)) }else{ scale = POPSpringAnimation(propertyNamed: kPOPViewScaleXY) scale?.toValue = NSValue(cgPoint:CGPoint(x: 1, y: 1)) scale?.springBounciness = 20 scale?.springSpeed = 5 self.pop_add(scale, forKey: TLscale) } //旋转动画 var rotate = self.layer.pop_animation(forKey: TLrotate)as? POPSpringAnimation if rotate != nil { rotate?.toValue = 0 }else{ rotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation) rotate?.toValue = 0 rotate?.springBounciness = 20 rotate?.springSpeed = 18 self.layer.pop_add(rotate, forKey: TLrotate)]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift_popAnimation初级]]]></title>
    <url>%2F2017%2F08%2F25%2FpopAnimation%E5%88%9D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 先初尝popAnimation一些环境配置和方法调用，下篇会写实例应用 Pods pop vim podfile platform :ios,'8.0' target "RedBall" do pod 'pop' end pod install 动画 宏定义 let TLspin = "spin" let TLmove = "move" let TLcolor = "color" let TLscale = "scale" 属性定义 let redBall = UIView(frame: CGRect(x: 100, y: 200, width: 100, height: 100)) let scale = POPSpringAnimation(propertyNamed:kPOPViewScaleXY) let move = POPSpringAnimation(propertyNamed: kPOPLayerPositionY) let spin = POPSpringAnimation(propertyNamed: kPOPLayerRotation) let color = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor) segmentContol创建 let array = [&quot;放大&quot;,&quot;旋转&quot;,&quot;移动&quot;,&quot;变色&quot;,&quot;归位&quot;] let segmentedControl = UISegmentedControl.init(items:array) segmentedControl.frame = CGRect(x:50,y:50,width:self.view.frame.size.width-100 ,height:30) segmentedControl.tintColor = UIColor.green segmentedControl.backgroundColor = UIColor.red segmentedControl.addTarget(self, action:#selector(segmentedControlChanged(segmented:)), for: UIControlEvents.valueChanged) self.view .addSubview(segmentedControl); 动画代码 pop放大，旋转，移动，变色，还原动画 springBounciness: 弹性振幅，范围0-20 springSpeed: 震动速度 pop_add: 加载动画 func redBallScale() { // 放大动画 scale?.toValue = NSValue(cgPoint:CGPoint(x: 2, y: 2)) scale?.springBounciness = 20 scale?.springSpeed = 1 redBall.pop_add(scale, forKey: TLscale) } func redBallSpin() { //旋转动画 spin?.toValue = Double.pi * 4 spin?.springBounciness = 20 spin?.springSpeed = 5 redBall.layer.pop_add(spin, forKey: TLspin) } func redBallMove() { //y坐标位移动画 move?.toValue = 500 move?.springBounciness = 20 move?.springSpeed = 5 redBall.layer.pop_add(move, forKey: TLmove) } func redBallColor() { //背景颜色变化 color?.toValue = UIColor.green color?.springBounciness = 20 color?.springSpeed = 5 redBall.pop_add(color, forKey: TLcolor) }]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS-绑定Amazon]]]></title>
    <url>%2F2017%2F08%2F23%2FiOS-%E7%BB%91%E5%AE%9AAmazon%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 为实现echo语音控制只能家居，所以需要绑定亚马逊账号 Install the Login with Amazon SDK for iOS 下载亚马逊SDK LoginWithAmazonSDKForiOS.zip 工程中拖入SDK LoginWithAmazon.framework Target - BuildPhases - Link Binary With Libraries中添加framework Register with Login with Amazon注册亚马逊账号亚马逊注册 登录亚马逊账号亚马逊登录 输入App的名称，链接和App图标等 注册地址 App Console.前提是你有亚马逊账号 Add iOS Settings to an Application 亚马逊 App应用界面，点击iOS设置，如果你的iOS App已经注册好，点击 API Key 需要输入你的Bundle ID,target - General Add Your API Key to Your App Property List 选择 project - Info.plist 添加APIKey ，选择copy，别出错 Add a URL Scheme to Your App Property List 选择 project - Info.plist 添加URL types Item 0 Document Role 填写Editor。 Shames 填写 prefs Item 1 identifier 填写bundle ID。 Shames 填写amzn-bundle ID 其他填写如下图 Using the SDK for iOS APIs创建亚马逊类，导入 #import&lt; LoginWithAmazon/LoginWithAmazon.h&gt; Using the SDK for iOS APIs 在 AppDelegate 导入import &lt; LoginWithAmazon/LoginWithAmazon.h&gt;. 添加以下方法,返回亚马逊URL - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation { #pragma unused(application,annotation) // Pass on the url to the SDK to parse authorization code from the url. BOOL isValidRedirectLogInURL = [AMZNAuthorizationManager handleOpenURL:url sourceApplication:(NSString *)sourceApplication]; if(!isValidRedirectLogInURL){ return NO; } // App may also want to handle url return YES; } Handle the Login Button and Get Profile Data 发出登录请求 userID ，profile，postalCode successful 成功登录返回数据result.token，result.user，user.userID error 回复错误 userDidCancel 用户自动取消 - (IBAction)onLogInButtonClicked:(id)sender { // Build an authorize request. AMZNAuthorizeRequest *request = [[AMZNAuthorizeRequest alloc] init]; request.scopes = [NSArray arrayWithObjects: [AMZNProfileScope userID], [AMZNProfileScope profile], [AMZNProfileScope postalCode]]; // Make an Authorize call to the Login with Amazon SDK. [[AMZNAuthorizationManager sharedManager] authorize:request withHandler:^(AMZNAuthorizeResult *result, BOOL userDidCancel, NSError *error) { if (error) { // Handle errors from the SDK or authorization server. } else if (userDidCancel) { // Handle errors caused when user cancels login. } else { // Authentication was successful. // Obtain the access token and user profile data. NSString *accessToken = result.token; AMZNUser *user = result.user; NSString *userID = user.userID; } }]; } Fetch User Profile Data 获取登录信息 user.userID，user.name，user.email，user.postalCode 在error时可以添加重新登录方法 AMZNUser fetch:^(AMZNUser *user, NSError *error) { if (error) { // Error from the SDK, or no user has authorized to the app. } else if (user) { NSString *userID = user.userID; //NSString *name = user.name; //NSString *email = user.email; //NSString *postalCode = user.postalCode; } }]; Check for User Login at Startup // Build an authorize request. AMZNAuthorizeRequest *request = [[AMZNAuthorizeRequest alloc] init]; request.scopes = [NSArray arrayWithObjects: // [AMZNProfileScope userID], [AMZNProfileScope profile], [AMZNProfileScope postalCode]]; request.interactiveStrategy = AMZNInteractiveStrategyNever; [[AMZNAuthorizationManager sharedManager] authorize:request withHandler:^(AMZNAuthorizeResult *result, BOOL userDidCancel, NSError *error) { if (error) { // Error from the SDK, indicating the user was not previously authorized to your app for the requested scopes. } else { // The user was previously authorized to your app. // Obtain the access token and user profile data. NSString *accessToken = result.token; AMZNUser *user = result.user; NSString *userID = user.userID; } }]; Clear Authorization Data and Log Out a User 退出登录 清除亚马逊数据 [[AMZNAuthorizationManager sharedManager] signOut:^(NSError * _Nullable error) { if (!error) { // error from the SDK or Login with Amazon authorization server. } }]; 注：亚马逊账号绑定在本地存储，所以多手机登录需要存储userID到自己服务器，实现多手机登录状态回显]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS-OpenGL图形绘制二]]]></title>
    <url>%2F2017%2F08%2F23%2FiOS-OpenGL%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks.Dome: github地址 本章讲如何用原生OpenGL绘制图形及渲染图片 环境搭建 创建一个新的工程，点击target-&gt;Build Phases -&gt; Link Binary With Libraries添加库 GLKit.framework OpenGLES.framework 导入头文件: #import &lt; OpenGLES/ES2/gl.h &gt; #import &lt; OpenGLES/ES2/glext.h &gt; 三角形宏定义一个三角线 const GLfloat Trianglevertices[] = { 0.0f, 0.5f, 0.0f, -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f }; const GLubyte Triangleindices[] = { 0,1,2 }; VBO申请空间并绑定目标-(void)OneRenderVerticesAnColorsForTriangles{ GLuint vertexBuffer; glGenBuffers(1, &amp;vertexBuffer); // 绑定vertexBuffer到GL_ARRAY_BUFFER目标 glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer); // 为VBO申请空间，初始化并传递数据 glBufferData(GL_ARRAY_BUFFER, sizeof(Trianglevertices), Trianglevertices, GL_STATIC_DRAW); GLuint indexBuffer; glGenBuffers(1, &amp;indexBuffer); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Triangleindices), Triangleindices, GL_STATIC_DRAW); // 使用VBO时，最后一个参数0为要获取参数在GL_ARRAY_BUFFER中的偏移量 glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(_positionSlot); glDrawElements(GL_TRIANGLES, sizeof(Triangleindices)/sizeof(Triangleindices[0]), GL_UNSIGNED_BYTE, 0); } 四边形宏定义定义一个Vertex结构, 其中包含了坐标和颜色 typedef struct { float Position[3]; float Color[4]; } Vertex; 顶点数组 const Vertex Vertices[] = { {{-1,-1,0}, {0,0,0,1}},// 左下，黑色 {{1,-1,0}, {1,0,0,1}}, // 右下，红色 {{-1,1,0}, {0,0,1,1}}, // 左上，蓝色 {{1,1,0}, {0,1,0,1}}, // 右上，绿色 }; 索引数组 const GLubyte Indices[] = { 0,1,2, // 三角形0 1,2,3 // 三角形1 }; VBO申请空间并绑定目标 取出Vertices数组中的坐标点值，赋给_positionSlot 取出Colors数组中的每个坐标点的颜色值，赋给_colorSlot 绘制两个三角形，不复用顶点，因此需要6个顶点坐标。 V0-V1-V2, V3-V4-V5 通用部分定义属性EAGLContext * _context; CAEAGLLayer * _EALayer; GLuint _colorBufferRender; // 渲染缓冲区 GLuint _frameBuffer; // 帧缓冲区 GLuint _positionSlot; // 用于绑定shader中的Position参数 GLuint _colorSlot; // 用于绑定shader中的SourceColor参数 GLuint _glProgram; 颜色和离屏渲染 生成一个renderBuffer，id是_colorRenderBuffer 设置为当前renderBuffer 为color renderbuffer 分配存储空间 FBO用于管理colorRenderBuffer，离屏渲染 设置为当前framebuffer 将 _colorRenderBuffer 装配到 GL_COLOR_ATTACHMENT0 这个装配点上 -(void)setColorAndFrameBufferRender{ if (_colorBufferRender) { glDeleteRenderbuffers(1, &amp;_colorBufferRender); _colorBufferRender = 0; } if (_frameBuffer) { glDeleteFramebuffers(1, &amp;_frameBuffer); _frameBuffer = 0; } glGenRenderbuffers(1, &amp;_colorBufferRender); glBindRenderbuffer(GL_RENDERBUFFER, _colorBufferRender); [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:_EALayer]; glGenFramebuffers(1, &amp;_frameBuffer); glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer); glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _colorBufferRender); } 创建绘制对象 setup context, 渲染上下文，管理所有绘制的状态，命令及资源信息。 setup layer, 必须要是CAEAGLLayer才行，才能在其上描绘OpenGL内容 如果在viewController中，使用[self.view.layer addSublayer:eaglLayer]; 如果在view中，可以直接重写UIView的layerClass类方法即可return [CAEAGLLayer class]。 - (void)setContentViewAndCAEGLayer{ _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2]; [EAGLContext setCurrentContext:_context]; _EALayer = (CAEAGLLayer*)self.view.layer; _EALayer.frame = self.view.frame; _EALayer.opaque = YES; _EALayer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithBool:YES],kEAGLDrawablePropertyRetainedBacking,kEAGLColorFormatRGBA8,kEAGLDrawablePropertyColorFormat, nil]; } 设置清屏 设置清屏颜色 用来指定要用清屏颜色来清除由mask指定的buffer，此处是color buffer 将指定renderBuffer渲染在屏幕上 -(void)glClear{ glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); glViewport(0, 0, self.view.frame.size.width , self.view.frame.size.height); } 离屏渲染显示绘制图片创建glsl文件：建一个empty文件，修改后缀即可三角形Fragment precision mediump float; void main(void) { gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); } 三角形Vertex attribute vec4 Position; void main(void) { gl_Position = Position; } 四边形Fragment varying lowp vec4 DestinationColor; void main(void) { gl_FragColor = DestinationColor; } 四边形Vertex attribute vec4 Position; attribute vec4 SourceColor; varying vec4 DestinationColor; void main(void) { DestinationColor = SourceColor; gl_Position = Position; } 创建一个分类继承NSObject实现以下两个类方法 + (GLuint)compileShader:(NSString*)shaderName withType:(GLenum)shaderType; + (GLuint)compileShaders:(NSString *)shaderVertex shaderFragment:(NSString *)shaderFragment; Shader四边形Shaders - (void)processShaders { _glProgram = [TLShaderOperation compileShaders:@&quot;Vertex&quot; shaderFragment:@&quot;Fragment&quot;]; glUseProgram(_glProgram); _positionSlot = glGetAttribLocation(_glProgram, &quot;Position&quot;); _colorSlot = glGetAttribLocation(_glProgram, &quot;SourceColor&quot;); } 三角形Shaders - (void)processTriangleShaders { // 编译shaders _glProgram = [TLShaderOperation compileShaders:@&quot;TriangleVertex&quot; shaderFragment:@&quot;TriangleFragment&quot;]; glUseProgram(_glProgram); // 获取指向vertex shader传入变量的指针, 然后就通过该指针来使用 // 即将_positionSlot 与 shader中的Position参数绑定起来 glGetAttribLocation(_glProgram, &quot;Position&quot;); } 获取图片 unbind the shader 从FBO中读取图像数据，离屏渲染。 图像经过render之后，已经在FBO中了，即使不将其拿到RenderBuffer中，依然可以使用getResultImage取到图像数据。 用[_eaglContext presentRenderbuffer:GL_RENDERBUFFER];，实际上就是将FBO中的图像拿到RenderBuffer中（即屏幕上） - (UIImage *)getResultImage { CGSize currentFBOSize = self.view.frame.size; NSUInteger totalBytesForImage = (int)currentFBOSize.width * (int)currentFBOSize.height * 4; GLubyte *_rawImagePixelsTemp = (GLubyte *)malloc(totalBytesForImage); glReadPixels(0, 0, (int)currentFBOSize.width, (int)currentFBOSize.height, GL_RGBA, GL_UNSIGNED_BYTE, _rawImagePixelsTemp); glUseProgram(0); glBindFramebuffer(GL_FRAMEBUFFER, 0); CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, _rawImagePixelsTemp, totalBytesForImage, (CGDataProviderReleaseDataCallback)&freeData); CGColorSpaceRef defaultRGBColorSpace = CGColorSpaceCreateDeviceRGB(); CGImageRef cgImageFromBytes = CGImageCreate((int)currentFBOSize.width, (int)currentFBOSize.height, 8, 32, 4 * (int)currentFBOSize.width, defaultRGBColorSpace, kCGBitmapByteOrderDefault, dataProvider, NULL, NO, kCGRenderingIntentDefault); UIImage *finalImage = [UIImage imageWithCGImage:cgImageFromBytes scale:1.0 orientation:UIImageOrientationDownMirrored]; CGImageRelease(cgImageFromBytes); CGDataProviderRelease(dataProvider); CGColorSpaceRelease(defaultRGBColorSpace); return finalImage; } void freeData(void *info, const void *data, size_t size) { free((unsigned char *)data); } 用于显示图片UIImage *image = [self getResultImage]; if (image) { UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)]; imageView.backgroundColor = [UIColor whiteColor]; imageView.contentMode = UIViewContentModeScaleAspectFit; imageView.image = image; [self.view addSubview:imageView]; }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS_OpenGL环境搭建和图形绘制]]]></title>
    <url>%2F2017%2F08%2F22%2FiOS-OpenGL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks.Dome: github地址 个人觉得OpenGl图形绘制很酷所以专研了一段时间，记录供以后自己使用和小白学习。 环境搭建 创建一个新的工程，点击target-&gt;Build Phases -&gt; Link Binary With Libraries添加库 GLKit.framework OpenGLES.framework 导入 #import 头文件 因为我用GLKBaseEffect绘制的，所以不需要导入更多的头文件 顶点输入一个顶点数组对象会储存以下这些内容： glEnableVertexAttribArray和glDisableVertexAttribArray的调用。 通过glVertexAttribPointer设置的顶点属性配置。 通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。 三角形 float vertices[] = { -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f }; 多边形 typedef struct { GLfloat Positon[3];//位置 GLfloat Color[4];//颜色 } Vertex; 顶点和颜色数组 const Vertex squareVertexData[] = { { 0.5f, 0.5f, -0.9f, 1.0f, 0.0f, 0.0f, 1.0f}, //0 {-0.5f, 0.5f, -0.9f, 0.0f, 1.0f, 0.0f, 1.0f}, //1 { 0.5f, -0.5f, -0.9f, 0.0f, 0.0f, 1.0f, 1.0f}, //2 {-0.5f, -0.5f, -0.9f, 0.0f, 0.0f, 0.0f, 1.0f} //3 }; 三角形数组 const GLubyte Indices[] = { 0, 1, 2, 2, 1, 3 }; 顶点数组对象：Vertex Array Object，VBO 使用glGenBuffers函数和一个缓冲ID生成一个VBO对象：unsigned int VBO;glGenBuffers(1, &amp;VBO); glBindBuffer函数把新创建的缓冲绑定到GL_ARRAY_BUFFER目标上：glBindBuffer(GL_ARRAY_BUFFER, VBO); 我们可以调用glBufferData函数，它会把之前定义的顶点数据复制到缓冲的内存中：glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);glBufferData： 它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上 第二个参数指定传输数据的大小(以字节为单位)；用一个简单的sizeof计算出顶点数据大小就行 第三个参数是我们希望发送的实际数据。 第四个参数指定了我们希望显卡如何管理给定的数据 GL_STATIC_DRAW ：数据不会或几乎不会改变。 GL_DYNAMIC_DRAW：数据会被改变很多。 GL_STREAM_DRAW ：数据每次绘制时都会改变。 现在我们已经把顶点数据储存在显卡的内存中，用VBO这个顶点缓冲对象管理 创建一个VAO和创建一个VBO很类似：unsigned int VAO;glGenVertexArrays(1, &amp;VAO); 要想使用VAO，要做的只是使用glBindVertexArray绑定VAO 绑定VAOglBindVertexArray(VAO); 把顶点数组复制到缓冲中供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); 设置顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 sizeof(float), (void)0);glEnableVertexAttribArray(0); 三角形 GL_ARRAY_BUFFER用于顶点数组 绑定vertexBuffer到GL_ARRAY_BUFFER 给VBO传递数据 取出地址 取出颜色 glVertexAttribPointer的最后一个参数是要获取的参数在GL_ARRAY_BUFFER（每一个Vertex）的偏移量 - (void)setupVBOs{ GLuint verticesBuffer; glGenBuffers(1, &verticesBuffer); glBindBuffer(GL_ARRAY_BUFFER, verticesBuffer); glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW); glEnableVertexAttribArray(GLKVertexAttribPosition); glEnableVertexAttribArray(GLKVertexAttribColor); glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 6, (GLfloat *)NULL + 0); glVertexAttribPointer(GLKVertexAttribColor, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 6, (GLfloat *)NULL + 3); } 多边形 申请一个标识符 把标识符绑定到GL_ARRAY_BUFFER上 把顶点数据从cpu内存复制到gpu内存 开启对应的顶点属性 设置合适的格式从buffer里面读取数据 - (void)setupVBOs{ GLuint buffer; glGenBuffers(1, &buffer); glBindBuffer(GL_ARRAY_BUFFER, buffer); glBufferData(GL_ARRAY_BUFFER, sizeof(squareVertexData), squareVertexData, GL_STATIC_DRAW); GLuint elementBuffer; glGenBuffers(1, &elementBuffer); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBuffer); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW); glEnableVertexAttribArray(GLKVertexAttribPosition); glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), 0); glEnableVertexAttribArray(GLKVertexAttribNormal); glVertexAttribPointer(GLKVertexAttribNormal, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid *) (sizeof(GLfloat) * 3)); glEnableVertexAttribArray(GLKVertexAttribColor); glVertexAttribPointer(GLKVertexAttribColor, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid *) (sizeof(GLfloat) * 6)); glEnableVertexAttribArray(GLKVertexAttribTexCoord0); glVertexAttribPointer(GLKVertexAttribTexCoord0, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid *) (sizeof(GLfloat) * 10)); } GLKViewDelegate 启动着色器 添加背景颜色 绘制图形 -(void)glkView:(GLKView *)view drawInRect:(CGRect)rect { [TLEffect prepareToDraw]; glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glDrawArrays(GL_TRIANGLES, 0, 3); } 在GLKView上绘制OpenGL内容 - (void)setupContext{ context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2]; if (!context) { NSLog(@"Failed to initialize OpenGLES 2.0 context"); exit(1); } [EAGLContext setCurrentContext:context]; GLKView *view = [[GLKView alloc]init]; view.delegate = self; view.frame = self.view.frame; view.context = context; view.drawableColorFormat = GLKViewDrawableColorFormatRGBA8888; if (![EAGLContext setCurrentContext:context]) { NSLog(@"Failed to set current OpenGL context"); exit(1); } [self.view addSubview:view]; }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS_定时器动画的使用]]]></title>
    <url>%2F2017%2F08%2F18%2F%E5%AE%9A%E6%97%B6%E5%99%A8timer%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github 地址 项目中智能灯有个定时开关的功能，需要在界面上实现时间选择，动画走动然后就写了这个功能实现倒计时 实现准备时间数组： 1. hourArray 存放小时的数组 2. minuteArray 存放分钟的数组 _hourArray = [NSMutableArray array]; for (int i = 0; i < 24; i ++) { [_hourArray addObject:[NSString stringWithFormat:@"%d",i]]; } _minuteArray = [NSMutableArray array]; for (int i = 1; i < 60; i ++) { [_minuteArray addObject:[NSString stringWithFormat:@"%d",i]]; } 宏定义： #define WIN_WIDTH [self.view.bounds.size.width] #define WIN_HEIGHT [self.view.bounds.size.height] #define BACKCOLOR [UIColor colorWithRed:241/255.0 green:241/255.0 blue:241/255.0 alpha:1] #define BARCOLOR [QPUtilities colorWithHexString:@"#242947" alpha:1.f] 全局变量： { BOOL OpenOrClose; dispatch_source_t _timer; int hours; int minites; int secondTotal; int delayTotal; } 时间选择器UIPickView懒加载： -(StellarTimeView *)dateTimeView{ if (_dateTimeView == nil) { _dateTimeView =[[StellarTimeView alloc]initWithFrame:CGRectMake(0, 40, self.dateView.frame.size.width, self.view.bounds.size.height / 2 - 100)]; } return _dateTimeView; } pragma mark – UIPickerViewDateSource - (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView { return 3; } -(NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component { if (component == 0) { return (unsigned)[_hourArray count]; }else if (component == 1){ return 1; }else return (unsigned)[_minuteArray count]; } pragma mark – UIPickerViewDelegate -(CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent:(NSInteger)component { return 60; } -(CGSize)rowSizeForComponent:(NSInteger)component{ CGSize size = CGSizeFromString(@"20"); return size; } -(void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component { if (component == 0) { NSString *_proNameStr = [_hourArray objectAtIndex:(unsigned)row]; hours = [_proNameStr intValue]; }else if (component == 1){ } else { NSString *_proTimeStr = [_minuteArray objectAtIndex:(unsigned)row]; minites = [_proTimeStr intValue]; } } -(NSString*)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component { if (component == 0) { return [_hourArray objectAtIndex:(unsigned)row]; }else if (component == 1){ return @":"; } else { return [_minuteArray objectAtIndex:(unsigned)row]; } } 动画绘制懒加载： -(StellarTimeView *)dateTimeView{ if (_dateTimeView == nil) { _dateTimeView =[[StellarTimeView alloc]initWithFrame:CGRectMake(0, 40, self.dateView.frame.size.width, self.view.bounds.size.height / 2 - 100)]; } return _dateTimeView; } 添加一个navgationbar - (void)setNavigationbar { CGRect screenRect = [[UIScreen mainScreen] bounds]; UINavigationBar *navigationBar = [[UINavigationBar alloc] initWithFrame:CGRectMake(0, 0, screenRect.size.width, 49)]; navigationBar.tintColor = [UIColor blackColor]; navigationBar.backgroundColor = [UIColor greenColor]; //创建 UINavigationItem UINavigationItem * navigationBarTitle = [[UINavigationItem alloc] initWithTitle:@"UINavigationBar"]; [navigationBar pushNavigationItem: navigationBarTitle animated:YES]; [self.view addSubview: navigationBar]; } 注： 动画类已封装只需要传入Percent和progressView定时器的处理- (void)timeHeadle{ if (_timer==nil) { __block int timeout = 0; //倒计时时间 timeout = secondTotal; [self setIsTotalTimeSelect:secondTotal]; if (timeout!=0) { dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue); dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),(uint64_t) 1.0 * NSEC_PER_SEC, 0); //每秒执行 dispatch_source_set_event_handler(_timer, ^{ if(timeout&lt;=0){ //倒计时结束，关闭时界面显示 dispatch_source_cancel(_timer); _timer = nil; dispatch_async(dispatch_get_main_queue(), ^{ [self timeHide]; }); } else{ int hour = (int)(timeout/3600); int minute = (int)(timeout-hour*3600)/60; int second = timeout-hour*3600-minute*60; dispatch_async(dispatch_get_main_queue(), ^{ if (secondTotal == 0) { int total =[self isTotalTimeSelect]; self.dateTimeView.percent = (CGFloat)(total-delayTotal) / total + (CGFloat)(delayTotal- timeout) / total; } else{ self.dateTimeView.percent = (CGFloat)(secondTotal-timeout)/(CGFloat)secondTotal; } if (hour&lt;10) { if (minute&lt;10) { if (second&lt;10) { self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:0%d&quot;,hour,minute,second]; }else{ self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:%d&quot;,hour,minute,second]; } }else { if (second&lt;10) { self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:0%d&quot;,hour,minute,second]; }else{ self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:%d&quot;,hour,minute,second]; } } }else{ if (minute&lt;10) { if (second&lt;10) { self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:0%d&quot;,hour,minute,second]; }else{ self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:%d&quot;,hour,minute,second]; } }else { if (second&lt;10) { self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:0%d&quot;,hour,minute,second]; }else{ self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:%d&quot;,hour,minute,second]; } } } }); timeout--; } }); dispatch_resume(_timer); }else{ self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;00:00:00&quot;]; } } }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[iOS_CollectionViewCell的增删移]]]></title>
    <url>%2F2017%2F08%2F11%2F%E5%A2%9E%E5%88%A0%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github 地址 今日看到某娱乐项目选择增删移很好玩，周五上午没事就写了一个。 利用CollectionViewCell，将数据持久化保存在infoplist。 再也不怕回到解放前了。主要分[已添加]–[待添加]–[未添加]–[删除添加] CollectionViewCell UIBarButtonItem * rightItem = [[UIBarButtonItem alloc]initWithTitle:@"新增加" style:UIBarButtonItemStylePlain target:self action:@selector(add)]; self.navigationItem.rightBarButtonItem = rightItem; UICollectionViewFlowLayout * layout = [[UICollectionViewFlowLayout alloc]init]; layout.itemSize = CGSizeMake(50, 50); layout.scrollDirection = UICollectionViewScrollDirectionVertical; self.collectionView = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height) collectionViewLayout:layout]; self.collectionView.backgroundColor = [UIColor whiteColor]; self.collectionView.delegate = self; self.collectionView.dataSource = self; [self.collectionView registerNib:[UINib nibWithNibName:@"CollectionViewCell" bundle:nil] forCellWithReuseIdentifier:identifier]; [self.collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:headerId]; 两个数组用来存放已添加的和待添加的 if ([[NSUserDefaults standardUserDefaults]objectForKey:@"one"] == nil) { self.oneArray = [NSMutableArray arrayWithObjects:@"0",@"1",@"2",@"3",@"4",@"5",@"6",@"7",@"8",@"9",@"10",@"11",@"12",@"13",@"14",@"15",@"16",@"17",@"18",@"19",nil]; }else{ id array = [[NSUserDefaults standardUserDefaults]objectForKey:@"one"]; [self.oneArray addObjectsFromArray:array]; } if ( [[NSUserDefaults standardUserDefaults]objectForKey:@"two"] == nil) { self.twoArray = [NSMutableArray arrayWithObjects:@"a",@"b",@"c",@"d",@"e",@"f",@"g",@"h",@"i",@"j", nil]; }else{ id array = [[NSUserDefaults standardUserDefaults]objectForKey:@"two"]; [self.twoArray addObjectsFromArray:array]; } 每次改变后刷新要防止复用 UICollectionReusableView *headerView = [self.collectionView dequeueReusableSupplementaryViewOfKind:kind withReuseIdentifier:headerId forIndexPath:indexPath]; headerView.backgroundColor = [UIColor darkGrayColor]; [headerView.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)]; _titleLab = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width - 50, 40)]; _titleLab.textAlignment = NSTextAlignmentLeft; _titleLab.textColor = [UIColor whiteColor]; [headerView addSubview:self.titleLab]; 编辑状态下进行移动和删除 -(void)edit{ for (CollectionViewCell * cell in self.collectionView.visibleCells) { if (cell.edit == NO) { cell.layer.masksToBounds = NO; cell.layer.shadowOpacity = 0.7f; cell.layer.shadowColor = [UIColor darkGrayColor].CGColor; cell.layer.shadowOffset = CGSizeMake(1.f, 1.f); cell.deleteBtn.hidden = NO; [self.editBtn setTitle:@"完成" forState:UIControlStateNormal]; cell.edit = YES; }else{ cell.edit = NO; cell.deleteBtn.hidden = YES; cell.layer.masksToBounds = YES; [self.editBtn setTitle:@"编辑" forState:UIControlStateNormal]; } } } 添加数据,持久化存储刷新界面 -(void)add{ SCLAlertView * alert = [[SCLAlertView alloc]init]; [alert setHorizontalButtons:YES]; SCLTextView * textField = [alert addTextField:@"Enter your name"]; [alert addButton:@"确定" actionBlock:^(void) { NSLog(@"Text value: %@", textField.text); [self.twoArray addObject:textField.text]; [self.collectionView reloadData]; [[NSUserDefaults standardUserDefaults]setObject:self.twoArray forKey:@"two"]; [[NSUserDefaults standardUserDefaults]synchronize]; }]; [alert showEdit:self title:nil subTitle:@"请输入名称" closeButtonTitle:@"取消" duration:0.0f]; 增删移随时保存数据 [[NSUserDefaults standardUserDefaults]setObject:self.oneArray forKey:@"one"]; [[NSUserDefaults standardUserDefaults]setObject:self.twoArray forKey:@"two"]; [[NSUserDefaults standardUserDefaults]synchronize];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[iOS_自定义tarbar和侧边栏]]]></title>
    <url>%2F2017%2F08%2F03%2F%E8%87%AA%E5%AE%9A%E4%B9%89tarbar%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github 地址 pod RESideMenu vim podfile platform :ios,&apos;8.0&apos; target &apos;SideAndTarbar&apos; do pod &apos;RESideMenu&apos;, &apos;~&gt; 4.0.7&apos; AppDelegate.m添加RESideMenuDelegate didFinishLaunchingWithOptions self.window = [[UIWindow alloc]initWithFrame:[[UIScreen mainScreen ]bounds]]; TableViewController * viewController = [[TableViewController alloc]init]; TarBarViewController * barViewController = [[TarBarViewController alloc]init]; RESideMenu * sideMenu = [[RESideMenu alloc]initWithContentViewController:barViewController leftMenuViewController:viewController rightMenuViewController:nil]; sideMenu.delegate = self; sideMenu.contentViewShadowEnabled = YES; sideMenu.contentViewInPortraitOffsetCenterX = 100.f; sideMenu.contentViewScaleValue = 1.0; sideMenu.menuPreferredStatusBarStyle = UIStatusBarStyleLightContent; sideMenu.bouncesHorizontally = NO; self.window.rootViewController = sideMenu; 自定义tabbar 添加子控制器属性 添加navgationbar 去除tabbar分割线 选中controller后图片和标题改变 -(void)addChildViewController:(UIViewController *)childController title:(NSString *)title image:(UIImage *)image selecteImage:(UIImage *)selectedImage{ UINavigationController * controller = [[UINavigationController alloc]initWithRootViewController:childController]; childController.view.backgroundColor = [UIColor whiteColor]; childController.navigationItem.title = title; [[UITabBar appearance] setShadowImage:[UIImage new]]; [[UITabBar appearance] setBackgroundImage:[[UIImage alloc]init]]; selectedImage = [selectedImage imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]; self.tabBar.tintColor = [UIColor greenColor]; controller.tabBarItem = [[UITabBarItem alloc]initWithTitle:title image:image selectedImage:selectedImage]; [self addChildViewController:controller]; } 添加子控制器 -(void)setNewBar{ OneViewController * one = [[OneViewController alloc]init]; [self addChildViewController:one title:@"MainOne" image:[UIImage imageNamed:@"icon_home_normal"] selecteImage:[UIImage imageNamed:@"icon_home_selected"]]; TwoViewController * two = [[TwoViewController alloc]init]; [self addChildViewController:two title:@"MainTwo" image:[UIImage imageNamed:@"icon_door_normal"] selecteImage:[UIImage imageNamed:@"icon_door_selected"]]; } 在各自类中进行操作就OK 例如： self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc]initWithImage:[UIImage imageNamed:@"icon_sidebar"] style:UIBarButtonItemStylePlain target:self action:@selector(presentLeftMenuViewController:)]; UIButton * button = [[UIButton alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; button.backgroundColor = [UIColor greenColor]; [self.view addSubview:button];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo简单操作]]></title>
    <url>%2F2017%2F07%2F25%2FHexo%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks.打开themes/next/source/css/_custom/custom.styl.参考样式:博客地址 /*标题 */ .post-title{ color: red; } /*内容 */ .post-body{ color: green; } /*author */ .author{ text-align: center; color: red; } /*心photo */ .with-love{ color: red; } /*乐乐 */ .theme-link{ color: red; } .busuanzi-value{ color: rebeccapurple; } Next主题操作 生成新页面 hexo g 发布代码 hexo d 开启调试服务 hexo s –debug 为next主题的主页文章添加阴影效果 打开themes/next/source/css/_schemes/Mist/_posts-expanded.styl文件 找到类.posts-expand下面的.post .post { margin-top: 120px; } 改成: .post { margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); } 添加“Fork me on Github” ribbon 打开themes\next\layout\layout.swig &lt;a href=&quot;你的地址&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; left: 0; border: 0;&quot; src=&quot;https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67&quot; alt=&quot;Fork me on GitHub&quot; data-canonical-src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png&quot;&gt;&lt;/a&gt; 404界面 找到根目录-source 创建HTML文件 打开：commonweal: /404.html &lt;html&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;http://www.princesmall.cn&quot; homePageName=&quot;回到乐乐的主页&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注：如果返回的还是qq主页，请参考我网页源码，毕竟有些长，这只是不body。然后copy到你的404.html下 文章末尾追加版权信息 找到themes/next/layout/_macro/reward.swig 在最上面添加如下代码：（最上面） Hexo插入图片 首先确认根目录下_config.yml 中有 post_asset_folder:true 在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image –save 创建文件hexo new “文件名” 在source下会生成一个和文件名一样的文件夹，图片放在该文件夹下 例如： ![logo](文件名/logo.jpg) 是不是so easy！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>