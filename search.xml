<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[iOS_OpenGL环境搭建和图形绘制]]]></title>
    <url>%2F2017%2F08%2F22%2FiOS-OpenGL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks.Dome: github地址 个人觉得OpenGl图形绘制很酷所以专研了一段时间，记录供以后自己使用和小白学习。 环境搭建 创建一个新的工程，点击target-&gt;Build Phases -&gt; Link Binary With Libraries添加库 GLKit.framework OpenGLES.framework 导入 #import 头文件 因为我用GLKBaseEffect绘制的，所以不需要导入更多的头文件 顶点输入一个顶点数组对象会储存以下这些内容： glEnableVertexAttribArray和glDisableVertexAttribArray的调用。 通过glVertexAttribPointer设置的顶点属性配置。 通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。 三角形 float vertices[] = { -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f }; 多边形 typedef struct { GLfloat Positon[3];//位置 GLfloat Color[4];//颜色 } Vertex; 顶点和颜色数组 const Vertex squareVertexData[] = { { 0.5f, 0.5f, -0.9f, 1.0f, 0.0f, 0.0f, 1.0f}, //0 {-0.5f, 0.5f, -0.9f, 0.0f, 1.0f, 0.0f, 1.0f}, //1 { 0.5f, -0.5f, -0.9f, 0.0f, 0.0f, 1.0f, 1.0f}, //2 {-0.5f, -0.5f, -0.9f, 0.0f, 0.0f, 0.0f, 1.0f} //3 }; 三角形数组 const GLubyte Indices[] = { 0, 1, 2, 2, 1, 3 }; 顶点数组对象：Vertex Array Object，VBO 使用glGenBuffers函数和一个缓冲ID生成一个VBO对象：unsigned int VBO;glGenBuffers(1, &amp;VBO); glBindBuffer函数把新创建的缓冲绑定到GL_ARRAY_BUFFER目标上：glBindBuffer(GL_ARRAY_BUFFER, VBO); 我们可以调用glBufferData函数，它会把之前定义的顶点数据复制到缓冲的内存中：glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);glBufferData： 它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上 第二个参数指定传输数据的大小(以字节为单位)；用一个简单的sizeof计算出顶点数据大小就行 第三个参数是我们希望发送的实际数据。 第四个参数指定了我们希望显卡如何管理给定的数据 GL_STATIC_DRAW ：数据不会或几乎不会改变。 GL_DYNAMIC_DRAW：数据会被改变很多。 GL_STREAM_DRAW ：数据每次绘制时都会改变。 现在我们已经把顶点数据储存在显卡的内存中，用VBO这个顶点缓冲对象管理 创建一个VAO和创建一个VBO很类似：unsigned int VAO;glGenVertexArrays(1, &amp;VAO); 要想使用VAO，要做的只是使用glBindVertexArray绑定VAO 绑定VAOglBindVertexArray(VAO); 把顶点数组复制到缓冲中供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); 设置顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 sizeof(float), (void)0);glEnableVertexAttribArray(0); 三角形 GL_ARRAY_BUFFER用于顶点数组 绑定vertexBuffer到GL_ARRAY_BUFFER 给VBO传递数据 取出地址 取出颜色 glVertexAttribPointer的最后一个参数是要获取的参数在GL_ARRAY_BUFFER（每一个Vertex）的偏移量 - (void)setupVBOs{ GLuint verticesBuffer; glGenBuffers(1, &verticesBuffer); glBindBuffer(GL_ARRAY_BUFFER, verticesBuffer); glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW); glEnableVertexAttribArray(GLKVertexAttribPosition); glEnableVertexAttribArray(GLKVertexAttribColor); glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 6, (GLfloat *)NULL + 0); glVertexAttribPointer(GLKVertexAttribColor, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 6, (GLfloat *)NULL + 3); } 多边形 申请一个标识符 把标识符绑定到GL_ARRAY_BUFFER上 把顶点数据从cpu内存复制到gpu内存 开启对应的顶点属性 设置合适的格式从buffer里面读取数据 - (void)setupVBOs{ GLuint buffer; glGenBuffers(1, &buffer); glBindBuffer(GL_ARRAY_BUFFER, buffer); glBufferData(GL_ARRAY_BUFFER, sizeof(squareVertexData), squareVertexData, GL_STATIC_DRAW); GLuint elementBuffer; glGenBuffers(1, &elementBuffer); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBuffer); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW); glEnableVertexAttribArray(GLKVertexAttribPosition); glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), 0); glEnableVertexAttribArray(GLKVertexAttribNormal); glVertexAttribPointer(GLKVertexAttribNormal, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid *) (sizeof(GLfloat) * 3)); glEnableVertexAttribArray(GLKVertexAttribColor); glVertexAttribPointer(GLKVertexAttribColor, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid *) (sizeof(GLfloat) * 6)); glEnableVertexAttribArray(GLKVertexAttribTexCoord0); glVertexAttribPointer(GLKVertexAttribTexCoord0, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid *) (sizeof(GLfloat) * 10)); } GLKViewDelegate 启动着色器 添加背景颜色 绘制图形 -(void)glkView:(GLKView *)view drawInRect:(CGRect)rect { [TLEffect prepareToDraw]; glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glDrawArrays(GL_TRIANGLES, 0, 3); } 在GLKView上绘制OpenGL内容 - (void)setupContext{ context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2]; if (!context) { NSLog(@"Failed to initialize OpenGLES 2.0 context"); exit(1); } [EAGLContext setCurrentContext:context]; GLKView *view = [[GLKView alloc]init]; view.delegate = self; view.frame = self.view.frame; view.context = context; view.drawableColorFormat = GLKViewDrawableColorFormatRGBA8888; if (![EAGLContext setCurrentContext:context]) { NSLog(@"Failed to set current OpenGL context"); exit(1); } [self.view addSubview:view]; }]]></content>
      <categories>
        <category>Ios</category>
      </categories>
      <tags>
        <tag>1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[定时器timer]]]></title>
    <url>%2F2017%2F08%2F18%2F%E5%AE%9A%E6%97%B6%E5%99%A8timer%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github 地址 项目中智能灯有个定时开关的功能，需要在界面上实现时间选择，动画走动然后就写了这个功能实现倒计时 实现准备时间数组： 1. hourArray 存放小时的数组 2. minuteArray 存放分钟的数组 _hourArray = [NSMutableArray array]; for (int i = 0; i < 24; i ++) { [_hourArray addObject:[NSString stringWithFormat:@"%d",i]]; } _minuteArray = [NSMutableArray array]; for (int i = 1; i < 60; i ++) { [_minuteArray addObject:[NSString stringWithFormat:@"%d",i]]; } 宏定义： #define WIN_WIDTH [self.view.bounds.size.width] #define WIN_HEIGHT [self.view.bounds.size.height] #define BACKCOLOR [UIColor colorWithRed:241/255.0 green:241/255.0 blue:241/255.0 alpha:1] #define BARCOLOR [QPUtilities colorWithHexString:@"#242947" alpha:1.f] 全局变量： { BOOL OpenOrClose; dispatch_source_t _timer; int hours; int minites; int secondTotal; int delayTotal; } 时间选择器UIPickView懒加载： -(StellarTimeView *)dateTimeView{ if (_dateTimeView == nil) { _dateTimeView =[[StellarTimeView alloc]initWithFrame:CGRectMake(0, 40, self.dateView.frame.size.width, self.view.bounds.size.height / 2 - 100)]; } return _dateTimeView; } pragma mark – UIPickerViewDateSource - (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView { return 3; } -(NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component { if (component == 0) { return (unsigned)[_hourArray count]; }else if (component == 1){ return 1; }else return (unsigned)[_minuteArray count]; } pragma mark – UIPickerViewDelegate -(CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent:(NSInteger)component { return 60; } -(CGSize)rowSizeForComponent:(NSInteger)component{ CGSize size = CGSizeFromString(@"20"); return size; } -(void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component { if (component == 0) { NSString *_proNameStr = [_hourArray objectAtIndex:(unsigned)row]; hours = [_proNameStr intValue]; }else if (component == 1){ } else { NSString *_proTimeStr = [_minuteArray objectAtIndex:(unsigned)row]; minites = [_proTimeStr intValue]; } } -(NSString*)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component { if (component == 0) { return [_hourArray objectAtIndex:(unsigned)row]; }else if (component == 1){ return @":"; } else { return [_minuteArray objectAtIndex:(unsigned)row]; } } 动画绘制懒加载： -(StellarTimeView *)dateTimeView{ if (_dateTimeView == nil) { _dateTimeView =[[StellarTimeView alloc]initWithFrame:CGRectMake(0, 40, self.dateView.frame.size.width, self.view.bounds.size.height / 2 - 100)]; } return _dateTimeView; } 添加一个navgationbar - (void)setNavigationbar { CGRect screenRect = [[UIScreen mainScreen] bounds]; UINavigationBar *navigationBar = [[UINavigationBar alloc] initWithFrame:CGRectMake(0, 0, screenRect.size.width, 49)]; navigationBar.tintColor = [UIColor blackColor]; navigationBar.backgroundColor = [UIColor greenColor]; //创建 UINavigationItem UINavigationItem * navigationBarTitle = [[UINavigationItem alloc] initWithTitle:@"UINavigationBar"]; [navigationBar pushNavigationItem: navigationBarTitle animated:YES]; [self.view addSubview: navigationBar]; } 注： 动画类已封装只需要传入Percent和progressView定时器的处理- (void)timeHeadle{ if (_timer==nil) { __block int timeout = 0; //倒计时时间 timeout = secondTotal; [self setIsTotalTimeSelect:secondTotal]; if (timeout!=0) { dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue); dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),(uint64_t) 1.0 * NSEC_PER_SEC, 0); //每秒执行 dispatch_source_set_event_handler(_timer, ^{ if(timeout&lt;=0){ //倒计时结束，关闭时界面显示 dispatch_source_cancel(_timer); _timer = nil; dispatch_async(dispatch_get_main_queue(), ^{ [self timeHide]; }); } else{ int hour = (int)(timeout/3600); int minute = (int)(timeout-hour*3600)/60; int second = timeout-hour*3600-minute*60; dispatch_async(dispatch_get_main_queue(), ^{ if (secondTotal == 0) { int total =[self isTotalTimeSelect]; self.dateTimeView.percent = (CGFloat)(total-delayTotal) / total + (CGFloat)(delayTotal- timeout) / total; } else{ self.dateTimeView.percent = (CGFloat)(secondTotal-timeout)/(CGFloat)secondTotal; } if (hour&lt;10) { if (minute&lt;10) { if (second&lt;10) { self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:0%d&quot;,hour,minute,second]; }else{ self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:%d&quot;,hour,minute,second]; } }else { if (second&lt;10) { self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:0%d&quot;,hour,minute,second]; }else{ self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:%d&quot;,hour,minute,second]; } } }else{ if (minute&lt;10) { if (second&lt;10) { self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:0%d&quot;,hour,minute,second]; }else{ self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:%d&quot;,hour,minute,second]; } }else { if (second&lt;10) { self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:0%d&quot;,hour,minute,second]; }else{ self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:%d&quot;,hour,minute,second]; } } } }); timeout--; } }); dispatch_resume(_timer); }else{ self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;00:00:00&quot;]; } } }]]></content>
      <categories>
        <category>Ios</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[增删移]]]></title>
    <url>%2F2017%2F08%2F11%2F%E5%A2%9E%E5%88%A0%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github 地址 今日看到某娱乐项目选择增删移很好玩，周五上午没事就写了一个。 利用CollectionViewCell，将数据持久化保存在infoplist。 再也不怕回到解放前了。主要分[已添加]–[待添加]–[未添加]–[删除添加] CollectionViewCell UIBarButtonItem * rightItem = [[UIBarButtonItem alloc]initWithTitle:@"新增加" style:UIBarButtonItemStylePlain target:self action:@selector(add)]; self.navigationItem.rightBarButtonItem = rightItem; UICollectionViewFlowLayout * layout = [[UICollectionViewFlowLayout alloc]init]; layout.itemSize = CGSizeMake(50, 50); layout.scrollDirection = UICollectionViewScrollDirectionVertical; self.collectionView = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height) collectionViewLayout:layout]; self.collectionView.backgroundColor = [UIColor whiteColor]; self.collectionView.delegate = self; self.collectionView.dataSource = self; [self.collectionView registerNib:[UINib nibWithNibName:@"CollectionViewCell" bundle:nil] forCellWithReuseIdentifier:identifier]; [self.collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:headerId]; 两个数组用来存放已添加的和待添加的 if ([[NSUserDefaults standardUserDefaults]objectForKey:@"one"] == nil) { self.oneArray = [NSMutableArray arrayWithObjects:@"0",@"1",@"2",@"3",@"4",@"5",@"6",@"7",@"8",@"9",@"10",@"11",@"12",@"13",@"14",@"15",@"16",@"17",@"18",@"19",nil]; }else{ id array = [[NSUserDefaults standardUserDefaults]objectForKey:@"one"]; [self.oneArray addObjectsFromArray:array]; } if ( [[NSUserDefaults standardUserDefaults]objectForKey:@"two"] == nil) { self.twoArray = [NSMutableArray arrayWithObjects:@"a",@"b",@"c",@"d",@"e",@"f",@"g",@"h",@"i",@"j", nil]; }else{ id array = [[NSUserDefaults standardUserDefaults]objectForKey:@"two"]; [self.twoArray addObjectsFromArray:array]; } 每次改变后刷新要防止复用 UICollectionReusableView *headerView = [self.collectionView dequeueReusableSupplementaryViewOfKind:kind withReuseIdentifier:headerId forIndexPath:indexPath]; headerView.backgroundColor = [UIColor darkGrayColor]; [headerView.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)]; _titleLab = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width - 50, 40)]; _titleLab.textAlignment = NSTextAlignmentLeft; _titleLab.textColor = [UIColor whiteColor]; [headerView addSubview:self.titleLab]; 编辑状态下进行移动和删除 -(void)edit{ for (CollectionViewCell * cell in self.collectionView.visibleCells) { if (cell.edit == NO) { cell.layer.masksToBounds = NO; cell.layer.shadowOpacity = 0.7f; cell.layer.shadowColor = [UIColor darkGrayColor].CGColor; cell.layer.shadowOffset = CGSizeMake(1.f, 1.f); cell.deleteBtn.hidden = NO; [self.editBtn setTitle:@"完成" forState:UIControlStateNormal]; cell.edit = YES; }else{ cell.edit = NO; cell.deleteBtn.hidden = YES; cell.layer.masksToBounds = YES; [self.editBtn setTitle:@"编辑" forState:UIControlStateNormal]; } } } 添加数据,持久化存储刷新界面 -(void)add{ SCLAlertView * alert = [[SCLAlertView alloc]init]; [alert setHorizontalButtons:YES]; SCLTextView * textField = [alert addTextField:@"Enter your name"]; [alert addButton:@"确定" actionBlock:^(void) { NSLog(@"Text value: %@", textField.text); [self.twoArray addObject:textField.text]; [self.collectionView reloadData]; [[NSUserDefaults standardUserDefaults]setObject:self.twoArray forKey:@"two"]; [[NSUserDefaults standardUserDefaults]synchronize]; }]; [alert showEdit:self title:nil subTitle:@"请输入名称" closeButtonTitle:@"取消" duration:0.0f]; 增删移随时保存数据 [[NSUserDefaults standardUserDefaults]setObject:self.oneArray forKey:@"one"]; [[NSUserDefaults standardUserDefaults]setObject:self.twoArray forKey:@"two"]; [[NSUserDefaults standardUserDefaults]synchronize];]]></content>
      <categories>
        <category>Ios</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[自定义tarbar]]]></title>
    <url>%2F2017%2F08%2F03%2F%E8%87%AA%E5%AE%9A%E4%B9%89tarbar%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github 地址 pod RESideMenu vim podfile platform :ios,&apos;8.0&apos; target &apos;SideAndTarbar&apos; do pod &apos;RESideMenu&apos;, &apos;~&gt; 4.0.7&apos; AppDelegate.m添加RESideMenuDelegate didFinishLaunchingWithOptions self.window = [[UIWindow alloc]initWithFrame:[[UIScreen mainScreen ]bounds]]; TableViewController * viewController = [[TableViewController alloc]init]; TarBarViewController * barViewController = [[TarBarViewController alloc]init]; RESideMenu * sideMenu = [[RESideMenu alloc]initWithContentViewController:barViewController leftMenuViewController:viewController rightMenuViewController:nil]; sideMenu.delegate = self; sideMenu.contentViewShadowEnabled = YES; sideMenu.contentViewInPortraitOffsetCenterX = 100.f; sideMenu.contentViewScaleValue = 1.0; sideMenu.menuPreferredStatusBarStyle = UIStatusBarStyleLightContent; sideMenu.bouncesHorizontally = NO; self.window.rootViewController = sideMenu; 自定义tabbar 添加子控制器属性 添加navgationbar 去除tabbar分割线 选中controller后图片和标题改变 -(void)addChildViewController:(UIViewController *)childController title:(NSString *)title image:(UIImage *)image selecteImage:(UIImage *)selectedImage{ UINavigationController * controller = [[UINavigationController alloc]initWithRootViewController:childController]; childController.view.backgroundColor = [UIColor whiteColor]; childController.navigationItem.title = title; [[UITabBar appearance] setShadowImage:[UIImage new]]; [[UITabBar appearance] setBackgroundImage:[[UIImage alloc]init]]; selectedImage = [selectedImage imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]; self.tabBar.tintColor = [UIColor greenColor]; controller.tabBarItem = [[UITabBarItem alloc]initWithTitle:title image:image selectedImage:selectedImage]; [self addChildViewController:controller]; } 添加子控制器 -(void)setNewBar{ OneViewController * one = [[OneViewController alloc]init]; [self addChildViewController:one title:@"MainOne" image:[UIImage imageNamed:@"icon_home_normal"] selecteImage:[UIImage imageNamed:@"icon_home_selected"]]; TwoViewController * two = [[TwoViewController alloc]init]; [self addChildViewController:two title:@"MainTwo" image:[UIImage imageNamed:@"icon_door_normal"] selecteImage:[UIImage imageNamed:@"icon_door_selected"]]; } 在各自类中进行操作就OK 例如： self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc]initWithImage:[UIImage imageNamed:@"icon_sidebar"] style:UIBarButtonItemStylePlain target:self action:@selector(presentLeftMenuViewController:)]; UIButton * button = [[UIButton alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; button.backgroundColor = [UIColor greenColor]; [self.view addSubview:button];]]></content>
      <categories>
        <category>Ios</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo简单操作]]></title>
    <url>%2F2017%2F07%2F25%2FHexo%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks.打开themes/next/source/css/_custom/custom.styl.参考样式:博客地址 /*标题 */ .post-title{ color: red; } /*内容 */ .post-body{ color: green; } /*author */ .author{ text-align: center; color: red; } /*心photo */ .with-love{ color: red; } /*乐乐 */ .theme-link{ color: red; } .busuanzi-value{ color: rebeccapurple; } Next主题操作 生成新页面 hexo g 发布代码 hexo d 开启调试服务 hexo s –debug 为next主题的主页文章添加阴影效果 打开themes/next/source/css/_schemes/Mist/_posts-expanded.styl文件 找到类.posts-expand下面的.post .post { margin-top: 120px; } 改成: .post { margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); } 添加“Fork me on Github” ribbon 打开themes\next\layout\layout.swig &lt;a href=&quot;你的地址&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; left: 0; border: 0;&quot; src=&quot;https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67&quot; alt=&quot;Fork me on GitHub&quot; data-canonical-src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png&quot;&gt;&lt;/a&gt; 404界面 找到根目录-source 创建HTML文件 打开：commonweal: /404.html &lt;html&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;http://www.princesmall.cn&quot; homePageName=&quot;回到乐乐的主页&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注：如果返回的还是qq主页，请参考我网页源码，毕竟有些长，这只是不body。然后copy到你的404.html下 文章末尾追加版权信息 找到themes/next/layout/_macro/reward.swig 在最上面添加如下代码：（最上面） Hexo插入图片 首先确认根目录下_config.yml 中有 post_asset_folder:true 在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image –save 创建文件hexo new “文件名” 在source下会生成一个和文件名一样的文件夹，图片放在该文件夹下 例如： ![logo](文件名/logo.jpg) 是不是so easy！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>