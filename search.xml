<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[[Animation_keyFrameAnimation]]]></title>
      <url>/2017/11/17/Animation-keyFrameAnimation/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/Full-animation-details" target="_blank" rel="external">github地址</a></p>
<p>CAPropertyAnimation 的子类有CABsicAnimation 和 CAKeyframeAnimation。<br>今天要说的就是CAKeyframeAnimation关键帧动画，毫无疑问一切复杂的动画都是由简单的动画拼接来的，知其所以然，需要的时候必定能写出好的动画</p>
<h3 id="keyFrameAnimation"><a href="#keyFrameAnimation" class="headerlink" title="keyFrameAnimation"></a>keyFrameAnimation</h3><h4 id="属性值了解"><a href="#属性值了解" class="headerlink" title="属性值了解"></a>属性值了解</h4><p>1、关键帧值数组,一组变化值</p>
<pre><code>@property(nullable, copy) NSArray *values;
</code></pre><p>2、关键帧帧路径,优先级比values大</p>
<pre><code>@property(nullable) CGPathRef path;
</code></pre><p>3、每一帧对应的时间,时间可以控制速度.它和每一个帧相对应,取值为0.0-1.0,不设则每一帧时间相等.</p>
<pre><code>@property(nullable, copy) NSArray *keyTimes;
</code></pre><p>4、每一帧对应的时间曲线函数,也就是每一帧的运动节奏</p>
<pre><code>@property(nullable, copy) NSArray *timingFunctions;
</code></pre><p>5、动画的计算模式,默认值: kCAAnimationLinear.有以下几个值:</p>
<pre><code>@property(copy) NSString *calculationMode;

kCAAnimationLinear
关键帧为座标点的时候,关键帧之间直接直线相连进行插值计算;

kCAAnimationDiscrete
离散的,也就是没有补间动画

kCAAnimationPaced
平均，keyTimes跟timeFunctions失效

kCAAnimationCubic
对关键帧为座标点的关键帧进行圆滑曲线相连后插值计算,对于曲线的形状还可以通过tensionValues,continuityValues,biasValues来进行调整自定义,keyTimes跟timeFunctions失效

kCAAnimationCubicPaced
在kCAAnimationCubic的基础上使得动画运行变得均匀,就是系统时间内运动的距离相同,,keyTimes跟timeFunctions失效
</code></pre><p>6、动画的张力,当动画为立方计算模式的时候此属性提供了控制插值,因为每个关键帧都可能有张力所以连续性会有所偏差它的范围为[-1,1].同样是此作用</p>
<pre><code>@property(nullable, copy) NSArray *tensionValues;
</code></pre><p>7、动画的连续性值</p>
<pre><code>@property(nullable, copy) NSArray *continuityValues;
</code></pre><p>8、动画的偏斜率</p>
<pre><code>@property(nullable, copy) NSArray *biasValues;
</code></pre><p>9、动画沿路径旋转方式,默认为nil.它有两个值:</p>
<pre><code>@property(nullable, copy) NSString *rotationMode;
kCAAnimationRotateAuto
自动旋转
kCAAnimationRotateAutoReverse
自动翻转
</code></pre><h4 id="动画应用"><a href="#动画应用" class="headerlink" title="动画应用"></a>动画应用</h4><p>draw  a curve</p>
<pre><code>keyFrame：
path：路径
duration：单次时间
rotationMode：旋转样式
repeatCount：重复次数
</code></pre><p>1、弧形</p>
<pre><code>- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise ;
center ： 弧形的中心
radius： 弧形的半径
startAngle：弧形开始弧度
endAngle：弧形结束弧度
colockwise：顺逆时针
</code></pre><p>2、抛物线</p>
<pre><code>- (void)moveToPoint:(CGPoint)point
- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint;
point：开始位置
endPoint：结束位置
controlPoint：拐点位置
</code></pre><p>3、椭圆形</p>
<pre><code>+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect;
rect： x起点
       y起点
       width宽度
       height高度
</code></pre><p>4、圆形</p>
<pre><code>rect：
width = height
</code></pre>]]></content>
      
        <categories>
            
            <category> Animation </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Animation_SpringAnimation]]]></title>
      <url>/2017/11/16/Animation-SpringAnimation/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/Full-animation-details" target="_blank" rel="external">github地址</a></p>
<p>昨天整理了BasicAnimation，昨晚对SpringAnimation也进行了梳理。说白了，它的父类也是BasicAnimation，也增加了UIView 实例方法的应用</p>
<h3 id="SpringAnimation"><a href="#SpringAnimation" class="headerlink" title="SpringAnimation"></a>SpringAnimation</h3><p>1、</p>
<pre><code>mass:

质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大

动画的速度变慢，并且波动幅度变大
</code></pre><p>2、 </p>
<pre><code>stiffness:

刚度系数(劲度系数/弹性系数)，刚度系数越大，形变产生的力就越大，运动越快
</code></pre><p>3、</p>
<pre><code>damping:

阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快
</code></pre><p>4、</p>
<pre><code>initialVelocity:

初始速率，动画视图的初始速度大小

速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反
</code></pre><p>5、</p>
<pre><code>CASpringAnimation * springAnimation = [CASpringAnimation animationWithKeyPath:@&quot;position&quot;];
springAnimation.damping = damping;
springAnimation.stiffness = stiffness;
springAnimation.mass = mass;
springAnimation.initialVelocity = initialVelocity;
springAnimation.toValue = [NSValue valueWithCGSize:CGSizeMake(self.redView.layer.position.x, self.redView.layer.position.y + 200)];
springAnimation.duration = springAnimation.settlingDuration;
[self.redView.layer addAnimation:springAnimation forKey:springAnimation.keyPath];
</code></pre><p>6、</p>
<pre><code> [UIView animateWithDuration:5 delay:0 usingSpringWithDamping:0.3 initialSpringVelocity:10 options:UIViewAnimationOptionTransitionFlipFromRight animations:^{
        CGPoint point =self.redView.center;
        point.y += 150;
        [self.redView setCenter:point];
    } completion:^(BOOL finished) {
        [self.redView setCenter:CGPointMake(250 + 49, 250 + 49)];
        [self.redView setBackgroundColor:[UIColor redColor]];
    }];
}     
      duration: 动画时长
      delay: 动画延迟
      damping: 弹簧效果
      springVelocity: 初始速度
      options: 过度效果
</code></pre>]]></content>
      
        <categories>
            
            <category> Animation </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Animation_BasicAnimation]]]></title>
      <url>/2017/11/15/Animation-BasicAnimation/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/Full-animation-details" target="_blank" rel="external">github地址</a></p>
<p>由于下班的时候出了事故，导致卧病休息了一个月左右，天天根本没时间更新博客，觉得没有记录就没有进步，很难过。好歹前段时间完成了公司的任务，现在有时间整理点东西。关于Animation明天会陆续整理出来，今天就是最简单的BasicAnimation。</p>
<h3 id="BasicAnimation"><a href="#BasicAnimation" class="headerlink" title="BasicAnimation"></a>BasicAnimation</h3><p><img src="/2017/11/15/Animation-BasicAnimation/Animation.gif" alt="animation"></p>
<p>1、keyPath</p>
<pre><code>rotation 旋轉

scale 缩放

translation 平移

CGPoint Key Paths : (example)position.x 位移

CGRect Key Paths : (example)bounds.size.width 伸缩

origin 原点

size 大小

opacity 透明度

backgroundColor  背景 颜色

contents  内容

Shadow Key Path: 阴影
</code></pre><p>2、</p>
<pre><code>duration：动画的持续时间
</code></pre><p>3、<br>　　<pre>repeatCount：动画的重复次数</pre></p>
<p>4、<br>　　<pre>timingFunction：动画的时间节奏控制</pre></p>
<p>5、Use</p>
<pre><code>    case 0:
        animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.x&quot;];
        //setFromValue不设置,默认以当前状态为准
        [animation setToValue:@(2 * M_PI)];
        break;
    case 1:
        animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.y&quot;];
        //setFromValue不设置,默认以当前状态为准
        [animation setToValue:@(2 * M_PI)];
        break;
    case 2:
        animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];
        //setFromValue不设置,默认以当前状态为准
        [animation setToValue:@(2 * M_PI)];
        break;
    case 3:
        //平移
        animation = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;];
        //setFromValue不设置,默认以当前状态为准
        [animation setToValue:[NSValue valueWithCGPoint:CGPointMake(self.redView.center.x, self.redView.center.y + 200)]];
        break;
    case 4:
        animation = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];
        [animation setFromValue:@1.0];
        [animation setToValue:@0.1];
        break;
    case 5:
        animation = [CABasicAnimation animationWithKeyPath:@&quot;backgroundColor&quot;];
        animation.fromValue = (__bridge id _Nullable)([UIColor redColor].CGColor);
        animation.toValue = (__bridge id _Nullable)([UIColor greenColor].CGColor);

        break;
    case 6:
        animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;];
        [animation setFromValue:@1.0];
        [animation setToValue:@0.1];
        break;
    case 7:
        animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale.x&quot;];
        [animation setFromValue:@1.0];
        [animation setToValue:@0.1];
        break;
    case 8:
        animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale.y&quot;];
        [animation setFromValue:@1.0];
        [animation setToValue:@0.1];
        break;
    case 9:
        animation = [CABasicAnimation animationWithKeyPath:@&quot;bounds&quot;];
        [animation setToValue:[NSValue valueWithCGRect:CGRectMake(self.redView.frame.origin.x, self.redView.frame.origin.y, 200, 200)]];
        break;

    default:
        break;
}
[animation setDelegate:self];//代理回调
[animation setDuration:1];//设置动画时间，单次动画时间
[animation setRemovedOnCompletion:NO];//默认为YES,设置为NO时setFillMode有效
[animation setTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]];
[animation setAutoreverses:YES];
[animation setFillMode:kCAFillModeBoth];
[self.redView.layer addAnimation:animation forKey:@&quot;basicAnimation&quot;];
</code></pre>]]></content>
      
        <categories>
            
            <category> Animation </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[iOS_零碎知识点整理]]]></title>
      <url>/2017/09/30/iOS-%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>明天就十一，项目也告一段路，今天就把以前的零碎知识点整理下，备忘录好几页找都不好找了</p>
<h3 id="iOS中属性-property的常用关键字"><a href="#iOS中属性-property的常用关键字" class="headerlink" title="iOS中属性@property的常用关键字"></a>iOS中属性@property的常用关键字</h3><p>strong，weak，assign，copy，nonatomic，retain ，atomic….</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>解析</th>
</tr>
</thead>
<tbody>
<tr>
<td>strong</td>
<td>释放旧对象，将旧对象的值赋予输入对象，输入对象的索引计数加1</td>
</tr>
<tr>
<td>weak</td>
<td>不增加引用计数，不持有对象，因此也不能决定对象释放</td>
</tr>
<tr>
<td>assign</td>
<td>适用于基础数据类型（NSInteger CGFloat…），不增加引用计数</td>
</tr>
<tr>
<td>copy</td>
<td>建立一个索引计数为1 的对象然后释放旧对象，此属性只对那些实行了NSCopying协议的对象类型有效（NSString , Block）</td>
</tr>
<tr>
<td>nonatomic</td>
<td>非原子性访问对于属性赋值的时候不加锁，多线程并发访问会提高性能，如果不加此属性则默认是两个访问方法都为原子型事务访问</td>
</tr>
<tr>
<td>retain</td>
<td>对象的引用计数+1。ARC下已经不再使用此关键字，用strong代替</td>
</tr>
<tr>
<td>atomic</td>
<td>和 nonatomic用来决定编译器生成的getter和setter是否为原子操作，atomic设置成员变量的@property属性时  默认为是atomic 提供线程安全</td>
</tr>
<tr>
<td>unsafe_unretained</td>
<td>跟weak类似，声明一个弱引用，但是当引用计数为0时，变量不会自动设置为nil</td>
</tr>
</tbody>
</table>
<h4 id="ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"><a href="#ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？" class="headerlink" title="ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"></a>ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h4><p>strong, atomic, readwrite</p>
<h4 id="copy-和-strong"><a href="#copy-和-strong" class="headerlink" title="copy 和 strong"></a>copy 和 strong</h4><p>（1）因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.<br>（2）如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性</p>
<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>Class 是一个 objc_class 结构类型的指针；而 id（任意对象） 是一个 objc_object 结构类型的指针<br>struct objc_class</p>
<pre>
{
    struct objc_class* isa;
    struct objc_class* super_class;
    const char* name;
    long version;
    long info;
    long instance_size;
    struct objc_ivar_list* ivars;
    struct objc_method_list** methodLists;
    struct objc_cache* cache;
    struct objc_protocol_list* protocols;
};
</pre>

<ol>
<li><p>（1）isa：对象的isa指向类（class），类的isa指向元类（meta class），元类isa指向元类的根类（root meteClass）。isa 帮助一个对象找到它的方法</p>
</li>
<li><p>（2）super_class：指向该类的父类！如果该类已经是最顶层的根类，如 NSObject 或 NSProxy），那么 super_class 就为 NULL。</p>
</li>
<li><p>（3）name：一个 C 字符串，指示类的名称。</p>
</li>
<li><p>（4）version：类的版本信息，默认初始化为 0。我们可以在运行期对其进行修改（class_setVersion）或获取</p>
</li>
<li>（5）info：供运行期使用的一些位标识。有如下一些位掩码：<br>CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含实例方法和变量；<br>CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法；<br>CLS_INITIALIZED (0x4L) 表示该类已经被运行期初始化了，这个标识位只被 objc_addClass 所设置；<br>CLS_POSING (0x8L) 表示该类被 pose 成其他的类；（poseclass 在ObjC 2.0中被废弃了）；<br>CLS_MAPPED (0x10L) 为ObjC运行期所使用<br>CLS_FLUSH_CACHE (0x20L) 为ObjC运行期所使用<br>CLS_GROW_CACHE (0x40L) 为ObjC运行期所使用<br>CLS_NEED_BIND (0x80L) 为ObjC运行期所使用<br>CLS_METHOD_ARRAY (0x100L) 该标志位指示 methodlists 是指向一个 objc_method_list 还是一个包含 objc_method_list 指针的数组；</li>
<li>（6）instance_size：该类的实例变量大小（包括从父类继承下来的实例变量）。</li>
<li>（7）ivars：指向 objc_ivar_list 的指针，存储每个实例变量的内存地址，如果该类没有任何实例变量则为 NULL；</li>
<li>（8）methodLists：与 info 的一些标志位有关，CLS_METHOD_ARRAY 标识位决定其指向的东西（是指向单个 objc_method_list还是一个 objc_method_list 指针数组），如果 info 设置了 CLS_CLASS 则 objc_method_list  存储实例方法，如果设置的是 CLS_META 则存储类方法；</li>
<li>（9）cache：指向 objc_cache 的指针，用来缓存最近使用的方法，以提高效率。</li>
<li>（10）protocols：指向 objc_protocol_list 的指针，存储该类声明要遵守的正式协议。</li>
</ol>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p>IMP本质上就是一个函数指针，指向方法的实现，在objc.h找到它的定义<br>typedef void (<em>IMP)(void /</em> id, SEL, … */ );</p>
<p>#else<br>typedef id (*IMP)(id, SEL, …);</p>
<p>#endif</p>
<h4 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h4><p>objc_msgSend它具体是如何发送消息：<br>首先根据receiver对象的isa指针获取它对应的class；<br>优先在class的cache查找message方法，如果找不到，再到methodLists查找；<br>如果没有在class找到，再到super_class查找；<br>一旦找到message这个方法，就执行它实现的IMP。<br>注：当objc_msgSend找不到实现的IMP时，程序并不会直接崩溃，而是给开发者一个plan b：方法决议与消息转发</p>
<h3 id="iOS的一些小技巧"><a href="#iOS的一些小技巧" class="headerlink" title="iOS的一些小技巧"></a>iOS的一些小技巧</h3><h4 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h4><ol>
<li><p>设置UILable行间距</p>
<pre><code>NSMutableAttributedString* attrString = [[NSMutableAttributedString  alloc] initWithString:label.text];

NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];

[style setLineSpacing:20];

[attrString addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, label.text.length)];

label.attributedText = attrString;
</code></pre></li>
<li><p>UILabel显示不同颜色字体</p>
<pre><code>NSMutableAttributedString * string = [[NSMutableAttributedString alloc] initWithString:label.text];

[string addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0,5)];

[string addAttribute:NSForegroundColorAttributeName value:[UIColor greenColor] range:NSMakeRange(5,6)];

[string addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(11,5)];

label.attributedText = string;
</code></pre></li>
<li><p>动画修改label上的文字</p>
<pre><code>方法一
CATransition * animation = [CATransition animation];
animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
animation.type = kCATransitionFade;
animation.duration = 0.75;
[self.label.layer addAnimation:animation forKey:@&quot;kCATransitionFade&quot;];
self.label.text = @&quot;New&quot;;

方法二
[UIView transitionWithView:self.label
              duration:0.25f
               options:UIViewAnimationOptionTransitionCrossDissolve
            animations:^{
                self.label.text = @&quot;Well done!&quot;;
            } completion:nil];

 方法三
 [UIView animateWithDuration:1.0
             animations:^{
                 self.label.alpha = 0.0f;
                 self.label.text = @&quot;newText&quot;;
                 self.label.alpha = 1.0f;
             }];
</code></pre></li>
</ol>
<ol>
<li><p>播放一张张连续的图片</p>
<pre><code>加入现在有三张图片分别为animate_1、animate_2、animate_3
方法一：
imageView.animationImages = @[[UIImage imageNamed:@&quot;animate_1&quot;], [UIImage imageNamed:@&quot;animate_2&quot;], [UIImage imageNamed:@&quot;animate_3&quot;]];
imageView.animationDuration = 1.0;
方法二：
imageView.image = [UIImage animatedImageNamed:@&quot;animate_&quot; duration:1.0];
方法二解释下：
这个方法会加载animate_为前缀的，后边0-1024，也就是animate_0、animate_1一直到animate_1024
</code></pre></li>
<li><p>修改UISearBar内部背景颜色</p>
<pre><code>UITextField *textField = [_searchBar valueForKey:@&quot;_searchField&quot;];
textField.backgroundColor = [UIColor redColor];
</code></pre></li>
<li><p>监听UISlider拖动状态</p>
<pre><code>[slider addTarget:self action:@selector(sliderValurChanged:forEvent:) forControlEvents:UIControlEventValueChanged];

 - (void)sliderValurChanged:(UISlider*)slider forEvent:(UIEvent*)event {
   UITouch *touchEvent = [[event allTouches] anyObject];
   switch (touchEvent.phase) {
       case UITouchPhaseBegan:
            NSLog(@&quot;开始拖动&quot;);
            break;
       case UITouchPhaseMoved:
            NSLog(@&quot;正在拖动&quot;);
            break;
       case UITouchPhaseEnded:
            NSLog(@&quot;结束拖动&quot;);
            break;
       default:
            break;
      }
  }
</code></pre></li>
</ol>
<h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><ol>
<li><p>MD5加密</p>
<pre><code>+ (NSString *)md5:(NSString *)str
{
   const char *concat_str = [str UTF8String];
   unsigned char result[CC_MD5_DIGEST_LENGTH];
   CC_MD5(concat_str, (unsigned int)strlen(concat_str), result);
   NSMutableString *hash = [NSMutableString string];
   for (int i =0; i&lt;16; i++){
      [hash appendFormat:@&quot;X&quot;, result[i]];
   }
   return [hash uppercaseString];
}
</code></pre></li>
<li><p>base64加密       </p>
<pre><code>@interface NSData (Base64)
/**
 *  @brief  字符串base64后转data
 */
+ (NSData *)dataWithBase64EncodedString:(NSString *)string
{
  if (![string length]) return nil;
  NSData *decoded = nil;
#if __MAC_OS_X_VERSION_MIN_REQUIRED &lt; __MAC_10_9 || __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_7_0
 if (![NSData instancesRespondToSelector:@selector(initWithBase64EncodedString:options:)])
 {
#pragma clang diagnostic push
#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;
decoded = [[self alloc] initWithBase64Encoding:[string stringByReplacingOccurrencesOfString:@&quot;[^A-Za-z0-9+/=]&quot; withString:@&quot;&quot; options:NSRegularExpressionSearch range:NSMakeRange(0, [string length])]];
#pragma clang diagnostic pop
 }
else
#endif
{
decoded = [[self alloc] initWithBase64EncodedString:string options:NSDataBase64DecodingIgnoreUnknownCharacters];
}
return [decoded length]? decoded: nil;
}
/**
  *  @brief  NSData转string
  *  @param wrapWidth 换行长度  76  64
  */
- (NSString *)base64EncodedStringWithWrapWidth:(NSUInteger)wrapWidth
{
   if (![self length]) return nil;
   NSString *encoded = nil;
  #if __MAC_OS_X_VERSION_MIN_REQUIRED &lt; __MAC_10_9 || __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_7_0
   if (![NSData instancesRespondToSelector:@selector(base64EncodedStringWithOptions:)])
   {
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;
encoded = [self base64Encoding];
#pragma clang diagnostic pop

 }
else
#endif
{
switch (wrapWidth)
{
    case 64:
    {
        return [self base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];
    }
    case 76:
    {
        return [self base64EncodedStringWithOptions:NSDataBase64Encoding76CharacterLineLength];
    }
    default:
    {
        encoded = [self base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)0];
    }
}
 }
if (!wrapWidth || wrapWidth &gt;= [encoded length])
{
   return encoded;
 }
 wrapWidth = (wrapWidth / 4) * 4;
 NSMutableString *result = [NSMutableString string];
   for (NSUInteger i = 0; i &lt; [encoded length]; i+= wrapWidth)
 {
if (i + wrapWidth &gt;= [encoded length])
{
    [result appendString:[encoded substringFromIndex:i]];
    break;
}
[result appendString:[encoded substringWithRange:NSMakeRange(i, wrapWidth)]];
[result appendString:@&quot;\r\n&quot;];
  }
  return result;
 }
/**
  *  @brief  NSData转string 换行长度默认64
  */
 - (NSString *)base64EncodedString
 {
      return [self base64EncodedStringWithWrapWidth:0];
 }
</code></pre></li>
<li><p>3DES加密</p>
<pre><code>#import
@interface NSData (3DES)
/**
  *  利用3DES加密数据
  */
- (NSData*)encryptedWith3DESUsingKey:(NSString*)key andIV:(NSData*)iv {

      NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];

      size_t dataMoved;
      NSMutableData *encryptedData = [NSMutableData dataWithLength:self.length + kCCBlockSize3DES];

      CCCryptorStatus result = CCCrypt(kCCEncrypt,kCCAlgorithm3DES,kCCOptionPKCS7Padding,keyData.bytes,keyData.length,iv.bytes,self.bytes,self.length,encryptedData.mutableBytes,encryptedData.length,&amp;dataMoved);

     if (result == kCCSuccess) {
encryptedData.length = dataMoved;
return encryptedData;
        }

    return nil;

 }
/**
  *  @brief   利用3DES解密数据
  */
- (NSData*)decryptedWith3DESUsingKey:(NSString*)key andIV:(NSData*)iv {

   NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];

  size_t dataMoved;
  NSMutableData *decryptedData = [NSMutableData dataWithLength:self.length + kCCBlockSize3DES];

  CCCryptorStatus result = CCCrypt(kCCDecrypt,kCCAlgorithm3DES,kCCOptionPKCS7Padding,keyData.bytes,keyData.length,iv.bytes,self.bytes,self.length,decryptedData.mutableBytes,decryptedData.length,&amp;dataMoved);

 if (result == kCCSuccess) {
      decryptedData.length = dataMoved;
      return decryptedData;
    }

   return nil;

}
</code></pre></li>
</ol>
<h4 id="零碎知识点"><a href="#零碎知识点" class="headerlink" title="零碎知识点"></a>零碎知识点</h4><ol>
<li><p>页面跳转实现翻转动画</p>
<pre><code>modal方式
TestViewController *vc = [[TestViewController alloc] init];
vc.view.backgroundColor = [UIColor redColor];
vc.modalTransitionStyle = UIModalTransitionStyleCoverVertical;
[self presentViewController:vc animated:YES completion:nil];

push方式:
TestViewController *vc = [[TestViewController alloc] init];
vc.view.backgroundColor = [UIColor redColor];
[UIView beginAnimations:@&quot;View Flip&quot; context:nil];
[UIView setAnimationDuration:0.80];
[UIView setAnimationCurve:UIViewAnimationCurveEaseInOut];
[UIView setAnimationTransition:UIViewAnimationTransitionFlipFromRight forView:self.navigationController.view cache:NO];
[self.navigationController pushViewController:vc animated:YES];
[UIView commitAnimations];
</code></pre></li>
<li><p>多网络请求：</p>
<pre><code>dispatch_group_t group = dispatch_group_create();
dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.wzb.test.www&quot;, DISPATCH_QUEUE_SERIAL);
dispatch_group_enter(group);
dispatch_group_async(group, serialQueue, ^{
// 网络请求一
[WebClick getDataSuccess:^(ResponseModel *model) {
    dispatch_group_leave(group);
} failure:^(NSString *err) {
    dispatch_group_leave(group);
}];
});
dispatch_group_enter(group);
  dispatch_group_async(group, serialQueue, ^{
// 网络请求二
[WebClick getDataSuccess:getBigTypeRM onSuccess:^(ResponseModel *model) {
    dispatch_group_leave(group);
}                                  failure:^(NSString *errorString) {
    dispatch_group_leave(group);
}];
});
dispatch_group_enter(group);
dispatch_group_async(group, serialQueue, ^{
// 网络请求三
[WebClick getDataSuccess:^{
    dispatch_group_leave(group);
} failure:^(NSString *errorString) {
    dispatch_group_leave(group);
}];
});

// 所有网络请求结束后会来到这个方法
dispatch_group_notify(group, serialQueue, ^{
dispatch_async(dispatch_get_global_queue(0, 0), ^{
    dispatch_async(dispatch_get_main_queue(), ^{
        // 刷新UI
    });
});
});
</code></pre></li>
<li><p>监听scrollView是否滚动到了顶部／底部</p>
<pre><code>-(void)scrollViewDidScroll: (UIScrollView*)scrollView
 {
   float scrollViewHeight = scrollView.frame.size.height;
   float scrollContentSizeHeight = scrollView.contentSize.height;
   float scrollOffset = scrollView.contentOffset.y;

   if (scrollOffset == 0)
    {
// 滚动到了顶部
    }
   else if (scrollOffset + scrollViewHeight ==  scrollContentSizeHeight)
    {
// 滚动到了底部
    }
  }
</code></pre></li>
<li><p>过滤空格</p>
</li>
</ol>
<pre><code>-(NSString *)userName:(NSString *)name{

name = [name stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];//前后空格

name = [name stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];//中间空格
return name;
}
</code></pre><ol>
<li><p>获取邮箱用户部分和域名部分</p>
<pre><code>- (BOOL)validateEmail:(NSString *)email {
    if ((0 != [email rangeOfString:@&quot;@&quot;].length) &amp;&amp;
        (0 != [email rangeOfString:@&quot;.&quot;].length)) {
         NSCharacterSet *tmpInvalidCharSet =
[[NSCharacterSet alphanumericCharacterSet] invertedSet];
        NSMutableCharacterSet *tmpInvalidMutableCharSet =
[tmpInvalidCharSet mutableCopy];
        [tmpInvalidMutableCharSet removeCharactersInString:@&quot;_-&quot;];

         NSRange range1 = [email rangeOfString:@&quot;@&quot; options:NSCaseInsensitiveSearch];

//取得用户名部分
NSString *userNameString = [email substringToIndex:range1.location];
NSLog(@&quot;length---%ld&quot;,userNameString.length);
if (userNameString.length &lt; 1 || userNameString.length &gt; 20) {
    return NO;
}else
//取得域名部分
NSString *domainString = [email substringFromIndex:range1.location + 1];
NSArray *domainArray = [domainString componentsSeparatedByString:@&quot;.&quot;];

for (NSString *string in domainArray) {
    NSRange rangeOfInavlidChars =
    [string rangeOfCharacterFromSet:tmpInvalidMutableCharSet];
    if (rangeOfInavlidChars.length != 0 || [string isEqualToString:@&quot;&quot;])
        return NO;
}

return YES;
} else {
return NO;
       }
}
</code></pre></li>
</ol>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[iOS_正则表达式]]]></title>
      <url>/2017/09/25/iOS-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>新的项目用户名、邮箱和密码等要用到正则，所以就把以前整理的拿出来用了，不要太方便，索性就打个flag吧。嗯，我以前笔记做的还是比较清楚的</p>
<p>  正则表达式记录表</p>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><pre><code>1、 \b : 单词的开始或结束

2、 .* : 任意数量的不包含换行的字符
    .  : 匹配除换行符以外的任意字符 

3、 \d : 是新的元字符，匹配一位数字
  \d{n} : 必须连续重复匹配n次

4、 \s : 匹配任意的空白符（空格，制表格，换行符，中文全角空格等）

5、 \w : 匹配字母或者数字或者下划线或者汉字等

6、  ^  : 匹配字符串的开始
    ￥  : 匹配字符串的结束
</code></pre><p> 注意：</p>
<pre><code>* 字符转义

如果你想查找元字符本身，比如.和* ，这时候你就应该使用\.和\*
</code></pre><h4 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h4><pre><code>    代码       |     说明      
------------- | -------------
   *          |   重复零次或更多次
   +          |   重复一次或更多次
   ?          |   重复零次或一次
   {n}        |   重复n次
   {n,}       |   重复n次或更多次
   {n,m}      |   重复n到m次
</code></pre><p>注意：</p>
<pre><code>*字符类

如果想匹配没有预定义的元字符集合，比如a，e，o。这时候你就要[aeo]就匹配任何一个英文元音的字母。[.?!]匹配任意一个标点符号
</code></pre><h3 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h3><ol>
<li><p>满足任意一种规则都应该当成匹配，用 | 把不同的规则分割开来</p>
<pre><code>0\d{2}-\d{8}|0\d{3}-\d{7} 这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)

 \(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔
</code></pre></li>
<li><p>使用分枝条件时，要注意个分枝的顺序</p>
<pre><code>\d{5}-\d{4}|\d{5} 换成 \d{5}|\d{5}-\d{4}，那么就只会匹配5位的邮编。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了
</code></pre></li>
<li><p>重复多个字符，使用分组</p>
<pre><code>(\d{1,3}\.){3}\d{1,3}是一个简单的IP地址匹配表达式

(\d{1,3}\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})

不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址

((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。解析正确IP：01-09,0-255
1. 2[0-4]\d :（200-249)
2. 25[0-5] :(250-255)
3. [01]?\d\d? : (01-09,0-199)
</code></pre></li>
</ol>
<h3 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h3><pre><code>   代码        |语法
--------------|-------------------      
    \W        |匹配任意不是字母，数字，下划线，汉字的字符
    \S        |匹配任意不是空白符的字符
    \D        |匹配任意非数字的字符
    \B        |匹配不是单词开头或结束的位置
    [^x]      |匹配除了x以外的任意字符
    [^aeiou]  |匹配除了aeiou这几个字母以外的任意字符

例如： 

 \S+匹配不包含空白符的字符串。

 &lt;a[^&gt;]+&gt;匹配用尖括号括起来的以a开头的字符串
</code></pre><h3 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h3><p>常用分组语法</p>
<pre><code>       分类 |代码/语法     |说明
-----------|-------------|-----------------
  捕获      |  (exp)      |匹配exp,并捕获文本到自动命名的组里
           | (?&lt;name&gt;exp |匹配exp,并捕获文本到名称为name的组里，也可以写成(?&apos;name&apos;exp)
           |  (?:exp)    |匹配exp,不捕获匹配的文本，也不给此分组分配组号
  零宽断言  |   (?=exp)   |   匹配exp前面的位置                 
           |   (?&lt;=exp)  |匹配exp后面的位置
           |   (?!exp)   |匹配后面跟的不是exp的位置
           | (?&lt;!exp)    |匹配前面不是exp的位置
 注释      | (?#comment)  |这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读
</code></pre><p>注意：</p>
<pre><code>分组0对应整个正则表达式
实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号
你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权
</code></pre><p>例如：</p>
<pre><code>\b(\w+)\b\s+\1\b可以用来匹配重复的单词：html  html
</code></pre><h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><pre><code>          &lt;?!w+&gt; ?&lt;!w+

  \b\w*q[^u]\w*\b匹配包含后面不是字母u的字母q的单词。

  你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w*\b将会匹配下一个单词，于是\b\w*q[^u]\w*\b就能匹配整个Iraq fighting

  负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：\b\w*q(?!u)\w*\b

例如

\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。

(?&lt;![a-z])\d{7}匹配前面不是小写字母的七位数字。

(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)匹配不包含属性的简单HTML标签内里的内容：被尖括号括起来的单词(比如可能是&lt;b&gt;)，然后是.*(任意的字符串),最后是一个后缀(?=&lt;\/\1&gt;)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是&lt;b&gt;的话，后缀就是&lt;/b&gt;了。整个表达式匹配的是&lt;b&gt;和&lt;/b&gt;之间的内容(再次提醒，不包括前缀和后缀本身)
</code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><pre><code>    代码          |语法
------------------|-----------------
      (?&lt;=        |# 断言要匹配的文本的前缀
      &lt;(\w+)&gt;     |# 查找尖括号括起来的字母或数字(即HTML/XML标签)
      (           |  # 前缀结束
      .*          |  # 匹配任意文本
      (?=         | # 断言要匹配的文本的后缀
     &lt;\ / \1&gt;     |# 查找尖括号括起来的内容：前面是一个&quot;/&quot;，后面是先前捕获的标签
       )          | # 后缀结束

例如：
2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)。
</code></pre><h3 id="贪婪和懒惰"><a href="#贪婪和懒惰" class="headerlink" title="贪婪和懒惰"></a>贪婪和懒惰</h3><ol>
<li><p>a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。它会匹配整个字符串aabab。这被称为贪婪匹配  </p>
</li>
<li><p>a.*?b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，匹配任意数量的重复，(但是在能使整个匹配成功的前提下)使用最少的重复,会匹配aab和ab。这被称为懒惰匹配</p>
<p>注意：</p>
<pre><code>为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？
简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：
最先开始的匹配拥有最高的优先权
</code></pre></li>
<li><p>懒惰限定符</p>
<pre><code> 代码          |说明
-----------------|------------------------
  *？            |重复任意次，但尽可能少重复
  +？            |重复1次或更多次，但尽可能少重复
 ？？            |重复0次或1次，但尽可能少重复
 {n,m}?         |重复n到m次，但尽可能少重复
 {n,}?          |重复n次以上，但尽可能少重复 
</code></pre></li>
</ol>
<h3 id="处理选项"><a href="#处理选项" class="headerlink" title="处理选项"></a>处理选项</h3><p>注意:</p>
<pre><code>Regex regex = new Regex(@&quot;\ba\w{6}\b&quot;, RegexOptions.IgnoreCase);
</code></pre><p>常用的处理选项</p>
<pre><code>            名称            |说明
---------------------------|--------------------------------
  IgnoreCase               |匹配时不区分大小写
  Multiline                |更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)
  Singleline               |更改.的含义，使它与每一个字符匹配（包括换行符\n）
  IgnorePatternWhitespace  |忽略表达式中的非转义空白并启用由#标记的注释。
  ExplicitCapture          | 仅捕获已被显式命名的组。 
</code></pre><h3 id="常用事例"><a href="#常用事例" class="headerlink" title="常用事例"></a>常用事例</h3><pre><code> 说明              |正则表达式     
 -----------------|----------------------------          
网址(url)         |[a-zA-z]+://[^\s]*
IP地址            |((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)
电子邮件(email)    |\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*
QQ号码            | [1-9]\d{4,}
HTML标签          |&lt;(.*)(.*)&gt;.*&lt;\/\1&gt;|&lt;(.*) \/&gt;
密码(有数字/大写字母/小写字母/标点，8位以上) |(?=^.{8,}$)(?=.*\d)(?=.*\W+)(?=.*[A-Z])(?=.*[a-z])(?!.*\n).*$
日期              |(\d{4}|\d{2})-((1[0-2])|(0?[1-9]))-(([12][0-9])|(3[01])|(0?[1-9]))
汉字              |[\u4e00-\u9fa5]
中文及全角标点符号  |[\u3000-\u301e\ufe10-\ufe19\ufe30-\ufe44\ufe50-\ufe6b\uff01-\uffee]
</code></pre><p>注意：</p>
<pre><code>ios 开发使用 RegexKit.framework 框架 
</code></pre><p>使用规则：</p>
<pre><code> 昵称验证：(4-8)位汉字    
 + (BOOL) validateNickname:(NSString *)nickname
{
    NSString *nicknameRegex = @&quot;^[\u4e00-\u9fa5]{4,8}$&quot;;

    NSPredicate *passWordPredicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,nicknameRegex];

    return [passWordPredicate evaluateWithObject:nickname];
}

密码验证：(6-20)位英文不分大小写和数字
+ (BOOL) validatePassword:(NSString *)passWord
{
   NSString *passWordRegex = @&quot;^[a-zA-Z0-9]{6,20}+$&quot;;

   NSPredicate *passWordPredicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,passWordRegex];

   return [passWordPredicate evaluateWithObject:passWord];
}

邮箱验证：
+ (BOOL) validateEmail:(NSString *)email
{
   NSString *emailRegex = @&quot;[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}&quot;;

   NSPredicate *emailTest = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, emailRegex];

   return [emailTest evaluateWithObject:email];
 }   
</code></pre>]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[GIT_版本库管理]]]></title>
      <url>/2017/09/22/GIT-%E7%89%88%E6%9C%AC%E5%BA%93%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>今天新同事不会用git，着实让我惊讶了，还好我有做笔记的习惯。就把我A long time ago 学习整理的git给他了，上手简单，很快就会成为git 大神，啊哈哈</p>
<h3 id="Git-小技能"><a href="#Git-小技能" class="headerlink" title="Git 小技能"></a>Git 小技能</h3><p>多人开发Git版本库的管理是再好不过的了，首先你要会把远程仓库的代码clone到你的电脑里，其次建立本地你的分支，写上你的code，然后添加到暂存区，没有问题就提交到修改区。既然是同时开发，肯能你同事也修改了，那就要把他的code先从远程仓库pull下来，不管你知不知道他们是否提交，避免冲突，先pull再push。然后无误后在merge到master分支，一切一气呵成。</p>
<h4 id="远程仓库管理"><a href="#远程仓库管理" class="headerlink" title="远程仓库管理"></a>远程仓库管理</h4><ol>
<li>先克隆代码到桌面吧，这克隆的是master分支代码<pre>
cd desktop
git clone (远程仓库地址)
</pre></li>
<li>如果你想克隆远程别的分支代码<pre>
git checkout -b (分支名) origin/(远程分支名)
git checkout —track origin/(远程分支名)
</pre></li>
<li>添加远程仓库<pre>
git remote add origin (远程仓库地址)：
</pre></li>
<li>删除远程仓库<pre>
git remote remove origin (远程仓库地址)
</pre></li>
<li>显示远程分支<pre>
git remote show origin
</pre>

</li>
</ol>
<h4 id="代码管理"><a href="#代码管理" class="headerlink" title="代码管理"></a>代码管理</h4><ol>
<li>代码添加到暂存区<pre>
git add (文件名)：添加某个文件
git add . : 添加所有文件
git add -A : 添加所有文件夹和文件
</pre></li>
<li>代码添加到当前分支<pre>
git commit -m "提交描述"
</pre></li>
<li>拉取远程代码<pre>
git pull origin (远程分支)
</pre></li>
<li>同步本地代码<pre>
git push origin (远程分支)
</pre>

</li>
</ol>
<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><ol>
<li>查看当前分支<pre>
git branch
</pre></li>
<li>创建新的分支<pre>
git checkout -b newBranch
</pre></li>
<li>删除旧的分支<pre>
git checkout -d newBranch
</pre></li>
<li>合并分支<pre>
git merge (要合并的分支)
</pre>

</li>
</ol>
<h4 id="提交管理"><a href="#提交管理" class="headerlink" title="提交管理"></a>提交管理</h4><ol>
<li>找到历史提交的commit id<pre>
git log —pretty=oneline —abbrev-commit
</pre></li>
<li>取消暂存<pre>
git reset HEAD 文件名
</pre></li>
<li>放弃当前修改<pre>
git checkout  -- (文件名)：（放弃当前文件修改）
git checkout . :(放弃当前所有修改)
</pre></li>
<li>恢复commit_id对应的版本<pre>
git reset --hard commit_id
</pre>

</li>
</ol>
<h4 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h4><ol>
<li>查看标签<pre>
git tag
</pre></li>
<li>查看标签信息<pre>
git show v1.0
</pre></li>
<li>创建标签<pre>
git tag v1.0  : 创建1.0标签
git tag v2.0 (commit_id): 创建指定提交的标签
</pre></li>
<li>删除标签<pre>
git tag -d v1.0 :（删除1.0标签）
git push origin :refs/tags/v0.9：（删除远程0.9标签）
</pre></li>
<li>推送本地标签<pre>
git push origin v1.0 ：（推送本地标签到远程）
git push origin —tags：（推送所有本地标签到远程）
</pre>

</li>
</ol>
<p>当然没有写Git冲突处理，因为我觉得冲突太简单了，打开项目包内容，定位到冲突的地方。保留正确的code，删除多余的运行就OK。如果一些乱七八糟的冲突，当然我也遇到过但是没有记录下来，很遗憾。</p>
<h4 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h4><p><img src="/2017/09/22/GIT-版本库管理/1.jpg" alt=""><br><img src="/2017/09/22/GIT-版本库管理/2.jpg" alt=""><br><img src="/2017/09/22/GIT-版本库管理/3.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> GIT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[机器学习_CoreML_Inceptionv3]]]></title>
      <url>/2017/09/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-CoreML-Inceptionv3/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome:<a href="https://github.com/princeSmall/CoreML_Inceptionv3" target="_blank" rel="external">github地址</a></p>
<p>一直直接用图片给.mlmodel去识别，觉得没有直接调用相机来的方便，一直看的都是swift版本的，所以想写一个oc的，立个flag。</p>
<h1 id="CoreML-Inceptionv3"><a href="#CoreML-Inceptionv3" class="headerlink" title="CoreML_Inceptionv3"></a>CoreML_Inceptionv3</h1><p><img src="/2017/09/21/机器学习-CoreML-Inceptionv3/Inceptionv3.gif" alt="Inceptionv3"></p>
<h3 id="相机调用"><a href="#相机调用" class="headerlink" title="相机调用"></a>相机调用</h3><ol>
<li>info.plist 添加调用相机请求</li>
<li>相机调用请求</li>
<li>相机数据输出的delegate</li>
</ol>
<h4 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h4><ul>
<li>摄像显示区域</li>
<li>相机调用请求</li>
<li>相机数据输出</li>
<li>线程</li>
<li>数据显示</li>
<li>InceptionvModel</li>
<li>InceptionvModel输出</li>
</ul>
<pre>
@property (nonatomic,strong) AVCaptureVideoPreviewLayer
*previewLayer; 
@property (nonatomic,strong) AVCaptureSession *session;
@property (nonatomic,strong) AVCaptureVideoDataOutput *videoOutPut;
@property (nonatomic,strong) AVCaptureConnection *videoConnection;
@property (nonatomic,strong) dispatch_queue_t videoQueue;
@property (nonatomic,strong) UILabel *resultLabel;
@property (nonatomic,strong) Inceptionv3 *InceptionvModel;
@property (nonatomic,strong) Inceptionv3Output *outPut;
</pre>

<h4 id="相机调用请求"><a href="#相机调用请求" class="headerlink" title="相机调用请求"></a>相机调用请求</h4><pre>
self.session = [[AVCaptureSession alloc] init];

    //视频
    AVCaptureDevice *videoDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];
    if (videoDevice.isFocusPointOfInterestSupported && [videoDevice isFocusModeSupported:AVCaptureFocusModeContinuousAutoFocus]) {
        [videoDevice lockForConfiguration:nil];
        [videoDevice setFocusMode:AVCaptureFocusModeContinuousAutoFocus];
        [videoDevice unlockForConfiguration];
    }

    AVCaptureDeviceInput *cameraDeviceInput = [[AVCaptureDeviceInput alloc] initWithDevice:videoDevice error:nil];


    if ([self.session canAddInput:cameraDeviceInput]) {
        [self.session addInput:cameraDeviceInput];
    }

    //视频
    self.videoOutPut = [[AVCaptureVideoDataOutput alloc] init];
    NSDictionary * outputSettings = [[NSDictionary alloc] initWithObjectsAndKeys:[NSNumber numberWithInt:kCVPixelFormatType_32BGRA],(id)kCVPixelBufferPixelFormatTypeKey, nil];
    [self.videoOutPut setVideoSettings:outputSettings];
    if ([self.session canAddOutput:self.videoOutPut]) {
        [self.session addOutput:self.videoOutPut];
    }
    self.videoConnection = [self.videoOutPut connectionWithMediaType:AVMediaTypeVideo];
    self.videoConnection.enabled = NO;
    [self.videoConnection setVideoOrientation:AVCaptureVideoOrientationPortrait];
</pre>

<h4 id="初始化预览层"><a href="#初始化预览层" class="headerlink" title="初始化预览层"></a>初始化预览层</h4><pre>
 self.previewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:self.session];
    [self.previewLayer setVideoGravity:AVLayerVideoGravityResizeAspectFill];
</pre>

<h4 id="打开相机"><a href="#打开相机" class="headerlink" title="打开相机"></a>打开相机</h4><pre>
 [self.session startRunning];
    self.videoConnection.enabled = YES;
    self.videoQueue = dispatch_queue_create("videoQueue", NULL);
    [self.videoOutPut setSampleBufferDelegate:self queue:self.videoQueue];
</pre>

<h4 id="关闭相机"><a href="#关闭相机" class="headerlink" title="关闭相机"></a>关闭相机</h4><pre>
[self.videoOutPut setSampleBufferDelegate:nil queue:nil];
    self.videoConnection.enabled = NO;
    self.videoQueue = nil;
    [self.session stopRunning];
</pre>

<h3 id="CoreML数据输出"><a href="#CoreML数据输出" class="headerlink" title="CoreML数据输出"></a>CoreML数据输出</h3><ol>
<li>获取相机数据输出的CMSampleBufferRef</li>
<li>转换成UIImage大小为299.299</li>
<li>输出为Inceptionv3Output</li>
</ol>
<h4 id="下载Inceptionv3-mlmodel"><a href="#下载Inceptionv3-mlmodel" class="headerlink" title="下载Inceptionv3.mlmodel"></a>下载Inceptionv3.mlmodel</h4><ol>
<li>target-&gt;build phases-&gt;compile sources 添加Inceptionv3.mlmodel</li>
<li>导入头文件Inceptionv3.h</li>
</ol>
<h4 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h4><pre>
-(UIImage *)image:(CGSize)resize{
    UIGraphicsBeginImageContext(resize);
    [self drawInRect:CGRectMake(0, 0, resize.width, resize.height)];
    UIImage * image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return image;
}
</pre>

<h4 id="数据输出"><a href="#数据输出" class="headerlink" title="数据输出"></a>数据输出</h4><pre>
-(void)imageOutput:(CMSampleBufferRef)sampleBuffer{    
    CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);
    CIImage * ciImage = [CIImage imageWithCVImageBuffer:imageBuffer];

    Inceptionv3Image * uiImage =[[Inceptionv3Image alloc]initWithCIImage:ciImage];
    UIImage * uiimage = [uiImage image:CGSizeMake(299, 299)];

    CGImageRef cgImage = uiimage.CGImage;
    CVPixelBufferRef pixelBuffer = [ImageConvert pixelBufferFromImage:cgImage];
    self.InceptionvModel = [[Inceptionv3 alloc]init];
    self.outPut =  [self.InceptionvModel predictionFromImage:pixelBuffer error:nil];
}
</pre>

<h4 id="在AVCaptureOutputDelegat回调方法中开启线程"><a href="#在AVCaptureOutputDelegat回调方法中开启线程" class="headerlink" title="在AVCaptureOutputDelegat回调方法中开启线程"></a>在AVCaptureOutputDelegat回调方法中开启线程</h4><ol>
<li>把相机输出的数据转换成Inceptionv3接收的数据</li>
<li>在主线程刷新界面</li>
</ol>
<pre>
dispatch_queue_t queue = dispatch_queue_create("CMSampleBufferRef", NULL);
    dispatch_sync(queue, ^{
        [self imageOutput:sampleBuffer];
        dispatch_async(dispatch_get_main_queue(), ^{
            self.resultLabel.text = self.outPut.classLabel;
        });
    });
</pre>


]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[机器学习_CoreML_MobileNet]]]></title>
      <url>/2017/09/20/Python-CoreML-MobileNet/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome:<a href="https://github.com/princeSmall/CoreML_MobileNet" target="_blank" rel="external">github地址</a></p>
<h1 id="CoreML-MobileNet"><a href="#CoreML-MobileNet" class="headerlink" title="CoreML_MobileNet"></a>CoreML_MobileNet</h1><p>接着上面再写一个MobileNet.mlmodel,这次这个直接拿来用。</p>
<p>GoogLeNetPlaces.mlmodel 和 Resnet50都可以识别人物和静态物体。不过这个才24M，小多了，所以就简尔处理给张特定的image，然后输出结果</p>
<p><img src="/2017/09/20/Python-CoreML-MobileNet/pool.png" alt=""></p>
<h3 id="Download-Core-ML-Model"><a href="#Download-Core-ML-Model" class="headerlink" title="Download Core ML Model"></a>Download Core ML Model</h3><p><a href="https://developer.apple.com/machine-learning/" target="_blank" rel="external">GoogLeNetPlaces.mlmodel下载地址</a></p>
<h3 id="导入头文件"><a href="#导入头文件" class="headerlink" title="导入头文件"></a>导入头文件</h3><pre>
 #import < CoreML/CoreML.h>
 #import < Vision/Vision.h>
 #import "GoogLeNetPlaces.h"
</pre>


<h3 id="图片识别"><a href="#图片识别" class="headerlink" title="图片识别"></a>图片识别</h3><ol>
<li><p>创建Resnet对象，加载CoreMLModel</p>
<pre>
GoogLeNetPlaces *googleModel = [[GoogLeNetPlaces alloc] init];
VNCoreMLModel * vnCoreModel = [VNCoreMLModel modelForMLModel:googleModel.model error:nil];
</pre>
</li>
<li><p>创建Vision请求，带有completion handle</p>
<pre>
VNCoreMLRequest * vnCoreMlRequest = [[VNCoreMLRequest alloc] initWithModel:vnCoreModel completionHandler:^(VNRequest * _Nonnull request, NSError * _Nullable error) {
   CGFloat confidence = 0.0f;
   VNClassificationObservation * tempClassification = nil;
   for (VNClassificationObservation *classification in request.results) {
       if (classification.confidence > confidence) {
           confidence = classification.confidence;
           tempClassification = classification;
       }
   }        
}];
</pre>
</li>
<li><p>VNClassificationObservation对象两个属性</p>
<ul>
<li>identifier：识别对象 </li>
<li>confidence：识别率</li>
</ul>
</li>
<li><p>发送图片识别请求</p>
<pre>
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
  VNImageRequestHandler * vnImageRequestHandler = [[VNImageRequestHandler alloc] initWithCGImage:image.CGImage options:nil];   
   NSError *error = nil;
   [vnImageRequestHandler performRequests:@[vnCoreMlRequest] error:&error]; 
   if (error) {
       NSLog(@"%@",error.localizedDescription);
   }
});
</pre>
</li>
<li><p>回调在主线程更新UI</p>
<pre>
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
       self.resultLable.text = [NSString stringWithFormat:@"识别结果:%@",tempClassification.identifier];
       self.confidenceLabel.text = [NSString stringWithFormat:@"匹配率:%@",@(tempClassification.confidence)];
   });
</pre>


</li>
</ol>
<p>多次下来是不是很简单，大同小异，只要熟悉CoreML，一切就是那么easy</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[机器学习_CoreML_Resnet50]]]></title>
      <url>/2017/09/20/Python-CoreML-Resnet50/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome:<a href="https://github.com/princeSmall/CoreML_Resnet50" target="_blank" rel="external">github地址</a></p>
<h1 id="CoreML-Resnet50"><a href="#CoreML-Resnet50" class="headerlink" title="CoreML_Resnet50"></a>CoreML_Resnet50</h1><p>把玩了几天的CoreML，现在上手就写很是方便啊，所以研究透之后再来些例子就简单了。<br>这次用的是苹果提供的resnet50.mlmodel。</p>
<p><img src="/2017/09/20/Python-CoreML-Resnet50/cat.png" alt="举例图片" width="250" height="500"><br><img src="/2017/09/20/Python-CoreML-Resnet50/dog.png" alt="举例图片" width="250" height="500"><br><img src="/2017/09/20/Python-CoreML-Resnet50/mouse.png" alt="举例图片" width="250" height="500"><br><img src="/2017/09/20/Python-CoreML-Resnet50/panda.png" alt="举例图片" width="250" height="500"></p>
<h3 id="Download-Core-ML-Model"><a href="#Download-Core-ML-Model" class="headerlink" title="Download Core ML Model"></a>Download Core ML Model</h3><p><a href="https://developer.apple.com/machine-learning/" target="_blank" rel="external">Resnet50.mlmodel下载地址</a></p>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><ol>
<li>把下载后的mlmodel放入Xcode里面，绑定target，会自动生成.h和.m文件</li>
<li>导入头文件</li>
</ol>
<pre>
 #import < CoreML/CoreML.h>
 #import < Vision/Vision.h>
 #import "Resnet50.h"
</pre>

<h3 id="添加UIScrollView和UIPageControl"><a href="#添加UIScrollView和UIPageControl" class="headerlink" title="添加UIScrollView和UIPageControl"></a>添加UIScrollView和UIPageControl</h3><pre>
self.scrollView = [[UIScrollView alloc]initWithFrame:CGRectMake(0, 0, viewWidth, 250)];
    self.scrollView.delegate = self;
    self.scrollView.bounces = YES;
    self.scrollView.contentSize = CGSizeMake(5 * viewWidth, 250);
    self.scrollView.pagingEnabled = YES;
    self.scrollView.showsHorizontalScrollIndicator = NO;
    [self.view addSubview:self.scrollView];

    self.pageControl = [[UIPageControl alloc]init];
    [self.pageControl setCenter:CGPointMake(viewWidth / 2 - 20, 250 - 10)];
    self.pageControl.numberOfPages = 5;
    self.pageControl.pageIndicatorTintColor = [UIColor blackColor];
    self.pageControl.currentPageIndicatorTintColor = [UIColor redColor];
    for (int i = 0; i < 5; i ++) {
        UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(i * viewWidth, 0, viewWidth, 250)];
        imageView.image = [UIImage imageNamed:[NSString stringWithFormat:@"%d.jpg",i + 1]];
        [self.scrollView addSubview:imageView];
    }

    [self.view addSubview:self.pageControl];
 </pre>

<h4 id="滚动到开头或末尾"><a href="#滚动到开头或末尾" class="headerlink" title="滚动到开头或末尾"></a>滚动到开头或末尾</h4> <pre>
if (scrollView.contentOffset.x > 4 * viewWidth) 
{
        self.scrollView.contentOffset = CGPointMake(0, 0);
    }else if (scrollView.contentOffset.x < 0){
        self.scrollView.contentOffset = CGPointMake(4 * viewWidth, 0);
 }
 </pre> 

<h4 id="滚动结束后识别图片"><a href="#滚动结束后识别图片" class="headerlink" title="滚动结束后识别图片"></a>滚动结束后识别图片</h4> <pre>
  self.currentImage =[UIImage imageNamed:[NSString stringWithFormat:@"%d.jpg",(int)(self.pageControl.currentPage)]];
   [self openResnet50];
 </pre>

<h3 id="图片识别"><a href="#图片识别" class="headerlink" title="图片识别"></a>图片识别</h3><ol>
<li><p>创建Resnet对象，加载CoreMLModel</p>
<pre>
Resnet50 *resnetModel = [[Resnet50 alloc] init];
VNCoreMLModel * vnCoreModel = [VNCoreMLModel modelForMLModel:resnetModel.model error:nil];
</pre>
</li>
<li><p>创建Vision请求，带有completion handle</p>
<pre>
VNCoreMLRequest * vnCoreMlRequest = [[VNCoreMLRequest alloc] initWithModel:vnCoreModel completionHandler:^(VNRequest * _Nonnull request, NSError * _Nullable error) {
   CGFloat confidence = 0.0f;
   VNClassificationObservation * tempClassification = nil;
   for (VNClassificationObservation *classification in request.results) {
       if (classification.confidence > confidence) {
           confidence = classification.confidence;
           tempClassification = classification;
       }
   }        
}];
</pre>
</li>
<li><p>VNClassificationObservation对象两个属性</p>
<ul>
<li>identifier：识别对象 </li>
<li>confidence：识别率</li>
</ul>
</li>
<li><p>发送图片识别请求</p>
<pre>
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
  VNImageRequestHandler * vnImageRequestHandler = [[VNImageRequestHandler alloc] initWithCGImage:image.CGImage options:nil];   
   NSError *error = nil;
   [vnImageRequestHandler performRequests:@[vnCoreMlRequest] error:&error]; 
   if (error) {
       NSLog(@"%@",error.localizedDescription);
   }
});
</pre>
</li>
<li><p>回调在主线程更新UI</p>
<pre>
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
       self.resultLable.text = [NSString stringWithFormat:@"识别结果:%@",tempClassification.identifier];
       self.confidenceLabel.text = [NSString stringWithFormat:@"匹配率:%@",@(tempClassification.confidence)];
   });
</pre>




</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[机器学习_Python_mlmodel]]]></title>
      <url>/2017/09/20/Python-mlmodel/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome:<a href="https://github.com/princeSmall/CoreMLModel" target="_blank" rel="external">github地址</a></p>
<h1 id="CoreMLModel"><a href="#CoreMLModel" class="headerlink" title="CoreMLModel"></a>CoreMLModel</h1><p><img src="/2017/09/20/Python-mlmodel/mlmodel.png" alt=""><br>把玩CoreML创建自己的.mlmodel的心酸历程，足足摆弄了半天，各种坑。立个flag</p>
<h3 id="Permission-denied-问题"><a href="#Permission-denied-问题" class="headerlink" title="[Permission denied]问题"></a>[Permission denied]问题</h3><p><img src="/2017/09/20/Python-mlmodel/coremltoolsbug.png" alt="tools"></p>
<ul>
<li><p>pip install -U coremltools</p>
</li>
<li><p>从图也可以看出coremltools包含numpy,six,protobuf,coremltools。<br>因为权限问题导致失败</p>
</li>
</ul>
<p><img src="/2017/09/20/Python-mlmodel/coremltools.png" alt=""></p>
<ul>
<li>sudo pip install -U coremltools</li>
<li>遇到[Permission denied]都要加sudo</li>
</ul>
<h3 id="ImportError-No-module-named-pkg-resources-问题"><a href="#ImportError-No-module-named-pkg-resources-问题" class="headerlink" title="ImportError: No module named pkg_resources 问题"></a>ImportError: No module named pkg_resources 问题</h3><ul>
<li><p>Step: 1 Login in root user.</p>
<pre>
sudo su root
</pre>
</li>
<li><p>Step: 2 Uninstall python-pip package if existing.</p>
<pre>
apt-get purge -y python-pip
</pre>
</li>
<li><p>Step: 3 Download files using wget command(File download in pwd )</p>
<pre>
wget https://bootstrap.pypa.io/get-pip.py
</pre>
</li>
<li><p>Step: 4 Run python file.</p>
<pre>
python ./get-pip.py
</pre>
</li>
<li><p>Step: 5 Finaly exicute installation command.</p>
<pre>
apt-get install python-pip
</pre>

</li>
</ul>
<p><div><span style="color:red">Note: User must be root.</span></div></p>
<p>好吧，这两个问题遍布整个流程，期间各种小问题我已经不记得了，接下来就开始正文了</p>
<ol>
<li><p>下载coremltools</p>
<pre>sudo pip install -U coremltools</pre>
</li>
<li><p>下载pip.py文件</p>
<pre>sudo python get-pip.py</pre>
</li>
<li><p>下载scikit-learn</p>
<pre>sudo pip install -U numpy scipy scikit-learn</pre>
</li>
<li><p>下载panda</p>
<pre>sudo pip install pandas</pre>

</li>
</ol>
<p>准备就绪，开工</p>
<h4 id="创建csv文件"><a href="#创建csv文件" class="headerlink" title="创建csv文件"></a>创建csv文件</h4><ol>
<li>csv文件属性Square_Feet，Price</li>
<li>记录文件所存储位置，调用的时候需要</li>
</ol>
<h4 id="在终端输入生成-mlmodel文件"><a href="#在终端输入生成-mlmodel文件" class="headerlink" title="在终端输入生成.mlmodel文件"></a>在终端输入生成.mlmodel文件</h4><ol>
<li>导入需要的类</li>
<li>调用csv文件</li>
<li>coremltools转换成.mlmodel文件</li>
<li>author,license,description描述</li>
<li>输入Square_Feet，输出Price，保存</li>
</ol>
<ul>
<li><blockquote>
<blockquote>
<blockquote>
<p>import coremltools</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>from sklearn.linear_model import LinearRegression</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>import pandas as pd</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>data = pd.read_csv(‘/Users/sansi/Desktop/CoreMLModel/input_data.csv’)</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>model = LinearRegression()</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>model.fit(data[[“Square_Feet”]], data[“Price”])</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>coreml_model = coremltools.converters.sklearn.convert(model, “Square_Feet”, “Price”)</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>coreml_model.author = ‘tongle’</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>coreml_model.license = ‘BSD’</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>coreml_model.short_description = ‘Predicts the price of a house in the Seattle area.’</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>coreml_model.input_description[‘Square_Feet’] = ‘Size (in square feet)’</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>coreml_model.output_description[‘Price’] = ‘Price of the house’</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>coreml_model.save(‘HousePricer.mlmodel’)</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<p>如果没有一点python功底，我都要死在电脑前了，哈哈</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[iOS_CellAnimation]]]></title>
      <url>/2017/09/12/iOS-CellAnimation/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/CellAnimation" target="_blank" rel="external">github地址</a></p>
<p>最近在用cell动画，就研究修改了别人的cell动画，整理了一下。</p>
<p><img src="/2017/09/12/iOS-CellAnimation/CellAnimation.gif" alt="CellAnimation"></p>
<h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p>导入Animation类，直接用类调用,输入要动画的tableview和动画type，即可</p>
<pre>
 [Animation addAnimationWithTableView:tableView andRow:self.type];
</pre>

<h3 id="UITableViewCell-出场动画："><a href="#UITableViewCell-出场动画：" class="headerlink" title="UITableViewCell 出场动画："></a>UITableViewCell 出场动画：</h3><p>简而明了的说就是利用cell的contentView来做一下出场动画animation</p>
<pre>
 CGFloat width = [[UIScreen mainScreen] bounds].size.width - 40;
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(20, 10, width, 60)];
    view.backgroundColor = [UIColor redColor];
    view.layer.masksToBounds = YES;
    view.layer.cornerRadius = 9.0;
    [cell.contentView addSubview:view];
</pre>

<h3 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h3><h4 id="move动画"><a href="#move动画" class="headerlink" title="move动画"></a>move动画</h4><pre>
+ (void)moveAnimationWithTableView:(UITableView *)tableView {

    NSArray *cells = tableView.visibleCells;
    for (int i = 0; i < cells.count; i++) {
        CGFloat totalTime = 0.4;
        UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i];
        cell.transform = CGAffineTransformMakeTranslation(-XS_SCREEN_WIDTH, 0);
        [UIView animateWithDuration:0.4 delay:i*(totalTime/cells.count) usingSpringWithDamping:0.7 initialSpringVelocity:1/0.7 options:UIViewAnimationOptionCurveEaseIn animations:^{
            cell.transform = CGAffineTransformIdentity;
        } completion:^(BOOL finished) {

        }];
    }
}
</pre>

<h4 id="alpha动画"><a href="#alpha动画" class="headerlink" title="alpha动画"></a>alpha动画</h4><pre>
+ (void)alphaAnimationWithTableView:(UITableView *)tableView {

    NSArray *cells = tableView.visibleCells;
    for (int i = 0; i < cells.count; i++) {
        UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i];
        cell.alpha = 0.0;
        [UIView animateWithDuration:0.3 delay:i*0.05 options:0 animations:^{
            cell.alpha = 1.0;
        } completion:^(BOOL finished) {

        }];
    }
}
</pre>

<h4 id="fall动画"><a href="#fall动画" class="headerlink" title="fall动画"></a>fall动画</h4><pre>
+ (void)fallAnimationWithTableView:(UITableView *)tableView {

    NSArray *cells = tableView.visibleCells;

    NSTimeInterval totalTime = 0.8;

    for (int i = 0; i < cells.count; i++) {
        UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i];
        cell.transform = CGAffineTransformMakeTranslation(0, - XS_SCREEN_HEIGHT);
        [UIView animateWithDuration:0.3 delay:(cells.count - i)*(totalTime/cells.count) options:0 animations:^{
            cell.transform = CGAffineTransformIdentity;
        } completion:^(BOOL finished) {

        }];
    }
}
</pre>

<h4 id="shake动画"><a href="#shake动画" class="headerlink" title="shake动画"></a>shake动画</h4><pre>
+ (void)shakeAnimationWithTableView:(UITableView *)tableView {

    NSArray *cells = tableView.visibleCells;
    for (int i = 0; i < cells.count; i++) {
        UITableViewCell *cell = [cells objectAtIndex:i];
        if (i%2 == 0) {
            cell.transform = CGAffineTransformMakeTranslation(-XS_SCREEN_WIDTH,0);
        }else {
            cell.transform = CGAffineTransformMakeTranslation(XS_SCREEN_WIDTH,0);
        }
        [UIView animateWithDuration:0.4 delay:i*0.03 usingSpringWithDamping:0.75 initialSpringVelocity:1/0.75 options:0 animations:^{
            cell.transform = CGAffineTransformIdentity;
        } completion:^(BOOL finished) {

        }];
    }
}
</pre>

<h4 id="overTurn动画"><a href="#overTurn动画" class="headerlink" title="overTurn动画"></a>overTurn动画</h4><pre>
+ (void)overTurnAnimationWithTableView:(UITableView *)tableView {

    NSArray *cells = tableView.visibleCells;
    for (int i = 0; i < cells.count; i++) {
        UITableViewCell *cell = [cells objectAtIndex:i];
        cell.layer.opacity = 0.0;
        cell.layer.transform = CATransform3DMakeRotation(M_PI, 1, 0, 0);
        NSTimeInterval totalTime = 0.7;
        [UIView animateWithDuration:0.3 delay:i*(totalTime/cells.count) options:0 animations:^{
            cell.layer.opacity = 1.0;
            cell.layer.transform = CATransform3DIdentity;
        } completion:^(BOOL finished) {

        }];

    }
}
</pre>

<h4 id="toTop动画"><a href="#toTop动画" class="headerlink" title="toTop动画"></a>toTop动画</h4><pre>
+ (void)toTopAnimationWithTableView:(UITableView *)tableView {


    NSArray *cells = tableView.visibleCells;

    NSTimeInterval totalTime = 0.8;

    for (int i = 0; i < cells.count; i++) {
        UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i];
        cell.transform = CGAffineTransformMakeTranslation(0,  XS_SCREEN_HEIGHT);
        [UIView animateWithDuration:0.35 delay:i*(totalTime/cells.count) options:UIViewAnimationOptionCurveEaseOut animations:^{
            cell.transform = CGAffineTransformIdentity;
        } completion:^(BOOL finished) {

        }];
    }
}
</pre>

<h4 id="spring动画"><a href="#spring动画" class="headerlink" title="spring动画"></a>spring动画</h4><pre>
+ (void)springListAnimationWithTableView:(UITableView *)tableView {

    NSArray *cells = tableView.visibleCells;
    for (int i = 0; i < cells.count; i++) {
        UITableViewCell *cell = [cells objectAtIndex:i];
        cell.layer.opacity = 0.7;
        cell.layer.transform = CATransform3DMakeTranslation(0, -XS_SCREEN_HEIGHT, 20);
        NSTimeInterval totalTime = 1.0;

        [UIView animateWithDuration:0.4 delay:i*(totalTime/cells.count) usingSpringWithDamping:0.65 initialSpringVelocity:1/0.65 options:UIViewAnimationOptionCurveEaseIn animations:^{
            cell.layer.opacity = 1.0;
            cell.layer.transform = CATransform3DMakeTranslation(0, 0, 20);
        } completion:^(BOOL finished) {

        }];
    }
}
</pre>

<h4 id="shrink动画"><a href="#shrink动画" class="headerlink" title="shrink动画"></a>shrink动画</h4><pre>
+ (void)shrinkToTopAnimationWithTableView:(UITableView *)tableView {
    NSArray *cells = tableView.visibleCells;
    for (int i = 0; i < cells.count; i++) {
        UITableViewCell *cell = [cells objectAtIndex:i];
        CGRect rect = [cell convertRect:cell.bounds fromView:tableView];
        cell.transform = CGAffineTransformMakeTranslation(0, -rect.origin.y);
        [UIView animateWithDuration:0.5 animations:^{
            cell.transform = CGAffineTransformIdentity;
        }];
    }
}
</pre>

<h3 id="laydown动画"><a href="#laydown动画" class="headerlink" title="laydown动画"></a>laydown动画</h3><pre>
+ (void)layDownAnimationWithTableView:(UITableView *)tableView {
    NSArray *cells = tableView.visibleCells;
    NSMutableArray *rectArr = [[NSMutableArray alloc] init];
    for (int i = 0; i < cells.count; i++) {
        UITableViewCell *cell = [cells objectAtIndex:i];
        CGRect rect = cell.frame;
        [rectArr addObject:[NSValue valueWithCGRect:rect]];
        rect.origin.y = i * 10;
        cell.frame = rect;
        cell.layer.transform = CATransform3DMakeTranslation(0, 0, i*5);
    }
    NSTimeInterval totalTime = 0.8;
    for (int i = 0; i < cells.count; i++) {
        UITableViewCell *cell = [cells objectAtIndex:i];
        CGRect rect = [[rectArr objectAtIndex:i] CGRectValue];
        [UIView animateWithDuration:(totalTime/cells.count) * i animations:^{
            cell.frame = rect;
        } completion:^(BOOL finished) {
            cell.layer.transform = CATransform3DIdentity;
        }];
    }

}
</pre>

<h4 id="rote动画"><a href="#rote动画" class="headerlink" title="rote动画"></a>rote动画</h4><pre>
+ (void)roteAnimationWithTableView:(UITableView *)tableView {

    NSArray *cells = tableView.visibleCells;
    CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"transform.rotation.y"];
    animation.fromValue = @(-M_PI);
    animation.toValue = 0;
    animation.duration = 0.3;
    animation.removedOnCompletion = NO;
    animation.repeatCount = 3;
    animation.fillMode = kCAFillModeForwards;
    animation.autoreverses = NO;

    for (int i = 0; i < cells.count; i++) {
        UITableViewCell *cell = [cells objectAtIndex:i];

        cell.alpha = 0.0;
        [UIView animateWithDuration:0.1 delay:i*0.25 options:0 animations:^{
            cell.alpha = 1.0;
        } completion:^(BOOL finished) {
            [cell.layer addAnimation:animation forKey:@"rotationYkey"];
        }];
    }
}
</pre>


]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 2 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[iOS-QRCodeImage]]]></title>
      <url>/2017/09/11/iOS-QRCodeImage/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/QRCodeImage" target="_blank" rel="external">github地址</a></p>
<p>好几天没写博客了，正好在忙二维码的生成，扫描就里一个flag吧</p>
<p><img src="/2017/09/11/iOS-QRCodeImage/QRCode.gif" alt="gif"></p>
<h3 id="原始二维码"><a href="#原始二维码" class="headerlink" title="原始二维码"></a>原始二维码</h3><p>通过滤镜CIFilter生成二维码</p>
<ol>
<li>创建过滤器</li>
<li>给过滤器添加数据</li>
<li>设置滤镜inputMessage数据</li>
<li>输出二维码</li>
</ol>
<pre>
+ (CIImage *)qrCodeImageWithContent:(NSString *)content{
    CIFilter *qrFilter = [CIFilter filterWithName:@"CIQRCodeGenerator"];
    NSData *contentData = [content dataUsingEncoding:NSUTF8StringEncoding];
    [qrFilter setValue:contentData forKey:@"inputMessage"];
    [qrFilter setValue:@"H" forKey:@"inputCorrectionLevel"];
    CIImage *image = qrFilter.outputImage;
    return image;
}

void ProviderReleaseData (void *info, const void *data, size_t size){
    free((void*)data);
}
</pre>

<p>生成制定大小的二维码</p>
<ol>
<li>传入原始二维码数据</li>
<li>设置倍数scale</li>
<li>通过bitmapImage放大并保存</li>
</ol>
<pre>
+ (UIImage *)qrCodeImageWithContent:(NSString *)content codeImageSize:(CGFloat)size{
    CIImage *image = [self qrCodeImageWithContent:content];
    CGRect integralRect = CGRectIntegral(image.extent);
    CGFloat scale = MIN(size/CGRectGetWidth(integralRect), size/CGRectGetHeight(integralRect));  
    size_t width = CGRectGetWidth(integralRect)*scale;
    size_t height = CGRectGetHeight(integralRect)*scale;
    CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceGray();
    CGContextRef bitmapRef = CGBitmapContextCreate(nil, width, height, 8, 0, colorSpaceRef, (CGBitmapInfo)kCGImageAlphaNone);
    CIContext *context = [CIContext contextWithOptions:nil];
    CGImageRef bitmapImage = [context createCGImage:image fromRect:integralRect];
    CGContextSetInterpolationQuality(bitmapRef, kCGInterpolationNone);
    CGContextScaleCTM(bitmapRef, scale, scale);
    CGContextDrawImage(bitmapRef, integralRect, bitmapImage);

    CGImageRef scaledImage = CGBitmapContextCreateImage(bitmapRef);
    CGContextRelease(bitmapRef);
    CGImageRelease(bitmapImage);
    return [UIImage imageWithCGImage:scaledImage];
}
</pre>



<h3 id="原始条形码"><a href="#原始条形码" class="headerlink" title="原始条形码"></a>原始条形码</h3><p>通过滤镜CIFilter生成二维码</p>
<ol>
<li>创建过滤器</li>
<li>给过滤器添加数据</li>
<li>设置滤镜inputMessage数据</li>
<li>输出二维码</li>
</ol>
<pre>
+ (CIImage *)barcodeImageWithContent:(NSString *)content{
    CIFilter *qrFilter = [CIFilter filterWithName:@"CICode128BarcodeGenerator"];
    NSData *contentData = [content dataUsingEncoding:NSUTF8StringEncoding];
    [qrFilter setValue:contentData forKey:@"inputMessage"];
    [qrFilter setValue:@(0.00) forKey:@"inputQuietSpace"];
    CIImage *image = qrFilter.outputImage;
    return image;
}

void ProviderReleaseData (void *info, const void *data, size_t size){
    free((void*)data);
}
</pre>

<p>生成定制大小的条形码</p>
<ol>
<li>传入原始二维码数据</li>
<li>设置倍数scale</li>
<li>通过bitmapImage放大并保存</li>
</ol>
<pre>
+ (UIImage *)barcodeImageWithContent:(NSString *)content codeImageSize:(CGSize)size{
    CIImage *image = [self barcodeImageWithContent:content];
    CGRect integralRect = CGRectIntegral(image.extent);
    CGFloat scale = MIN(size.width/CGRectGetWidth(integralRect), size.height/CGRectGetHeight(integralRect));  
    size_t width = CGRectGetWidth(integralRect)*scale;
    size_t height = CGRectGetHeight(integralRect)*scale;
    CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceGray();
    CGContextRef bitmapRef = CGBitmapContextCreate(nil, width, height, 8, 0, colorSpaceRef, (CGBitmapInfo)kCGImageAlphaNone);
    CIContext *context = [CIContext contextWithOptions:nil];
    CGImageRef bitmapImage = [context createCGImage:image fromRect:integralRect];
    CGContextSetInterpolationQuality(bitmapRef, kCGInterpolationNone);
    CGContextScaleCTM(bitmapRef, scale, scale);
    CGContextDrawImage(bitmapRef, integralRect, bitmapImage);

    CGImageRef scaledImage = CGBitmapContextCreateImage(bitmapRef);
    CGContextRelease(bitmapRef);
    CGImageRelease(bitmapImage);
    return [UIImage imageWithCGImage:scaledImage];
}
</pre>


<h3 id="彩色二维码"><a href="#彩色二维码" class="headerlink" title="彩色二维码"></a>彩色二维码</h3><p>获取原始二维码改变像素点颜色</p>
<ol>
<li>@param content 二维码数据</li>
<li>@param size 二维码大小</li>
<li>@param red 0 ~ 1.0</li>
<li>@param green 0 ~ 1.0</li>
<li>@param blue 0 ~ 1.0</li>
</ol>
<pre>
+ (UIImage *)qrCodeImageWithContent:(NSString *)content codeImageSize:(CGFloat)size red:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue{
    UIImage *image = [self qrCodeImageWithContent:content codeImageSize:size];
    int imageWidth = image.size.width;
    int imageHeight = image.size.height;
    size_t bytesPerRow = imageWidth * 4;
    uint32_t *rgbImageBuf = (uint32_t *)malloc(bytesPerRow * imageHeight);
    CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(rgbImageBuf, imageWidth, imageHeight, 8, bytesPerRow, colorSpaceRef, kCGBitmapByteOrder32Little|kCGImageAlphaNoneSkipLast);
    CGContextDrawImage(context, CGRectMake(0, 0, imageWidth, imageHeight), image.CGImage);
    //遍历像素, 改变像素点颜色
    int pixelNum = imageWidth * imageHeight;
    uint32_t *pCurPtr = rgbImageBuf;
    for (int i = 0; i< pixelNum; i++, pCurPtr++) {
        if ((*pCurPtr & 0xFFFFFF00) < 0x99999900) {
            uint8_t* ptr = (uint8_t*)pCurPtr;
            ptr[3] = red*255;
            ptr[2] = green*255;
            ptr[1] = blue*255;
        }else{
            uint8_t* ptr = (uint8_t*)pCurPtr;
            ptr[0] = 0;
        }
    }
    //取出图片
    CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, rgbImageBuf, bytesPerRow * imageHeight, ProviderReleaseData);
    CGImageRef imageRef = CGImageCreate(imageWidth, imageHeight, 8, 32, bytesPerRow, colorSpaceRef,
                                        kCGImageAlphaLast | kCGBitmapByteOrder32Little, dataProvider,
                                        NULL, true, kCGRenderingIntentDefault);
    CGDataProviderRelease(dataProvider);
    UIImage *resultImage = [UIImage imageWithCGImage:imageRef];
    CGImageRelease(imageRef);
    CGContextRelease(context);
    CGColorSpaceRelease(colorSpaceRef);

    return resultImage;
}
</pre>

<p>给二维码添加中心logo</p>
<pre>
+ (UIImage *)qrCodeImageWithContent:(NSString *)content
                      codeImageSize:(CGFloat)size
                               logo:(UIImage *)logo
                          logoFrame:(CGRect)logoFrame
                                red:(CGFloat)red
                              green:(CGFloat)green
                               blue:(CGFloat)blue{
    UIImage * image = [self qrCodeImageWithContent:content codeImageSize:size red:red green:green blue:blue];   
    if (logo != nil) {
        UIGraphicsBeginImageContext(image.size);
        [image drawInRect:CGRectMake(0, 0, image.size.width, image.size.height)];
        [logo drawInRect:logoFrame];
        UIImage *resultImage = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();
        return resultImage;
    }else{
        return image;
    }   
}
</pre>

<h3 id="彩色条形码"><a href="#彩色条形码" class="headerlink" title="彩色条形码"></a>彩色条形码</h3><p>获取原始二维码改变像素点颜色</p>
<ol>
<li>@param content 二维码数据</li>
<li>@param size 二维码大小</li>
<li>@param red 0 ~ 1.0</li>
<li>@param green 0 ~ 1.0</li>
<li>@param blue 0 ~ 1.0</li>
</ol>
<pre>
+ (UIImage *)barcodeImageWithContent:(NSString *)content codeImageSize:(CGSize)size red:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue{
    UIImage *image = [self barcodeImageWithContent:content codeImageSize:size];
    int imageWidth = image.size.width;
    int imageHeight = image.size.height;
    size_t bytesPerRow = imageWidth * 4;
    uint32_t *rgbImageBuf = (uint32_t *)malloc(bytesPerRow * imageHeight);
    CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(rgbImageBuf, imageWidth, imageHeight, 8, bytesPerRow, colorSpaceRef, kCGBitmapByteOrder32Little|kCGImageAlphaNoneSkipLast);
    CGContextDrawImage(context, CGRectMake(0, 0, imageWidth, imageHeight), image.CGImage);
    //遍历像素, 改变像素点颜色
    int pixelNum = imageWidth * imageHeight;
    uint32_t *pCurPtr = rgbImageBuf;
    for (int i = 0; i< pixelNum; i++, pCurPtr++) {
        if ((*pCurPtr & 0xFFFFFF00) < 0x99999900) {
            uint8_t* ptr = (uint8_t*)pCurPtr;
            ptr[3] = red*255;
            ptr[2] = green*255;
            ptr[1] = blue*255;
        }else{
            uint8_t* ptr = (uint8_t*)pCurPtr;
            ptr[0] = 0;
        }
    }
    //取出图片
    CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, rgbImageBuf, bytesPerRow * imageHeight, ProviderReleaseData);
    CGImageRef imageRef = CGImageCreate(imageWidth, imageHeight, 8, 32, bytesPerRow, colorSpaceRef,
                                        kCGImageAlphaLast | kCGBitmapByteOrder32Little, dataProvider,
                                        NULL, true, kCGRenderingIntentDefault);
    CGDataProviderRelease(dataProvider);
    UIImage *resultImage = [UIImage imageWithCGImage:imageRef];
    CGImageRelease(imageRef);
    CGContextRelease(context);
    CGColorSpaceRelease(colorSpaceRef); 
    return resultImage;
}
</pre>

<h3 id="渐变二维码"><a href="#渐变二维码" class="headerlink" title="渐变二维码"></a>渐变二维码</h3><p>绘制黑白二维码</p>
<pre>
- (UIImage *)genQRCodeImageMask:(UIImage *)image {
    if (image != nil) {
        int bitsPerComponent = 8;
        int bytesPerPixel = 4;
        int width = image.size.width;
        int height = image.size.height;
        unsigned char * imageData = (unsigned char *)malloc(width * height * bytesPerPixel);

        // 将原始黑白二维码图片绘制到像素格式为ARGB的图片上，绘制后的像素数据在imageData中。
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef imageContext = CGBitmapContextCreate(imageData, width, height, bitsPerComponent, bytesPerPixel * width, colorSpace, kCGImageAlphaPremultipliedFirst);
        UIGraphicsPushContext(imageContext);
        CGContextTranslateCTM(imageContext, 0, height);
        CGContextScaleCTM(imageContext, 1, -1);
        [image drawInRect:CGRectMake(0, 0, width, height)];

        CGColorSpaceRelease(colorSpace);

        // 根据每个像素R通道的值修改Alpha通道的值，当Red大于100，则将Alpha置为0，反之置为255
        for (int row = 0; row < height; ++row) {
            for (int col = 0; col < width; ++col) {
                int offset = row * width * bytesPerPixel + col * bytesPerPixel;
                unsigned char r = imageData[offset + 1];
                unsigned char alpha = r > 100 ? 0 : 255;
                imageData[offset] = alpha;
            }
        }

        CGImageRef cgMaskImage = CGBitmapContextCreateImage(imageContext);
        UIImage *maskImage = [UIImage imageWithCGImage:cgMaskImage];
        CFRelease(cgMaskImage);
        UIGraphicsPopContext();
        CFRelease(imageContext);

        free(imageData);
        return maskImage;
    }
    return nil;
}
</pre>

<p>设置蒙层的颜色</p>
<pre>
- (CAGradientLayer *)gradientLayer {
    if (_gradientLayer == nil) {
        _gradientLayer = [CAGradientLayer new];
        _gradientLayer.colors = @[
                                  (__bridge id)[UIColor colorWithRed: 0x2a / 255.0 green:0x9c / 255.0 blue: 0x1f / 255.0 alpha:1.0].CGColor,
                                  (__bridge id)[UIColor colorWithRed: 0xe6 / 255.0 green:0xcd / 255.0 blue: 0x27 / 255.0 alpha:1.0].CGColor,
                                  (__bridge id)[UIColor colorWithRed: 0xe6 / 255.0 green:0x27 / 255.0 blue: 0x57 / 255.0 alpha:1.0].CGColor
                                  ];
        [self.layer addSublayer: _gradientLayer];
        _gradientLayer.frame = self.bounds;
    }
    return _gradientLayer;
}
</pre>

<p>添加蒙层，设置黑白二维码图片</p>
<pre>- (void)setQRCodeImage:(UIImage *)qrcodeImage {
    UIImage *maskImage = [self genQRCodeImageMask: qrcodeImage];
    self.maskLayer.contents = (__bridge id)maskImage.CGImage;
    self.maskLayer.frame = self.bounds;
    self.gradientLayer.mask = self.maskLayer;
}
</pre>]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 2 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[iOS物理动画引擎_UIDynamic]]]></title>
      <url>/2017/09/05/iOS%E7%89%A9%E7%90%86%E5%8A%A8%E7%94%BB%E5%BC%95%E6%93%8E-UIDynamic/</url>
      <content type="html"><![CDATA[<h3 id="Welcome-to-my-blog-Thanks"><a href="#Welcome-to-my-blog-Thanks" class="headerlink" title="Welcome to my blog. Thanks."></a>Welcome to my blog. Thanks.</h3><p>Dome: <a href="https://github.com/princeSmall/UIDynamic" target="_blank" rel="external">github地址</a></p>
<p>iOS物理动画引擎-UIDynamic</p>
<p><img src="/2017/09/05/iOS物理动画引擎-UIDynamic/UIDynamic.gif" alt="UIDynamic"></p>
<h3 id="UIDynamicBehavior-仿真行为"><a href="#UIDynamicBehavior-仿真行为" class="headerlink" title="UIDynamicBehavior 仿真行为"></a>UIDynamicBehavior 仿真行为</h3><ol>
<li>创建一个仿真者,用来仿真所有的物理行为</li>
</ol>
<pre>
 animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view]
 </pre>
2. 创建具体的物理仿真行为

<pre>
gravity = [[UIGravityBehavior alloc]init]
collision = [[UICollisionBehavior alloc]init]
snapBehavior = [[UISnapBehavior alloc] init]
itemBehavior = [[UIDynamicItemBehavior alloc] init]
</pre>
3. 将物理仿真行为添加给仿真者实现仿真效果。

<pre>
 -(void)addBehavior:(UIDynamicBehavior *)behavior;
 -(void)removeBehavior:(UIDynamicBehavior *)behavior;
 -(void)removeAllBehaviors;
</pre>

<h3 id="UIGravityBehavior-重力行为"><a href="#UIGravityBehavior-重力行为" class="headerlink" title="UIGravityBehavior 重力行为"></a>UIGravityBehavior 重力行为</h3><ul>
<li>创建仿真者</li>
</ul>
<pre>
 self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];
</pre>

<ul>
<li>创建仿真行为</li>
</ul>
<pre>
-(UIGravityBehavior *)gravity{
    if (_gravity == nil) {
        _gravity = [[UIGravityBehavior alloc]init];
    }
    return _gravity;
}
-(UICollisionBehavior *)collision{
    if (_collision == nil) {
        _collision = [[UICollisionBehavior alloc]init];
    }
    return _collision;
}
</pre>

<ul>
<li>触碰屏幕生成重力小球</li>
</ul>
<pre>
-(void)touchesBegan:(NSSet<uitouch *=""> *)touches withEvent:(UIEvent *)event{
    UITouch * touch = touches.anyObject;
    CGPoint location = [touch locationInView:self.view];
    self.redView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, widthRed, widthRed)];
    self.redView.center = location;
    [self.view addSubview:self.redView];

    // 随机色方块
    self.redView.backgroundColor = randomColor;

    // 创建重力的物理仿真行为，并设置具体的items(需要仿真的view)
    [self.gravity addItem:self.redView];

    // 下落方向
    // [gravity setAngle:0.5];

    // 创建弹性的物理仿真行为，并设置具体的items(需要仿真的view)
    [self.collision addItem:self.redView];
    self.collision.translatesReferenceBoundsIntoBoundary = YES;

    // 将重力仿真行为添加给仿真者实现仿真效果，开始仿真
    [self.animator addBehavior:self.gravity];
    [self.animator addBehavior:self.collision];

}
</uitouch></pre>

<h3 id="UICollisionBehavior-碰撞行为"><a href="#UICollisionBehavior-碰撞行为" class="headerlink" title="UICollisionBehavior 碰撞行为"></a>UICollisionBehavior 碰撞行为</h3><ul>
<li>创建仿真者</li>
</ul>
<pre>
 self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];
</pre>

<ul>
<li>创建碰撞对象</li>
</ul>
<pre>
self.greenView = [[UIView alloc] initWithFrame:CGRectMake(100, 200, 100, 30)];
self.greenView.backgroundColor = [UIColor greenColor];
[self.view addSubview:self.greenView];

self.blueView = [[UIView alloc] initWithFrame:CGRectMake(120, 300, 100, 30)];
self.blueView.backgroundColor = [UIColor blueColor];
[self.view addSubview:self.blueView];

  //未绑定仿真对象  
self.blackView = [[UIView alloc] initWithFrame:CGRectMake(140, 400, 100, 30)];
self.blackView.backgroundColor = [UIColor blackColor];
[self.view addSubview:self.blackView];

  // 物体角度  
self.blueView.transform =  CGAffineTransformMakeRotation(M_PI_4);
self.greenView.transform = CGAffineTransformMakeRotation(-M_PI / 8);

</pre>

<ul>
<li>创建仿真行为</li>
</ul>
<pre>
-(UIGravityBehavior *)gravity{
    if (_gravity == nil) {
        _gravity = [[UIGravityBehavior alloc]init];
    }
    return _gravity;
}
-(UICollisionBehavior *)collision{
    if (_collision == nil) {
        _collision = [[UICollisionBehavior alloc]init];
    }
    return _collision;
}
</pre>

<ul>
<li>开始碰撞行为</li>
</ul>
<pre>
-(void)touchesBegan:(NSSet<uitouch *=""> *)touches withEvent:(UIEvent *)event{
    // 获取点击位置，生成仿真者
    UITouch * touch = touches.anyObject;
    CGPoint location = [touch locationInView:self.view];
    self.redView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, widthRed, widthRed)];
    self.redView.center = location;
    // pch中宏定义的随机色
    self.redView.backgroundColor = randomColor;
    [self.view addSubview:self.redView];
    [self.gravity addItem:self.redView];
    // 添加碰撞检测
    [self.collision addItem:self.redView];
    [self.collision addItem:self.greenView];
    [self.collision  addItem:self.blueView];
    self.collision.translatesReferenceBoundsIntoBoundary = YES;
    self.collision.collisionDelegate = self;


   __weak typeof(self) weakSelf = self;
        // 获取方块运动轨迹坐标
    self.collision.action = ^{
        NSLog(@"%@", NSStringFromCGRect(weakSelf.redView.frame));

    };

    CGFloat Y = self.view.frame.size.height;
    CGFloat X = self.view.frame.size.width;
    CGFloat height = self.view.frame.size.height;

    //设置红色的View为底边界,左边框跟右边框作为边界
    [self.collision addBoundaryWithIdentifier:@"collision1" fromPoint:CGPointMake(0,Y) toPoint:CGPointMake(X, Y)];
    [self.collision addBoundaryWithIdentifier:@"collision2" fromPoint:CGPointMake(0, 0) toPoint:CGPointMake(0, height)];
    [self.collision addBoundaryWithIdentifier:@"collision3" fromPoint:CGPointMake(X,0) toPoint:CGPointMake(X, height)];
    [self.animator addBehavior:self.collision];
    [self.animator addBehavior:self.gravity];  
}
</uitouch></pre>

<ul>
<li>碰撞开始时给被碰撞的物体添加重力仿真</li>
</ul>
<pre>
// UICollisionBehavior 代理行为
- (void)collisionBehavior:(UICollisionBehavior*)behavior beganContactForItem:(id <uidynamicitem>)item withBoundaryIdentifier:(nullable id <nscopying>)identifier atPoint:(CGPoint)p{

    if ([item isEqual:self.greenView]) {
        UIGravityBehavior * gravity = [[UIGravityBehavior alloc] initWithItems:@[self.greenView]];
        [self.animator addBehavior:gravity];
    }else if ([item isEqual:self.blueView]){
        UIGravityBehavior * gravity = [[UIGravityBehavior alloc] initWithItems:@[self.blueView]];
        [self.animator addBehavior:gravity];
    }

}
</nscopying></uidynamicitem></pre>

<h3 id="UISnapBehavior-吸附行为"><a href="#UISnapBehavior-吸附行为" class="headerlink" title="UISnapBehavior 吸附行为"></a>UISnapBehavior 吸附行为</h3><ul>
<li>创建仿真者</li>
</ul>
<pre>
self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];
</pre>

<ul>
<li>创建吸附对象</li>
</ul>
<pre>
-(UIView *)redView{
    if (_redView ==nil) {
        _redView = [[UIView alloc]initWithFrame:CGRectMake(p.x, p.y, 50, 50)];
        _redView.backgroundColor = [UIColor redColor];
        [self.view addSubview:_redView];
    }
    return _redView;
}
</pre>

<ul>
<li>开始吸附行为</li>
</ul>
<pre>
-(void)touchesBegan:(NSSet<uitouch *=""> *)touches withEvent:(UIEvent *)event{

    [self.animator removeAllBehaviors];
    UITouch * touch = touches.anyObject;
    CGPoint location = [touch locationInView:self.view];
    p = location;
    NSLog(@"%@",NSStringFromCGPoint(location));
     // 3 添加吸附事件
     UISnapBehavior *snap = [[UISnapBehavior alloc] initWithItem:self.redView snapToPoint:location];
    // 改变震动幅度，0表示振幅最大，1振幅最小
    snap.damping = 0.5;
    // 4. 将吸附事件添加到仿真者行为中
    [self.animator addBehavior:snap];

}
</uitouch></pre>

<h3 id="UIDynamicItemBehavior-迅猛移动弹跳摆动行为"><a href="#UIDynamicItemBehavior-迅猛移动弹跳摆动行为" class="headerlink" title="UIDynamicItemBehavior 迅猛移动弹跳摆动行为"></a>UIDynamicItemBehavior 迅猛移动弹跳摆动行为</h3><ul>
<li>创建仿真者</li>
</ul>
<pre>
self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];
</pre>

<ul>
<li>创建仿真行为</li>
</ul>
<pre>
-(UIGravityBehavior *)gravity{
    if (_gravity == nil) {
        _gravity = [[UIGravityBehavior alloc]init];
    }
    return _gravity;
}
-(UICollisionBehavior *)collision{
    if (_collision == nil) {
        _collision = [[UICollisionBehavior alloc]init];
         [_collision addBoundaryWithIdentifier:@"barrier" forPath:[UIBezierPath bezierPathWithRect:self.view.bounds]];
        _collision.translatesReferenceBoundsIntoBoundary = YES;
    }
    return _collision;
}
-(UIDynamicItemBehavior *)itemBehavior{
    if (_itemBehavior == nil) {
        _itemBehavior = [[UIDynamicItemBehavior alloc] init];
        _itemBehavior.elasticity = 1;
    }
    return _itemBehavior;
}
</pre>

<ul>
<li>生成小球，添加仿真事件</li>
</ul>
<pre>
-(void)touchesAddSquareView{
    float  viewWidth = 20;
    UIView * view = [[UIView alloc]initWithFrame:CGRectMake(p.x, p.y, viewWidth, viewWidth)];
    view.layer.cornerRadius = viewWidth / 2.0;
    view.backgroundColor = randomColor;
    [self performSelector:@selector(removeView:) withObject:view afterDelay:10];
    [self.view addSubview:view];
    [self.collision addItem:view];
    [self.itemBehavior addItem:view];
    [self.gravity addItem:view];
    [self.animator addBehavior:self.collision];
    [self.animator addBehavior:self.itemBehavior];
    [self.animator addBehavior:self.gravity];

}
</pre>

<ul>
<li>点触，移动和松开创建小球</li>
</ul>
<pre>
- (void)touchesBegan:(NSSet<uitouch *=""> *)touches withEvent:(UIEvent *)event
{
    UITouch * touch = touches.anyObject;
    CGPoint location = [touch locationInView:self.view];
    p = location;
    [self touchesAddSquareView];
}

- (void)touchesMoved:(NSSet<uitouch *=""> *)touches withEvent:(UIEvent *)event
{
    UITouch * touch = touches.anyObject;
    CGPoint location = [touch locationInView:self.view];
    p = location;
   [self touchesAddSquareView];
}
- (void)touchesEnded:(NSSet<uitouch *=""> *)touches withEvent:(UIEvent *)event
{
    [self touchesAddSquareView];
}
</uitouch></uitouch></uitouch></pre>

<ul>
<li>10s后删除小球和其物理仿真行为</li>
</ul>
<pre>
-(void)removeView:(UIView *)view{
    if (view == nil) {
        return;
    }
    [UIView animateWithDuration:.5 animations:^{
        view.alpha = 0;
    } completion:^(BOOL finished) {
        [view removeFromSuperview];
        [self.collision removeItem:view];
        [self.itemBehavior removeItem:view];
        [self.gravity removeItem:view];
    }];

}
</pre>

]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 1 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Swift_popAnimation实例]]]></title>
      <url>/2017/08/28/Swift-popAnimation%E5%AE%9E%E4%BE%8B/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/hamburger" target="_blank" rel="external">github地址</a></p>
<p>情人节在写博客也是蛮拼的</p>
<ol>
<li>Pod pop 如 [Swift_popAnimation初级]</li>
</ol>
<h3 id="动画思路"><a href="#动画思路" class="headerlink" title="动画思路"></a>动画思路</h3><pre>
   三条杠变叉：中间杠的消失和两边杠的偏移。
   叉变三条杠：两边杠的偏移和中间杠的出现。
</pre>

<ol>
<li><p>三条杠用三个view来代替，添加在一个button上。声明全局属性</p>
<pre>
 var  hamburger = true
 var  hamburgerButton : UIButton?
 var  top:UIView?
 var  middle:UIView?
 var  bottom:UIView?
</pre>
</li>
<li><p>实例化对象</p>
<pre><code>self.hamburgerButton = UIButton()
self.hamburgerButton?.backgroundColor = UIColor.black
self.hamburgerButton?.frame = CGRect(x: 100, y: 200, width: 150, height: 150)     
self.hamburgerButton?.layer.cornerRadius = 75
self.view.addSubview(hamburgerButton!)
self.hamburgerButton?.addTarget(self, action:#selector(didTapHamburgerButton), for: UIControlEvents.touchUpInside)
//三道杠
let sectionWidth:CGFloat = 80.0
let sectionHeight:CGFloat = 11.0
//top
top = UIView(frame: CGRect(x: (self.hamburgerButton?.bounds.size.width)! / 2 - sectionWidth / 2, y: 40, width: sectionWidth, height: sectionHeight))
top?.backgroundColor = UIColor.white
top?.isUserInteractionEnabled = false
top?.layer.cornerRadius = sectionHeight / 2
self.hamburgerButton?.addSubview(top!)
//middle
middle = UIView(frame: CGRect(x: (self.hamburgerButton?.bounds.size.width)! / 2 - sectionWidth / 2, y: 69, width: sectionWidth, height: sectionHeight))
middle?.backgroundColor = UIColor.white
middle?.isUserInteractionEnabled = false
middle?.layer.cornerRadius = sectionHeight / 2
self.hamburgerButton?.addSubview(middle!)
//bottom
bottom = UIView(frame: CGRect(x: (self.hamburgerButton?.bounds.size.width)! / 2 - sectionWidth / 2, y: 99, width: sectionWidth, height: sectionHeight))
bottom?.backgroundColor = UIColor.white
bottom?.isUserInteractionEnabled = false
bottom?.layer.cornerRadius = sectionHeight / 2
self.hamburgerButton?.addSubview(bottom!)
</code></pre></li>
</ol>
<h3 id="pop对象复用"><a href="#pop对象复用" class="headerlink" title="pop对象复用"></a>pop对象复用</h3><ol>
<li>颜色动画：<pre>
     var topColor = self.top?.pop_animation(forKey: "topColor") as! POPSpringAnimation?
     var bottomColor = self.top?.pop_animation(forKey: "bottomColor") as! POPSpringAnimation?
</pre></li>
<li>旋转动画：<pre>
     var topRotate = self.top?.layer.pop_animation(forKey: "topRotate") as! POPSpringAnimation?
     var bottomRotate = self.top?.layer.pop_animation(forKey: "bottomRotate") as! POPSpringAnimation?
</pre></li>
<li>位置动画：<pre>
     var topPosition = self.top?.layer.pop_animation(forKey: "topPosition")as!POPSpringAnimation?
     var bottomPosition = self.top?.layer.pop_animation(forKey: "bottomPosition")as!POPSpringAnimation?
</pre>

</li>
</ol>
<h3 id="三道杠变红叉叉"><a href="#三道杠变红叉叉" class="headerlink" title="三道杠变红叉叉"></a>三道杠变红叉叉</h3><pre>
 hamburger = false
            UIView.animate(withDuration: 0.2, animations: {
                self.middle?.alpha = 0
            })
            //变色
            if topColor != nil {
                topColor?.toValue = UIColor.red
            }else{
                topColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor)
                topColor?.toValue = UIColor.red
                topColor?.springBounciness = 0
                topColor?.springSpeed = 18
                top?.pop_add(topColor, forKey: "topColor")
            }
            if bottomColor != nil {
                bottomColor?.toValue = UIColor.red
            }else{
                bottomColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor)
                bottomColor?.toValue = UIColor.red
                bottomColor?.springBounciness = 0
                bottomColor?.springSpeed = 18
                bottom?.pop_add(topColor, forKey: "bottomColor")
            }
            //旋转
            if topRotate != nil {
                topRotate?.toValue = -Double.pi / 4
            }else{
                topRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation)
                topRotate?.toValue = -Double.pi / 4
                topRotate?.springBounciness = 11
                topRotate?.springSpeed = 18
                top?.layer.pop_add(topRotate, forKey: "topRotate")
            }
            if bottomRotate != nil {
                bottomRotate?.toValue = Double.pi / 4
            }else{
                bottomRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation)
                bottomRotate?.toValue = Double.pi / 4
                bottomRotate?.springBounciness = 11
                bottomRotate?.springSpeed = 18
                bottom?.layer.pop_add(bottomRotate, forKey: "bottomRotate")
            }
            //移动
            if topPosition != nil {
                topPosition?.toValue = 29
            }else{
                topPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY)
                topPosition?.toValue = 29
                topPosition?.springBounciness = 11
                topPosition?.springSpeed = 18
                top?.layer.pop_add(topPosition, forKey: "topPosition")
            }
            if bottomPosition != nil {
                bottomPosition?.toValue = -29
            }else{
                bottomPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY)
                bottomPosition?.toValue = -29
                bottomPosition?.springBounciness = 11
                bottomPosition?.springSpeed = 18
                bottom?.layer.pop_add(bottomPosition, forKey: "bottomPosition")
            }

}
</pre>

<h3 id="红叉叉变三道杠-逆向-gt-就还原一起改变值"><a href="#红叉叉变三道杠-逆向-gt-就还原一起改变值" class="headerlink" title="红叉叉变三道杠:逆向-&gt;就还原一起改变值"></a>红叉叉变三道杠:逆向-&gt;就还原一起改变值</h3><pre>
   hamburger = true
            UIView.animate(withDuration: 0.2, animations: {
                self.middle?.alpha = 1
            })
            //变色
            if topColor != nil {
                topColor?.toValue = UIColor.white
            }else{
                topColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor)
                topColor?.toValue = UIColor.white
                topColor?.springBounciness = 0
                topColor?.springSpeed = 18
                top?.pop_add(topColor, forKey: "topColor")
            }
            if bottomColor != nil {
                bottomColor?.toValue = UIColor.white
            }else{
                bottomColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor)
                bottomColor?.toValue = UIColor.white
                bottomColor?.springBounciness = 0
                bottomColor?.springSpeed = 18
                bottom?.pop_add(topColor, forKey: "bottomColor")
            }
            //旋转
            if topRotate != nil {
                topRotate?.toValue = 0
            }else{
                topRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation)
                topRotate?.toValue = 0
                topRotate?.springBounciness = 11
                topRotate?.springSpeed = 18
                top?.layer.pop_add(topRotate, forKey: "topRotate")
            }
            if bottomRotate != nil {
                bottomRotate?.toValue = 0
            }else{
                bottomRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation)
                bottomRotate?.toValue = 0
                bottomRotate?.springBounciness = 11
                bottomRotate?.springSpeed = 18
                bottom?.layer.pop_add(bottomRotate, forKey: "bottomRotate")
            }
            //移动
            if topPosition != nil {
                topPosition?.toValue = 0
            }else{
                topPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY)
                topPosition?.toValue = 0
                topPosition?.springBounciness = 11
                topPosition?.springSpeed = 18
                top?.layer.pop_add(topPosition, forKey: "topPosition")
            }
            if bottomPosition != nil {
                bottomPosition?.toValue = 0
            }else{
                bottomPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY)
                bottomPosition?.toValue = 0
                bottomPosition?.springBounciness = 11
                bottomPosition?.springSpeed = 18
                bottom?.layer.pop_add(bottomPosition, forKey: "bottomPosition")
            }


        }

    }
</pre>

<p>so easy<br><img src="/2017/08/28/Swift-popAnimation实例/san.png" alt=""><br><img src="/2017/08/28/Swift-popAnimation实例/hong.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Swift </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Swift_popAnimation应用]]]></title>
      <url>/2017/08/25/Swift-popAnimation%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/TongPopInstall" target="_blank" rel="external">github地址</a></p>
<p><img src="/2017/08/25/Swift-popAnimation应用/PopInstall.gif" alt="GIF"></p>
<ol>
<li>Pod pop如上篇文章</li>
<li>创建UIbutton类对象与storyboard绑定</li>
<li>应用touchesBegan ，touchesEnded</li>
</ol>
<h3 id="开始点击"><a href="#开始点击" class="headerlink" title="开始点击"></a>开始点击</h3><ol>
<li>缩小0.5倍</li>
<li>旋转半圈</li>
</ol>
<pre>
  //缩放动画
        var scale = self.pop_animation(forKey: TLscale)as?POPSpringAnimation
        if scale != nil {
            scale?.toValue = NSValue(cgPoint:CGPoint(x: 0.5, y: 0.5))
        }else{
       scale = POPSpringAnimation(propertyNamed: kPOPViewScaleXY)
            scale?.toValue = NSValue(cgPoint:CGPoint(x: 0.5, y: 0.5))
            scale?.springBounciness = 20
            scale?.springSpeed = 5
            self.pop_add(scale, forKey: TLscale)

        }
  //旋转动画
        var rotate = self.layer.pop_animation(forKey: TLrotate)as? POPSpringAnimation
        if rotate != nil {
            rotate?.toValue = Double.pi / 2
        }else{
            rotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation)
            rotate?.toValue = Double.pi / 2
            rotate?.springBounciness = 20
            rotate?.springSpeed = 18
            self.layer.pop_add(rotate, forKey: TLrotate)
        }
</pre>

<h3 id="结束点击"><a href="#结束点击" class="headerlink" title="结束点击"></a>结束点击</h3><ol>
<li>缩放1.0倍回到起始状态</li>
<li>旋转到起始位置</li>
</ol>
<pre>
  //缩放动画
        var scale = self.pop_animation(forKey: TLscale)as?POPSpringAnimation
        if scale != nil {
            scale?.toValue = NSValue(cgPoint:CGPoint(x: 1, y: 1))
        }else{
            scale = POPSpringAnimation(propertyNamed: kPOPViewScaleXY)
            scale?.toValue = NSValue(cgPoint:CGPoint(x: 1, y: 1))
            scale?.springBounciness = 20
            scale?.springSpeed = 5
            self.pop_add(scale, forKey: TLscale)
             }
  //旋转动画
        var rotate = self.layer.pop_animation(forKey: TLrotate)as? POPSpringAnimation
        if rotate != nil {
            rotate?.toValue = 0
        }else{
            rotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation)
            rotate?.toValue = 0
            rotate?.springBounciness = 20
            rotate?.springSpeed = 18
            self.layer.pop_add(rotate, forKey: TLrotate)
</pre>
]]></content>
      
        <categories>
            
            <category> Swift </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Swift_popAnimation初级]]]></title>
      <url>/2017/08/25/popAnimation%E5%88%9D%E7%BA%A7/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/RedBall" target="_blank" rel="external">github地址</a></p>
<p><img src="/2017/08/25/popAnimation初级/redBall.gif" alt="GIF"></p>
<p>先初尝popAnimation一些环境配置和方法调用，下篇会写实例应用</p>
<h3 id="Pods-pop"><a href="#Pods-pop" class="headerlink" title="Pods pop"></a>Pods pop</h3><ol>
<li>vim podfile</li>
</ol>
<pre>
platform :ios,'8.0'

target "RedBall" do

pod 'pop'

end
</pre>

<ol>
<li>pod install</li>
</ol>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><ol>
<li>宏定义</li>
</ol>
<pre>
let TLspin = "spin"
let TLmove = "move"
let TLcolor = "color"
let TLscale = "scale"
</pre>

<ol>
<li>属性定义</li>
</ol>
<pre>
    let redBall = UIView(frame: CGRect(x: 100, y: 200, width: 100, height: 100))
    let scale = POPSpringAnimation(propertyNamed:kPOPViewScaleXY)
    let move = POPSpringAnimation(propertyNamed: kPOPLayerPositionY)
    let spin = POPSpringAnimation(propertyNamed: kPOPLayerRotation)
    let color = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor)

</pre>

<ol>
<li><p>segmentContol创建</p>
<pre><code>let array = [&quot;放大&quot;,&quot;旋转&quot;,&quot;移动&quot;,&quot;变色&quot;,&quot;归位&quot;]

let segmentedControl = UISegmentedControl.init(items:array)

segmentedControl.frame = CGRect(x:50,y:50,width:self.view.frame.size.width-100 ,height:30)

segmentedControl.tintColor = UIColor.green

segmentedControl.backgroundColor = UIColor.red

segmentedControl.addTarget(self, action:#selector(segmentedControlChanged(segmented:)), for: UIControlEvents.valueChanged)

self.view .addSubview(segmentedControl);
</code></pre></li>
<li><p>动画代码</p>
<ol>
<li>pop放大，旋转，移动，变色，还原动画</li>
<li>springBounciness: 弹性振幅，范围0-20</li>
<li>springSpeed: 震动速度</li>
<li>pop_add: 加载动画</li>
</ol>
</li>
</ol>
<pre> 
    func redBallScale()  {
        // 放大动画
        scale?.toValue = NSValue(cgPoint:CGPoint(x: 2, y: 2))
        scale?.springBounciness = 20
        scale?.springSpeed = 1
        redBall.pop_add(scale, forKey: TLscale)
    }
    func redBallSpin()  {
        //旋转动画
        spin?.toValue = Double.pi * 4
        spin?.springBounciness = 20
        spin?.springSpeed = 5
        redBall.layer.pop_add(spin, forKey: TLspin)

    }
    func redBallMove()  {
        //y坐标位移动画
        move?.toValue = 500
        move?.springBounciness = 20
        move?.springSpeed = 5
        redBall.layer.pop_add(move, forKey: TLmove)
    }
    func redBallColor()  {
        //背景颜色变化
        color?.toValue = UIColor.green
        color?.springBounciness = 20
        color?.springSpeed = 5
        redBall.pop_add(color, forKey: TLcolor)

    }
</pre>


]]></content>
      
        <categories>
            
            <category> Swift </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[iOS-绑定Amazon]]]></title>
      <url>/2017/08/23/iOS-%E7%BB%91%E5%AE%9AAmazon/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/iOS_Amazon" target="_blank" rel="external">github地址</a></p>
<p>为实现echo语音控制只能家居，所以需要绑定亚马逊账号</p>
<h3 id="Install-the-Login-with-Amazon-SDK-for-iOS"><a href="#Install-the-Login-with-Amazon-SDK-for-iOS" class="headerlink" title="Install the Login with Amazon SDK for iOS"></a>Install the Login with Amazon SDK for iOS</h3><ol>
<li>下载亚马逊SDK <a href="https://images-na.ssl-images-amazon.com/images/G/01/lwa/sdk/LoginWithAmazonSDKForiOS._TTH_.zip" target="_blank" rel="external">LoginWithAmazonSDKForiOS.zip</a> </li>
<li>工程中拖入SDK LoginWithAmazon.framework </li>
<li>Target - BuildPhases - Link Binary With Libraries中添加framework<br><img src="/2017/08/23/iOS-绑定Amazon/FrameWork.png" alt=""></li>
</ol>
<h3 id="Register-with-Login-with-Amazon"><a href="#Register-with-Login-with-Amazon" class="headerlink" title="Register with Login with Amazon"></a>Register with Login with Amazon</h3><h4 id="注册亚马逊账号"><a href="#注册亚马逊账号" class="headerlink" title="注册亚马逊账号"></a>注册亚马逊账号</h4><p><a href="https://www.amazon.com/ap/register?clientContext=168-8975905-4767102&amp;openid.pape.max_auth_age=18000&amp;openid.return_to=https%3A%2F%2Flogin.amazon.com%2Fap-post-redirect&amp;prevRID=8DS9KWNHYGC5AH3NEF6R&amp;openid.identity=http%3A%2F%2Fspecs.openid.net%2Fauth%2F2.0%2Fidentifier_select&amp;openid.assoc_handle=amzn_lwa_landing&amp;openid.mode=checkid_setup&amp;siteState=clientContext%3D146-3143884-7961460%2CsourceUrl%3Dhttps%253A%252F%252Flogin.amazon.com%252Fagreement%2Csignature%3DiKv2yHIcj2BRW7gb6EL42A4KfOU24j3D&amp;marketPlaceId=ATVPDKIKX0DER&amp;openid.claimed_id=http%3A%2F%2Fspecs.openid.net%2Fauth%2F2.0%2Fidentifier_select&amp;pageId=amzn_lwa_landing&amp;openid.ns=http%3A%2F%2Fspecs.openid.net%2Fauth%2F2.0" target="_blank" rel="external">亚马逊注册</a></p>
<p><img src="/2017/08/23/iOS-绑定Amazon/RegisterAmazon.png" alt=""></p>
<h4 id="登录亚马逊账号"><a href="#登录亚马逊账号" class="headerlink" title="登录亚马逊账号"></a>登录亚马逊账号</h4><p><a href="https://www.amazon.com/ap/signin?clientContext=168-8975905-4767102&amp;openid.return_to=https%3A%2F%2Flogin.amazon.com%2Fap-post-redirect&amp;openid.identity=http%3A%2F%2Fspecs.openid.net%2Fauth%2F2.0%2Fidentifier_select&amp;openid.assoc_handle=amzn_lwa_landing&amp;openid.mode=checkid_setup&amp;marketPlaceId=ATVPDKIKX0DER&amp;openid.claimed_id=http%3A%2F%2Fspecs.openid.net%2Fauth%2F2.0%2Fidentifier_select&amp;pageId=amzn_lwa_landing&amp;openid.ns=http%3A%2F%2Fspecs.openid.net%2Fauth%2F2.0&amp;openid.pape.max_auth_age=18000&amp;siteState=clientContext%3D146-3143884-7961460%2CsourceUrl%3Dhttps%253A%252F%252Flogin.amazon.com%252Fagreement%2Csignature%3DiKv2yHIcj2BRW7gb6EL42A4KfOU24j3D" target="_blank" rel="external">亚马逊登录</a></p>
<p><img src="/2017/08/23/iOS-绑定Amazon/LoginAmazon.png" alt=""></p>
<ol>
<li>输入App的名称，链接和App图标等</li>
<li>注册地址 <a href="https://login.amazon.com/agreement" target="_blank" rel="external">App Console</a>.前提是你有亚马逊账号<br><img src="/2017/08/23/iOS-绑定Amazon/Register.png" alt=""></li>
</ol>
<h3 id="Add-iOS-Settings-to-an-Application"><a href="#Add-iOS-Settings-to-an-Application" class="headerlink" title="Add iOS Settings to an Application"></a>Add iOS Settings to an Application</h3><ol>
<li><a href="https://developer.amazon.com" target="_blank" rel="external">亚马逊</a> App应用界面，点击iOS设置，如果你的iOS App已经注册好，点击 API Key </li>
<li>需要输入你的Bundle ID,target - General<br><img src="/2017/08/23/iOS-绑定Amazon/bunldID.png" alt=""></li>
</ol>
<h3 id="Add-Your-API-Key-to-Your-App-Property-List"><a href="#Add-Your-API-Key-to-Your-App-Property-List" class="headerlink" title="Add Your API Key to Your App Property List"></a>Add Your API Key to Your App Property List</h3><ol>
<li>选择 project - Info.plist 添加APIKey ，选择copy，别出错<br><img src="/2017/08/23/iOS-绑定Amazon/API.png" alt=""></li>
</ol>
<h3 id="Add-a-URL-Scheme-to-Your-App-Property-List"><a href="#Add-a-URL-Scheme-to-Your-App-Property-List" class="headerlink" title="Add a URL Scheme to Your App Property List"></a>Add a URL Scheme to Your App Property List</h3><ol>
<li>选择 project - Info.plist 添加URL types</li>
<li>Item 0 Document Role 填写Editor。 Shames 填写 prefs</li>
<li>Item 1 identifier 填写bundle ID。 Shames 填写amzn-bundle ID</li>
<li>其他填写如下图<br><img src="/2017/08/23/iOS-绑定Amazon/URL.png" alt=""></li>
</ol>
<h3 id="Using-the-SDK-for-iOS-APIs"><a href="#Using-the-SDK-for-iOS-APIs" class="headerlink" title="Using the SDK for iOS APIs"></a>Using the SDK for iOS APIs</h3><p>创建亚马逊类，导入 #import&lt; LoginWithAmazon/LoginWithAmazon.h&gt;</p>
<h4 id="Using-the-SDK-for-iOS-APIs-1"><a href="#Using-the-SDK-for-iOS-APIs-1" class="headerlink" title="Using the SDK for iOS APIs"></a>Using the SDK for iOS APIs</h4><ol>
<li>在 AppDelegate 导入import &lt; LoginWithAmazon/LoginWithAmazon.h&gt;.</li>
<li>添加以下方法,返回亚马逊URL</li>
</ol>
<pre>
- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation {
    #pragma unused(application,annotation)
    // Pass on the url to the SDK to parse authorization code from the url.
    BOOL isValidRedirectLogInURL = [AMZNAuthorizationManager handleOpenURL:url sourceApplication:(NSString *)sourceApplication];

    if(!isValidRedirectLogInURL){
        return NO;
    }
    // App may also want to handle url
    return YES;
}
</pre>


<h4 id="Handle-the-Login-Button-and-Get-Profile-Data"><a href="#Handle-the-Login-Button-and-Get-Profile-Data" class="headerlink" title="Handle the Login Button and Get Profile Data"></a>Handle the Login Button and Get Profile Data</h4><ol>
<li>发出登录请求 userID ，profile，postalCode</li>
<li>successful 成功登录返回数据result.token，result.user，user.userID</li>
<li>error 回复错误</li>
<li>userDidCancel 用户自动取消</li>
</ol>
<pre>
- (IBAction)onLogInButtonClicked:(id)sender {
  // Build an authorize request.
  AMZNAuthorizeRequest *request = [[AMZNAuthorizeRequest alloc] init];
        request.scopes = [NSArray arrayWithObjects: 
        [AMZNProfileScope userID],
        [AMZNProfileScope profile], 
        [AMZNProfileScope postalCode]];

  // Make an Authorize call to the Login with Amazon SDK.
  [[AMZNAuthorizationManager sharedManager] authorize:request
    withHandler:^(AMZNAuthorizeResult *result, BOOL 
    userDidCancel, NSError *error) {
          if (error) { 
              // Handle errors from the SDK or authorization server. 
          } else if (userDidCancel) {
              // Handle errors caused when user cancels login.
          } else {
              // Authentication was successful.
              // Obtain the access token and user profile data.
              NSString *accessToken = result.token;
              AMZNUser *user = result.user;
              NSString *userID = user.userID;
          }
  }];
}
</pre>

<h4 id="Fetch-User-Profile-Data"><a href="#Fetch-User-Profile-Data" class="headerlink" title="Fetch User Profile Data"></a>Fetch User Profile Data</h4><ol>
<li>获取登录信息 user.userID，user.name，user.email，user.postalCode</li>
<li>在error时可以添加重新登录方法</li>
</ol>
<pre>
AMZNUser fetch:^(AMZNUser *user, NSError *error) {
  if (error) {
    // Error from the SDK, or no user has authorized to the app.
  } else if (user) {
    NSString *userID = user.userID;
    //NSString *name = user.name;
    //NSString *email = user.email;
    //NSString *postalCode = user.postalCode;
  }
}];
</pre>

<h4 id="Check-for-User-Login-at-Startup"><a href="#Check-for-User-Login-at-Startup" class="headerlink" title="Check for User Login at Startup"></a>Check for User Login at Startup</h4><pre>
// Build an authorize request.
   AMZNAuthorizeRequest *request = [[AMZNAuthorizeRequest alloc] init];
    request.scopes = [NSArray arrayWithObjects: 
  // [AMZNProfileScope userID],
     [AMZNProfileScope profile], 
    [AMZNProfileScope postalCode]];

   request.interactiveStrategy = AMZNInteractiveStrategyNever;

   [[AMZNAuthorizationManager sharedManager] authorize:request
     withHandler:^(AMZNAuthorizeResult *result, BOOL 
      userDidCancel, NSError *error) {
        if (error) { 
             // Error from the SDK, indicating the user was not previously authorized to your app for the requested scopes. 
         } else {
             // The user was previously authorized to your app.
             // Obtain the access token and user profile data.
                 NSString *accessToken = result.token;
             AMZNUser *user = result.user;
             NSString *userID = user.userID;
             }
       }];
</pre>

<h4 id="Clear-Authorization-Data-and-Log-Out-a-User"><a href="#Clear-Authorization-Data-and-Log-Out-a-User" class="headerlink" title="Clear Authorization Data and Log Out a User"></a>Clear Authorization Data and Log Out a User</h4><ol>
<li>退出登录</li>
<li>清除亚马逊数据</li>
</ol>
<pre>
[[AMZNAuthorizationManager sharedManager] signOut:^(NSError * _Nullable error) {
  if (!error) {
    // error from the SDK or Login with Amazon authorization server.
  }
}];
</pre>

<p>注：亚马逊账号绑定在本地存储，所以多手机登录需要存储userID到自己服务器，实现多手机登录状态回显</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 2 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[iOS-OpenGL图形绘制二]]]></title>
      <url>/2017/08/23/iOS-OpenGL%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h3 id="Welcome-to-my-blog-Thanks"><a href="#Welcome-to-my-blog-Thanks" class="headerlink" title="Welcome to my blog. Thanks."></a>Welcome to my blog. Thanks.</h3><p>Dome: <a href="https://github.com/princeSmall/iOS_OpenGL_layer" target="_blank" rel="external">github地址</a></p>
<p>本章讲如何用原生OpenGL绘制图形及渲染图片</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol>
<li><p>创建一个新的工程，点击target-&gt;Build Phases -&gt; Link Binary With Libraries添加库</p>
<ul>
<li>GLKit.framework</li>
<li>OpenGLES.framework</li>
</ul>
</li>
<li><p>导入头文件:</p>
<p>  #import &lt; OpenGLES/ES2/gl.h &gt;</p>
<p>  #import &lt; OpenGLES/ES2/glext.h &gt;</p>
</li>
</ol>
<h3 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h3><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><p>一个三角线</p>
<pre><code>const GLfloat Trianglevertices[] = {
0.0f,  0.5f, 0.0f,
-0.5f, -0.5f, 0.0f,
0.5f,  -0.5f, 0.0f };

const GLubyte Triangleindices[] = {
0,1,2
};
</code></pre><h4 id="VBO申请空间并绑定目标"><a href="#VBO申请空间并绑定目标" class="headerlink" title="VBO申请空间并绑定目标"></a>VBO申请空间并绑定目标</h4><pre><code>-(void)OneRenderVerticesAnColorsForTriangles{
GLuint vertexBuffer;
glGenBuffers(1, &amp;vertexBuffer);
// 绑定vertexBuffer到GL_ARRAY_BUFFER目标
glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
// 为VBO申请空间，初始化并传递数据
glBufferData(GL_ARRAY_BUFFER, sizeof(Trianglevertices), Trianglevertices, GL_STATIC_DRAW);

GLuint indexBuffer;
glGenBuffers(1, &amp;indexBuffer);
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Triangleindices), Triangleindices, GL_STATIC_DRAW);

// 使用VBO时，最后一个参数0为要获取参数在GL_ARRAY_BUFFER中的偏移量
glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 0, 0);
glEnableVertexAttribArray(_positionSlot);

glDrawElements(GL_TRIANGLES, sizeof(Triangleindices)/sizeof(Triangleindices[0]), GL_UNSIGNED_BYTE, 0);
}
</code></pre><h3 id="四边形"><a href="#四边形" class="headerlink" title="四边形"></a>四边形</h3><h4 id="宏定义-1"><a href="#宏定义-1" class="headerlink" title="宏定义"></a>宏定义</h4><p>定义一个Vertex结构, 其中包含了坐标和颜色</p>
<pre><code>typedef struct {
float Position[3];
float Color[4];
} Vertex;
</code></pre><p>顶点数组</p>
<pre><code>const Vertex Vertices[] = {
{{-1,-1,0}, {0,0,0,1}},// 左下，黑色
{{1,-1,0}, {1,0,0,1}}, // 右下，红色
{{-1,1,0}, {0,0,1,1}}, // 左上，蓝色
{{1,1,0}, {0,1,0,1}},  // 右上，绿色
};
</code></pre><p>索引数组</p>
<pre><code>const GLubyte Indices[] = {
0,1,2, // 三角形0
1,2,3  // 三角形1
};
</code></pre><h4 id="VBO申请空间并绑定目标-1"><a href="#VBO申请空间并绑定目标-1" class="headerlink" title="VBO申请空间并绑定目标"></a>VBO申请空间并绑定目标</h4><ol>
<li>取出Vertices数组中的坐标点值，赋给_positionSlot</li>
<li>取出Colors数组中的每个坐标点的颜色值，赋给_colorSlot</li>
<li>绘制两个三角形，不复用顶点，因此需要6个顶点坐标。</li>
<li>V0-V1-V2, V3-V4-V5</li>
</ol>
<h3 id="通用部分"><a href="#通用部分" class="headerlink" title="通用部分"></a>通用部分</h3><h4 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h4><pre><code>EAGLContext * _context;
CAEAGLLayer * _EALayer;
GLuint _colorBufferRender; // 渲染缓冲区
GLuint _frameBuffer;       // 帧缓冲区
GLuint _positionSlot;      // 用于绑定shader中的Position参数
GLuint _colorSlot;         // 用于绑定shader中的SourceColor参数
GLuint _glProgram;
</code></pre><h4 id="颜色和离屏渲染"><a href="#颜色和离屏渲染" class="headerlink" title="颜色和离屏渲染"></a>颜色和离屏渲染</h4><ol>
<li>生成一个renderBuffer，id是_colorRenderBuffer</li>
<li>设置为当前renderBuffer</li>
<li>为color renderbuffer 分配存储空间</li>
<li>FBO用于管理colorRenderBuffer，离屏渲染</li>
<li>设置为当前framebuffer</li>
<li><p>将 _colorRenderBuffer 装配到 GL_COLOR_ATTACHMENT0 这个装配点上</p>
<pre><code>-(void)setColorAndFrameBufferRender{
 if (_colorBufferRender) {
glDeleteRenderbuffers(1, &amp;_colorBufferRender);
_colorBufferRender = 0;
 } 
 if (_frameBuffer) {
glDeleteFramebuffers(1, &amp;_frameBuffer);
_frameBuffer = 0;
}
glGenRenderbuffers(1, &amp;_colorBufferRender);
glBindRenderbuffer(GL_RENDERBUFFER, _colorBufferRender);
[_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:_EALayer];
glGenFramebuffers(1, &amp;_frameBuffer);
glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);
glFramebufferRenderbuffer(GL_FRAMEBUFFER,
                      GL_COLOR_ATTACHMENT0,
                      GL_RENDERBUFFER,
                      _colorBufferRender);
 }
</code></pre></li>
</ol>
<h4 id="创建绘制对象"><a href="#创建绘制对象" class="headerlink" title="创建绘制对象"></a>创建绘制对象</h4><ol>
<li>setup context, 渲染上下文，管理所有绘制的状态，命令及资源信息。</li>
<li>setup layer, 必须要是CAEAGLLayer才行，才能在其上描绘OpenGL内容             </li>
<li>如果在viewController中，使用[self.view.layer addSublayer:eaglLayer];</li>
<li><p>如果在view中，可以直接重写UIView的layerClass类方法即可return [CAEAGLLayer class]。</p>
<pre><code>- (void)setContentViewAndCAEGLayer{
  _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];
 [EAGLContext setCurrentContext:_context];  
 _EALayer = (CAEAGLLayer*)self.view.layer;
 _EALayer.frame = self.view.frame;
 _EALayer.opaque = YES;
 _EALayer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithBool:YES],kEAGLDrawablePropertyRetainedBacking,kEAGLColorFormatRGBA8,kEAGLDrawablePropertyColorFormat, nil];
 }
</code></pre></li>
</ol>
<h4 id="设置清屏"><a href="#设置清屏" class="headerlink" title="设置清屏"></a>设置清屏</h4><ol>
<li>设置清屏颜色</li>
<li>用来指定要用清屏颜色来清除由mask指定的buffer，此处是color buffer</li>
<li><p>将指定renderBuffer渲染在屏幕上</p>
<pre><code>-(void)glClear{
glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
glClear(GL_COLOR_BUFFER_BIT);
glViewport(0, 0, self.view.frame.size.width , self.view.frame.size.height);
}
</code></pre></li>
</ol>
<h3 id="离屏渲染显示绘制图片"><a href="#离屏渲染显示绘制图片" class="headerlink" title="离屏渲染显示绘制图片"></a>离屏渲染显示绘制图片</h3><h3 id="创建glsl文件：建一个empty文件，修改后缀即可"><a href="#创建glsl文件：建一个empty文件，修改后缀即可" class="headerlink" title="创建glsl文件：建一个empty文件，修改后缀即可"></a>创建glsl文件：建一个empty文件，修改后缀即可</h3><p>三角形Fragment</p>
<pre><code>precision mediump float;
void main(void) {
gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); 
}
</code></pre><p>三角形Vertex</p>
<pre><code>attribute vec4 Position;
void main(void) {
gl_Position = Position;   
}
</code></pre><p>四边形Fragment</p>
<pre><code>varying lowp vec4 DestinationColor;
void main(void) {
gl_FragColor = DestinationColor; 
}
</code></pre><p>四边形Vertex</p>
<pre><code>attribute vec4 Position;  
attribute vec4 SourceColor;  
varying vec4 DestinationColor;
void main(void) {
   DestinationColor = SourceColor;
   gl_Position = Position;
}
</code></pre><h4 id="创建一个分类继承NSObject"><a href="#创建一个分类继承NSObject" class="headerlink" title="创建一个分类继承NSObject"></a>创建一个分类继承NSObject</h4><p>实现以下两个类方法</p>
<pre><code>+ (GLuint)compileShader:(NSString*)shaderName withType:(GLenum)shaderType;

+ (GLuint)compileShaders:(NSString *)shaderVertex shaderFragment:(NSString *)shaderFragment;
</code></pre><h4 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h4><p>四边形Shaders</p>
<pre><code>- (void)processShaders {
_glProgram = [TLShaderOperation compileShaders:@&quot;Vertex&quot; shaderFragment:@&quot;Fragment&quot;];
glUseProgram(_glProgram);
_positionSlot = glGetAttribLocation(_glProgram, &quot;Position&quot;);
_colorSlot = glGetAttribLocation(_glProgram, &quot;SourceColor&quot;);
}
</code></pre><p>三角形Shaders</p>
<pre><code>- (void)processTriangleShaders {
// 编译shaders
_glProgram = [TLShaderOperation compileShaders:@&quot;TriangleVertex&quot; shaderFragment:@&quot;TriangleFragment&quot;];
glUseProgram(_glProgram);
// 获取指向vertex shader传入变量的指针, 然后就通过该指针来使用
// 即将_positionSlot 与 shader中的Position参数绑定起来
glGetAttribLocation(_glProgram, &quot;Position&quot;);
}
</code></pre><h4 id="获取图片"><a href="#获取图片" class="headerlink" title="获取图片"></a>获取图片</h4><ol>
<li>unbind the shader</li>
<li>从FBO中读取图像数据，离屏渲染。</li>
<li>图像经过render之后，已经在FBO中了，即使不将其拿到RenderBuffer中，依然可以使用getResultImage取到图像数据。</li>
<li>用[_eaglContext presentRenderbuffer:GL_RENDERBUFFER];，实际上就是将FBO中的图像拿到RenderBuffer中（即屏幕上）</li>
</ol>
<pre>
- (UIImage *)getResultImage {

    CGSize currentFBOSize = self.view.frame.size;
    NSUInteger totalBytesForImage = (int)currentFBOSize.width * (int)currentFBOSize.height * 4;

    GLubyte *_rawImagePixelsTemp = (GLubyte *)malloc(totalBytesForImage);

    glReadPixels(0, 0, (int)currentFBOSize.width, (int)currentFBOSize.height, GL_RGBA, GL_UNSIGNED_BYTE, _rawImagePixelsTemp);
    glUseProgram(0);

    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, _rawImagePixelsTemp, totalBytesForImage, (CGDataProviderReleaseDataCallback)&freeData);
    CGColorSpaceRef defaultRGBColorSpace = CGColorSpaceCreateDeviceRGB();

    CGImageRef cgImageFromBytes = CGImageCreate((int)currentFBOSize.width, (int)currentFBOSize.height, 8, 32, 4 * (int)currentFBOSize.width, defaultRGBColorSpace, kCGBitmapByteOrderDefault, dataProvider, NULL, NO, kCGRenderingIntentDefault);
    UIImage *finalImage = [UIImage imageWithCGImage:cgImageFromBytes scale:1.0 orientation:UIImageOrientationDownMirrored];

    CGImageRelease(cgImageFromBytes);
    CGDataProviderRelease(dataProvider);
    CGColorSpaceRelease(defaultRGBColorSpace);

    return finalImage;
}
void freeData(void *info, const void *data, size_t size) {
    free((unsigned char *)data);
}
</pre>

<h4 id="用于显示图片"><a href="#用于显示图片" class="headerlink" title="用于显示图片"></a>用于显示图片</h4><pre><code>UIImage *image = [self getResultImage];

if (image) {
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100,  100, 100, 100)];
    imageView.backgroundColor = [UIColor whiteColor];
    imageView.contentMode = UIViewContentModeScaleAspectFit;
    imageView.image = image;
    [self.view addSubview:imageView];
}
</code></pre><p><img src="/2017/08/23/iOS-OpenGL图形绘制二/Triangle.png" alt="Triangle"><br><img src="/2017/08/23/iOS-OpenGL图形绘制二/Quadrangle.png" alt="Quadrangle"></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 1 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[iOS_OpenGL环境搭建和图形绘制]]]></title>
      <url>/2017/08/22/iOS-OpenGL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="Welcome-to-my-blog-Thanks"><a href="#Welcome-to-my-blog-Thanks" class="headerlink" title="Welcome to my blog. Thanks."></a>Welcome to my blog. Thanks.</h3><p>Dome: <a href="https://github.com/princeSmall/iOS_OpenGL" target="_blank" rel="external">github地址</a></p>
<p>个人觉得OpenGl图形绘制很酷所以专研了一段时间，记录供以后自己使用和小白学习。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol>
<li><p>创建一个新的工程，点击target-&gt;Build Phases -&gt; Link Binary With Libraries添加库</p>
<ul>
<li>GLKit.framework</li>
<li>OpenGLES.framework</li>
</ul>
</li>
<li><p>导入 #import <glkit glkit.h=""> 头文件</glkit></p>
</li>
</ol>
<p>因为我用GLKBaseEffect绘制的，所以不需要导入更多的头文件</p>
<h3 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h3><h4 id="一个顶点数组对象会储存以下这些内容："><a href="#一个顶点数组对象会储存以下这些内容：" class="headerlink" title="一个顶点数组对象会储存以下这些内容："></a>一个顶点数组对象会储存以下这些内容：</h4><ul>
<li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</li>
<li>通过glVertexAttribPointer设置的顶点属性配置。</li>
<li>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</li>
</ul>
<h4 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h4><pre>
float vertices[] = {
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.0f,  0.5f, 0.0f
};
</pre>

<h4 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h4><pre>
typedef struct {
    GLfloat Positon[3];//位置
    GLfloat Color[4];//颜色

} Vertex;

顶点和颜色数组
const Vertex squareVertexData[] = {

    { 0.5f,  0.5f, -0.9f,  1.0f, 0.0f, 0.0f, 1.0f},  //0
    {-0.5f,  0.5f, -0.9f,  0.0f, 1.0f, 0.0f, 1.0f},  //1
    { 0.5f, -0.5f, -0.9f,  0.0f, 0.0f, 1.0f, 1.0f},  //2
    {-0.5f, -0.5f, -0.9f,  0.0f, 0.0f, 0.0f, 1.0f}   //3

};
三角形数组
const GLubyte Indices[] = {
    0, 1, 2,
    2, 1, 3
};
</pre>


<h3 id="顶点数组对象：Vertex-Array-Object，VBO"><a href="#顶点数组对象：Vertex-Array-Object，VBO" class="headerlink" title="顶点数组对象：Vertex Array Object，VBO"></a>顶点数组对象：Vertex Array Object，VBO</h3><ul>
<li><p>使用glGenBuffers函数和一个缓冲ID生成一个VBO对象：<br>unsigned int VBO;<br>glGenBuffers(1, &amp;VBO);</p>
</li>
<li><p>glBindBuffer函数把新创建的缓冲绑定到GL_ARRAY_BUFFER目标上：<br>glBindBuffer(GL_ARRAY_BUFFER, VBO);  </p>
</li>
<li><p>我们可以调用glBufferData函数，它会把之前定义的顶点数据复制到缓冲的内存中：<br>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);<br>glBufferData：</p>
</li>
</ul>
<ol>
<li>它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上</li>
<li>第二个参数指定传输数据的大小(以字节为单位)；用一个简单的sizeof计算出顶点数据大小就行</li>
<li>第三个参数是我们希望发送的实际数据。</li>
<li>第四个参数指定了我们希望显卡如何管理给定的数据<ul>
<li>GL_STATIC_DRAW ：数据不会或几乎不会改变。</li>
<li>GL_DYNAMIC_DRAW：数据会被改变很多。</li>
<li>GL_STREAM_DRAW ：数据每次绘制时都会改变。</li>
</ul>
</li>
</ol>
<p>现在我们已经把顶点数据储存在显卡的内存中，用VBO这个顶点缓冲对象管理</p>
<ul>
<li><p>创建一个VAO和创建一个VBO很类似：<br>unsigned int VAO;<br>glGenVertexArrays(1, &amp;VAO);</p>
</li>
<li><p>要想使用VAO，要做的只是使用glBindVertexArray绑定VAO</p>
<ol>
<li>绑定VAO<br>glBindVertexArray(VAO);</li>
<li>把顶点数组复制到缓冲中供OpenGL使用<br>glBindBuffer(GL_ARRAY_BUFFER, VBO);<br>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</li>
<li>设置顶点属性指针<br>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 <em> sizeof(float), (void</em>)0);<br>glEnableVertexAttribArray(0);</li>
</ol>
</li>
</ul>
<h4 id="三角形-1"><a href="#三角形-1" class="headerlink" title="三角形"></a>三角形</h4><ol>
<li>GL_ARRAY_BUFFER用于顶点数组</li>
<li>绑定vertexBuffer到GL_ARRAY_BUFFER</li>
<li>给VBO传递数据</li>
<li>取出地址</li>
<li>取出颜色</li>
<li>glVertexAttribPointer的最后一个参数是要获取的参数在GL_ARRAY_BUFFER（每一个Vertex）的偏移量</li>
</ol>
<pre>
- (void)setupVBOs{
    GLuint verticesBuffer;
    glGenBuffers(1, &verticesBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, verticesBuffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);
    glEnableVertexAttribArray(GLKVertexAttribPosition);
    glEnableVertexAttribArray(GLKVertexAttribColor);
    glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 6, (GLfloat *)NULL + 0);
    glVertexAttribPointer(GLKVertexAttribColor, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 6, (GLfloat *)NULL + 3);
}
</pre>

<h4 id="多边形-1"><a href="#多边形-1" class="headerlink" title="多边形"></a>多边形</h4><ol>
<li>申请一个标识符</li>
<li>把标识符绑定到GL_ARRAY_BUFFER上</li>
<li>把顶点数据从cpu内存复制到gpu内存</li>
<li>开启对应的顶点属性</li>
<li>设置合适的格式从buffer里面读取数据</li>
</ol>
<pre>
- (void)setupVBOs{
    GLuint buffer;
    glGenBuffers(1, &buffer);   
    glBindBuffer(GL_ARRAY_BUFFER, buffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(squareVertexData), squareVertexData, GL_STATIC_DRAW);
    GLuint elementBuffer;
    glGenBuffers(1, &elementBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW);  
    glEnableVertexAttribArray(GLKVertexAttribPosition);  
    glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), 0);
    glEnableVertexAttribArray(GLKVertexAttribNormal);
    glVertexAttribPointer(GLKVertexAttribNormal, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid *) (sizeof(GLfloat) * 3));
    glEnableVertexAttribArray(GLKVertexAttribColor);
    glVertexAttribPointer(GLKVertexAttribColor, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid *) (sizeof(GLfloat) * 6)); 
    glEnableVertexAttribArray(GLKVertexAttribTexCoord0); 
    glVertexAttribPointer(GLKVertexAttribTexCoord0, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid *) (sizeof(GLfloat) * 10));
}
</pre>

<h3 id="GLKViewDelegate"><a href="#GLKViewDelegate" class="headerlink" title="GLKViewDelegate"></a>GLKViewDelegate</h3><ol>
<li>启动着色器</li>
<li>添加背景颜色</li>
<li>绘制图形<pre>
-(void)glkView:(GLKView *)view drawInRect:(CGRect)rect
{
[TLEffect prepareToDraw];
glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
glDrawArrays(GL_TRIANGLES, 0, 3);    
}
</pre>

</li>
</ol>
<h3 id="在GLKView上绘制OpenGL内容"><a href="#在GLKView上绘制OpenGL内容" class="headerlink" title="在GLKView上绘制OpenGL内容"></a>在GLKView上绘制OpenGL内容</h3><pre>
- (void)setupContext{

    context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2];
    if (!context) {
        NSLog(@"Failed to initialize OpenGLES 2.0 context");
        exit(1);
    }
    [EAGLContext setCurrentContext:context];
    GLKView *view = [[GLKView alloc]init];
    view.delegate = self;
    view.frame = self.view.frame;
    view.context = context;

    view.drawableColorFormat = GLKViewDrawableColorFormatRGBA8888;
    if (![EAGLContext setCurrentContext:context]) {
        NSLog(@"Failed to set current OpenGL context");
        exit(1);
    }
    [self.view addSubview:view];
}
</pre>

<p><img src="/2017/08/22/iOS-OpenGL环境搭建和图形绘制/triangle.png" alt="T"><br><img src="/2017/08/22/iOS-OpenGL环境搭建和图形绘制/quadrangle.png" alt="Q"></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 1 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[iOS_定时器动画的使用]]]></title>
      <url>/2017/08/18/%E5%AE%9A%E6%97%B6%E5%99%A8timer/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/Timer" target="_blank" rel="external">github 地址</a></p>
<p> 项目中智能灯有个定时开关的功能，需要在界面上实现时间选择，动画走动然后就写了这个功能实现倒计时</p>
<h3 id="实现准备"><a href="#实现准备" class="headerlink" title="实现准备"></a>实现准备</h3><h4 id="时间数组："><a href="#时间数组：" class="headerlink" title="时间数组："></a>时间数组：</h4><pre>
1. hourArray   存放小时的数组
2. minuteArray 存放分钟的数组
 _hourArray = [NSMutableArray array];
    for (int i = 0; i < 24; i ++) {
        [_hourArray addObject:[NSString stringWithFormat:@"%d",i]];
    }
    _minuteArray = [NSMutableArray array];
    for (int i = 1; i < 60; i ++) {
        [_minuteArray addObject:[NSString stringWithFormat:@"%d",i]];
    }

</pre>

<h4 id="宏定义："><a href="#宏定义：" class="headerlink" title="宏定义："></a>宏定义：</h4><pre>
 #define WIN_WIDTH  [self.view.bounds.size.width]
 #define WIN_HEIGHT [self.view.bounds.size.height]
 #define BACKCOLOR  [UIColor colorWithRed:241/255.0 green:241/255.0 blue:241/255.0 alpha:1]
 #define BARCOLOR  [QPUtilities colorWithHexString:@"#242947" alpha:1.f]
</pre>

<h4 id="全局变量："><a href="#全局变量：" class="headerlink" title="全局变量："></a>全局变量：</h4><pre>
{
    BOOL OpenOrClose;
    dispatch_source_t _timer;
    int hours;
    int minites;
    int secondTotal;
    int delayTotal;
}
</pre>

<h3 id="时间选择器UIPickView"><a href="#时间选择器UIPickView" class="headerlink" title="时间选择器UIPickView"></a>时间选择器UIPickView</h3><h4 id="懒加载："><a href="#懒加载：" class="headerlink" title="懒加载："></a>懒加载：</h4><pre>
-(StellarTimeView *)dateTimeView{
    if (_dateTimeView == nil) {
        _dateTimeView =[[StellarTimeView alloc]initWithFrame:CGRectMake(0, 40, self.dateView.frame.size.width, self.view.bounds.size.height / 2 - 100)];
    }
    return _dateTimeView;
}
</pre>

<h4 id="pragma-mark-–-UIPickerViewDateSource"><a href="#pragma-mark-–-UIPickerViewDateSource" class="headerlink" title="pragma mark – UIPickerViewDateSource"></a>pragma mark – UIPickerViewDateSource</h4><pre>
- (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView {
    return 3;
}
-(NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component {
    if (component == 0) {
        return (unsigned)[_hourArray count];
    }else if (component == 1){
        return 1;
    }else
        return (unsigned)[_minuteArray count];
}
</pre>

<h4 id="pragma-mark-–-UIPickerViewDelegate"><a href="#pragma-mark-–-UIPickerViewDelegate" class="headerlink" title="pragma mark – UIPickerViewDelegate"></a>pragma mark – UIPickerViewDelegate</h4><pre>
-(CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent:(NSInteger)component {
    return 60;
}
-(CGSize)rowSizeForComponent:(NSInteger)component{  
    CGSize  size = CGSizeFromString(@"20");
    return  size;
}

-(void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component
{
    if (component == 0) {
        NSString  *_proNameStr = [_hourArray objectAtIndex:(unsigned)row];
        hours = [_proNameStr intValue];
    }else if (component == 1){

   }
   else {
        NSString  *_proTimeStr = [_minuteArray objectAtIndex:(unsigned)row];
        minites = [_proTimeStr intValue];
    }   
}
-(NSString*)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component
{
    if (component == 0) {
        return [_hourArray objectAtIndex:(unsigned)row];
    }else if (component == 1){
        return @":";
    }
    else {
        return [_minuteArray objectAtIndex:(unsigned)row];      
    }
}
</pre>

<h3 id="动画绘制"><a href="#动画绘制" class="headerlink" title="动画绘制"></a>动画绘制</h3><h4 id="懒加载：-1"><a href="#懒加载：-1" class="headerlink" title="懒加载："></a>懒加载：</h4><pre>
-(StellarTimeView *)dateTimeView{
    if (_dateTimeView == nil) {
        _dateTimeView =[[StellarTimeView alloc]initWithFrame:CGRectMake(0, 40, self.dateView.frame.size.width, self.view.bounds.size.height / 2 - 100)];
    }
    return _dateTimeView;
}
</pre>

<h4 id="添加一个navgationbar"><a href="#添加一个navgationbar" class="headerlink" title="添加一个navgationbar"></a>添加一个navgationbar</h4><pre>
- (void)setNavigationbar
{   
    CGRect screenRect = [[UIScreen mainScreen] bounds];
    UINavigationBar *navigationBar = [[UINavigationBar alloc] initWithFrame:CGRectMake(0, 0, screenRect.size.width, 49)];
    navigationBar.tintColor = [UIColor blackColor];
    navigationBar.backgroundColor = [UIColor greenColor];
    //创建 UINavigationItem
    UINavigationItem * navigationBarTitle = [[UINavigationItem alloc] initWithTitle:@"UINavigationBar"];
    [navigationBar pushNavigationItem: navigationBarTitle animated:YES];
    [self.view addSubview: navigationBar]; 

}
</pre>

<h4 id="注：-动画类已封装只需要传入Percent和progressView"><a href="#注：-动画类已封装只需要传入Percent和progressView" class="headerlink" title="注： 动画类已封装只需要传入Percent和progressView"></a>注： 动画类已封装只需要传入Percent和progressView</h4><h3 id="定时器的处理"><a href="#定时器的处理" class="headerlink" title="定时器的处理"></a>定时器的处理</h3><pre><code>- (void)timeHeadle{         
    if (_timer==nil) {
    __block int timeout = 0; //倒计时时间
        timeout = secondTotal;
        [self setIsTotalTimeSelect:secondTotal];
    if (timeout!=0) {
        dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
        _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);
        dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),(uint64_t) 1.0 * NSEC_PER_SEC, 0); //每秒执行
        dispatch_source_set_event_handler(_timer, ^{
            if(timeout&lt;=0){ //倒计时结束，关闭时界面显示

      dispatch_source_cancel(_timer);

    _timer = nil;

       dispatch_async(dispatch_get_main_queue(), ^{

     [self timeHide];

                });

            }
      else{
       int hour = (int)(timeout/3600);
       int minute = (int)(timeout-hour*3600)/60;                            
       int second = timeout-hour*3600-minute*60;

     dispatch_async(dispatch_get_main_queue(), ^{

                    if (secondTotal == 0) {
             int  total =[self isTotalTimeSelect];
                        self.dateTimeView.percent = (CGFloat)(total-delayTotal) / total + (CGFloat)(delayTotal- timeout) / total;
                    }
                else{
                        self.dateTimeView.percent = (CGFloat)(secondTotal-timeout)/(CGFloat)secondTotal;
                    }
                if (hour&lt;10) {
                     if (minute&lt;10) {
                          if (second&lt;10) {
                                self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:0%d&quot;,hour,minute,second];
                            }else{
                                self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:%d&quot;,hour,minute,second];
                            }
                        }else {
                            if (second&lt;10) {
                                self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:0%d&quot;,hour,minute,second];
                            }else{
                                self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:%d&quot;,hour,minute,second];
                            }
                        }
                    }else{
                        if (minute&lt;10) {
                            if (second&lt;10) {
                                self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:0%d&quot;,hour,minute,second];
                            }else{
                                self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:%d&quot;,hour,minute,second];
                            }
                        }else {
                            if (second&lt;10) {
                                self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:0%d&quot;,hour,minute,second];
                            }else{
                                self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:%d&quot;,hour,minute,second];
                            }
                        }
                    }
                });
                timeout--;
            }
        });
        dispatch_resume(_timer);
    }else{
        self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;00:00:00&quot;];
    }
    }
     }
</code></pre><p><img src="/2017/08/18/定时器timer/timeSelect.png" alt="时间选择"><br><img src="/2017/08/18/定时器timer/timeRun.png" alt="时间动画"></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[[iOS_CollectionViewCell的增删移]]]></title>
      <url>/2017/08/11/%E5%A2%9E%E5%88%A0%E7%A7%BB/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/CollectionViewCell.git" target="_blank" rel="external"> github 地址</a></p>
<p>   今日看到某娱乐项目选择增删移很好玩，周五上午没事就写了一个。<br>   利用CollectionViewCell，将数据持久化保存在infoplist。<br>   再也不怕回到解放前了。主要分[已添加]–[待添加]–[未添加]–[删除添加]</p>
<h3 id="CollectionViewCell"><a href="#CollectionViewCell" class="headerlink" title="CollectionViewCell"></a>CollectionViewCell</h3><pre>
 UIBarButtonItem * rightItem = [[UIBarButtonItem alloc]initWithTitle:@"新增加" style:UIBarButtonItemStylePlain target:self action:@selector(add)];
    self.navigationItem.rightBarButtonItem = rightItem;
    UICollectionViewFlowLayout * layout = [[UICollectionViewFlowLayout alloc]init];
    layout.itemSize = CGSizeMake(50, 50);
    layout.scrollDirection = UICollectionViewScrollDirectionVertical;
    self.collectionView = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height) collectionViewLayout:layout];
    self.collectionView.backgroundColor = [UIColor whiteColor];
    self.collectionView.delegate = self;
    self.collectionView.dataSource = self;
    [self.collectionView registerNib:[UINib nibWithNibName:@"CollectionViewCell" bundle:nil] forCellWithReuseIdentifier:identifier];
    [self.collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:headerId];
</pre> 

<h3 id="两个数组用来存放已添加的和待添加的"><a href="#两个数组用来存放已添加的和待添加的" class="headerlink" title="两个数组用来存放已添加的和待添加的"></a>两个数组用来存放已添加的和待添加的</h3><pre> 
   if ([[NSUserDefaults standardUserDefaults]objectForKey:@"one"] == nil) {
   self.oneArray = [NSMutableArray arrayWithObjects:@"0",@"1",@"2",@"3",@"4",@"5",@"6",@"7",@"8",@"9",@"10",@"11",@"12",@"13",@"14",@"15",@"16",@"17",@"18",@"19",nil];
    }else{
        id array = [[NSUserDefaults standardUserDefaults]objectForKey:@"one"];
        [self.oneArray addObjectsFromArray:array];
    }
    if ( [[NSUserDefaults standardUserDefaults]objectForKey:@"two"] == nil) {
        self.twoArray = [NSMutableArray arrayWithObjects:@"a",@"b",@"c",@"d",@"e",@"f",@"g",@"h",@"i",@"j", nil];
    }else{
        id array = [[NSUserDefaults standardUserDefaults]objectForKey:@"two"];
        [self.twoArray addObjectsFromArray:array];
    }
</pre>

<h3 id="每次改变后刷新要防止复用"><a href="#每次改变后刷新要防止复用" class="headerlink" title="每次改变后刷新要防止复用"></a>每次改变后刷新要防止复用</h3><pre>
 UICollectionReusableView *headerView = [self.collectionView dequeueReusableSupplementaryViewOfKind:kind withReuseIdentifier:headerId forIndexPath:indexPath];
    headerView.backgroundColor = [UIColor darkGrayColor];
    [headerView.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];
    _titleLab = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width - 50, 40)];
    _titleLab.textAlignment = NSTextAlignmentLeft;
    _titleLab.textColor = [UIColor whiteColor];
    [headerView addSubview:self.titleLab];
</pre>

<h3 id="编辑状态下进行移动和删除"><a href="#编辑状态下进行移动和删除" class="headerlink" title="编辑状态下进行移动和删除"></a>编辑状态下进行移动和删除</h3><pre>
-(void)edit{
    for (CollectionViewCell * cell in self.collectionView.visibleCells) {
        if (cell.edit == NO) {
            cell.layer.masksToBounds = NO;
            cell.layer.shadowOpacity = 0.7f;
            cell.layer.shadowColor = [UIColor darkGrayColor].CGColor;
            cell.layer.shadowOffset = CGSizeMake(1.f, 1.f);
            cell.deleteBtn.hidden = NO;
            [self.editBtn setTitle:@"完成" forState:UIControlStateNormal];
            cell.edit = YES;
        }else{
            cell.edit = NO;
            cell.deleteBtn.hidden = YES;
            cell.layer.masksToBounds = YES;
            [self.editBtn setTitle:@"编辑" forState:UIControlStateNormal];
        }
    }

}
</pre>

<h3 id="添加数据-持久化存储刷新界面"><a href="#添加数据-持久化存储刷新界面" class="headerlink" title="添加数据,持久化存储刷新界面"></a>添加数据,持久化存储刷新界面</h3><pre>
-(void)add{
    SCLAlertView * alert = [[SCLAlertView alloc]init];
    [alert setHorizontalButtons:YES];
    SCLTextView * textField = [alert addTextField:@"Enter your name"];
    [alert addButton:@"确定" actionBlock:^(void) {
        NSLog(@"Text value: %@", textField.text);
        [self.twoArray addObject:textField.text];
        [self.collectionView reloadData];
        [[NSUserDefaults standardUserDefaults]setObject:self.twoArray forKey:@"two"];
        [[NSUserDefaults standardUserDefaults]synchronize];

    }];   
  [alert showEdit:self title:nil subTitle:@"请输入名称" closeButtonTitle:@"取消" duration:0.0f];
</pre>

<h3 id="增删移随时保存数据"><a href="#增删移随时保存数据" class="headerlink" title="增删移随时保存数据"></a>增删移随时保存数据</h3><pre> 
    [[NSUserDefaults standardUserDefaults]setObject:self.oneArray forKey:@"one"];
    [[NSUserDefaults standardUserDefaults]setObject:self.twoArray forKey:@"two"];
    [[NSUserDefaults standardUserDefaults]synchronize];

</pre>



<p><img src="/2017/08/11/增删移/main.png" alt="mian"><br><img src="/2017/08/11/增删移/add.png" alt="add"><br><img src="/2017/08/11/增删移/remove.png" alt="remove"></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[[iOS_自定义tarbar和侧边栏]]]></title>
      <url>/2017/08/03/%E8%87%AA%E5%AE%9A%E4%B9%89tarbar/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog. Thanks.</p>
<p>Dome: <a href="https://github.com/princeSmall/REsideAndTarbar" target="_blank" rel="external"> github 地址</a></p>
<h3 id="pod-RESideMenu"><a href="#pod-RESideMenu" class="headerlink" title="pod RESideMenu"></a>pod RESideMenu</h3><ol>
<li><p>vim podfile</p>
<pre><code>platform :ios,&apos;8.0&apos;
target &apos;SideAndTarbar&apos; do
pod &apos;RESideMenu&apos;, &apos;~&gt; 4.0.7&apos;
</code></pre></li>
</ol>
<h3 id="AppDelegate-m"><a href="#AppDelegate-m" class="headerlink" title="AppDelegate.m"></a>AppDelegate.m</h3><pre><code>添加RESideMenuDelegate
</code></pre><ol>
<li><p>didFinishLaunchingWithOptions</p>
<pre><code>self.window = [[UIWindow alloc]initWithFrame:[[UIScreen mainScreen ]bounds]];
TableViewController * viewController =  [[TableViewController alloc]init];
TarBarViewController * barViewController = [[TarBarViewController alloc]init];
RESideMenu * sideMenu = [[RESideMenu alloc]initWithContentViewController:barViewController leftMenuViewController:viewController rightMenuViewController:nil];
sideMenu.delegate = self;
sideMenu.contentViewShadowEnabled = YES;
sideMenu.contentViewInPortraitOffsetCenterX = 100.f;
sideMenu.contentViewScaleValue = 1.0;
sideMenu.menuPreferredStatusBarStyle = UIStatusBarStyleLightContent;
sideMenu.bouncesHorizontally = NO;
self.window.rootViewController = sideMenu; 
</code></pre></li>
</ol>
<h3 id="自定义tabbar"><a href="#自定义tabbar" class="headerlink" title="自定义tabbar"></a>自定义tabbar</h3><ol>
<li><p>添加子控制器属性</p>
<ul>
<li>添加navgationbar</li>
<li>去除tabbar分割线</li>
<li>选中controller后图片和标题改变</li>
</ul>
</li>
</ol>
<pre>
-(void)addChildViewController:(UIViewController *)childController title:(NSString *)title image:(UIImage *)image selecteImage:(UIImage *)selectedImage{

    UINavigationController * controller = [[UINavigationController alloc]initWithRootViewController:childController];
    childController.view.backgroundColor = [UIColor whiteColor];
    childController.navigationItem.title = title;
    [[UITabBar appearance] setShadowImage:[UIImage new]]; [[UITabBar appearance] setBackgroundImage:[[UIImage alloc]init]];
    selectedImage = [selectedImage imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];
    self.tabBar.tintColor = [UIColor greenColor];  
    controller.tabBarItem = [[UITabBarItem alloc]initWithTitle:title image:image selectedImage:selectedImage];
    [self addChildViewController:controller];

}  
</pre>  

<ol>
<li>添加子控制器 <pre>
-(void)setNewBar{
OneViewController * one = [[OneViewController alloc]init];
[self addChildViewController:one title:@"MainOne" image:[UIImage imageNamed:@"icon_home_normal"] selecteImage:[UIImage imageNamed:@"icon_home_selected"]];
TwoViewController * two = [[TwoViewController alloc]init];
[self addChildViewController:two title:@"MainTwo" image:[UIImage imageNamed:@"icon_door_normal"] selecteImage:[UIImage imageNamed:@"icon_door_selected"]];
}
</pre>

</li>
</ol>
<h3 id="在各自类中进行操作就OK"><a href="#在各自类中进行操作就OK" class="headerlink" title="在各自类中进行操作就OK"></a>在各自类中进行操作就OK</h3><ol>
<li>例如：<pre>
self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc]initWithImage:[UIImage imageNamed:@"icon_sidebar"] style:UIBarButtonItemStylePlain target:self action:@selector(presentLeftMenuViewController:)];
 UIButton * button = [[UIButton alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];
 button.backgroundColor = [UIColor greenColor];
 [self.view addSubview:button];
</pre>

</li>
</ol>
<p><img src="/2017/08/03/自定义tarbar/main.png" alt=""><br><img src="/2017/08/03/自定义tarbar/mainTwo.png" alt=""><br><img src="/2017/08/03/自定义tarbar/left.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo简单操作]]></title>
      <url>/2017/07/25/Hexo%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h3 id="Welcome-to-my-blog-Thanks"><a href="#Welcome-to-my-blog-Thanks" class="headerlink" title="Welcome to my blog. Thanks."></a>Welcome to my blog. Thanks.</h3><p>打开themes/next/source/css/_custom/custom.styl.<br>参考样式:<a href="https://princesmall.cn" target="_blank" rel="external">博客地址</a></p>
<p><img src="/2017/07/25/Hexo简单操作/css.png" alt="logo"></p>
<pre>/*标题  */
.post-title{
color: red;
}    
/*内容  */
.post-body{
color: green;
}
/*author  */
.author{
text-align: center;
color: red;
}
/*心photo  */
.with-love{
color: red;
}
/*乐乐  */
.theme-link{
color: red;
}
.busuanzi-value{
color: rebeccapurple;
}
</pre>

<h3 id="Next主题操作"><a href="#Next主题操作" class="headerlink" title="Next主题操作"></a>Next主题操作</h3><ol>
<li>生成新页面 <pre> hexo g</pre></li>
<li>发布代码  <pre> hexo d</pre></li>
<li>开启调试服务  <pre> hexo  s –debug</pre></li>
</ol>
<h3 id="为next主题的主页文章添加阴影效果"><a href="#为next主题的主页文章添加阴影效果" class="headerlink" title="为next主题的主页文章添加阴影效果"></a>为next主题的主页文章添加阴影效果</h3><ol>
<li>打开themes/next/source/css/_schemes/Mist/_posts-expanded.styl文件</li>
<li>找到类.posts-expand下面的.post<pre>
.post {
margin-top: 120px;
}
改成:
.post {
margin-top: 60px;
margin-bottom: 60px;
padding: 25px;
-webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);
-moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);
}
</pre>

</li>
</ol>
<h3 id="添加“Fork-me-on-Github”-ribbon"><a href="#添加“Fork-me-on-Github”-ribbon" class="headerlink" title="添加“Fork me on Github” ribbon"></a>添加“Fork me on Github” ribbon</h3><ol>
<li><p>打开themes\next\layout\layout.swig</p>
<pre><code>&lt;a href=&quot;你的地址&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; left: 0; border: 0;&quot; 
src=&quot;https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67&quot; 
alt=&quot;Fork me on GitHub&quot; 
data-canonical-src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png&quot;&gt;&lt;/a&gt;
</code></pre></li>
</ol>
<h3 id="404界面"><a href="#404界面" class="headerlink" title="404界面"></a>404界面</h3><ol>
<li>找到根目录-source<br><img src="/2017/07/25/Hexo简单操作/404.png" alt="logo"></li>
<li>创建HTML文件</li>
<li><p>打开：commonweal: /404.html</p>
<pre><code>&lt;html&gt;
&lt;body&gt;
&lt;script type=&quot;text/javascript&quot; 
src=&quot;http://www.qq.com/404/search_children.js&quot;         
charset=&quot;utf-8&quot; homePageUrl=&quot;http://www.princesmall.cn&quot;
 homePageName=&quot;回到乐乐的主页&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
注：如果返回的还是qq主页，请参考我网页源码，毕竟有些长，这只是不body。然后copy到你的404.html下
</code></pre></li>
</ol>
<h3 id="文章末尾追加版权信息"><a href="#文章末尾追加版权信息" class="headerlink" title="文章末尾追加版权信息"></a>文章末尾追加版权信息</h3><ol>
<li>找到themes/next/layout/_macro/reward.swig</li>
<li>在最上面添加如下代码：（最上面）<br><img src="/2017/07/25/Hexo简单操作/permalink.png" alt="permalink">   </li>
</ol>
<h3 id="Hexo插入图片"><a href="#Hexo插入图片" class="headerlink" title="Hexo插入图片"></a>Hexo插入图片</h3><ol>
<li>首先确认根目录下_config.yml 中有 post_asset_folder:true</li>
<li>在hexo的目录下执行npm install <a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="external">https://github.com/CodeFalling/hexo-asset-image</a> –save</li>
<li>创建文件hexo new “文件名”</li>
<li><p>在source下会生成一个和文件名一样的文件夹，图片放在该文件夹下</p>
<pre><code>例如：
  ![logo](文件名/logo.jpg)
  是不是so easy！
</code></pre></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 1 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/07/17/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
