<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[Python_scrapy图片爬取下载]]]></title>
    <url>%2F2017%2F12%2F20%2FPython-scrapy%E5%9B%BE%E7%89%87%E7%88%AC%E5%8F%96%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[welcome to myblog Dome地址 爬取某个车站的图片 item.py 中1、申明item 的fields class PhotoItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() image_urls = scrapy.Field() images = scrapy.Field() pass spider 的image.py 导入头文件 from Photo.items import PhotoItem from scrapy import Spider from scrapy import Selector from scrapy.http import Request 爬取代码 注： 只需要爬取图片对应的url 翻页爬取时加上爬取范围url class imageSpider(Spider): name = &apos;car&apos; allowed_domains = [&apos;car.autohome.com.cn&apos;] start_urls = [ &quot;https://car.autohome.com.cn/jingxuan/list-0-p1.html&quot;, ] def parse(self, response): item = PhotoItem() sel = Selector(response) item[&apos;image_urls&apos;] = sel.xpath(&apos;//ul[@class=&quot;content&quot;]/li/a/img/@src&apos;).extract() print item[&apos;image_urls&apos;], &apos;..image_urls..&apos; yield item # 翻页 new_urls = response.xpath(&apos;//div[@class=&quot;pageindex&quot;]/a[9]/@href&apos;).extract_first() new_url = &quot;https://car.autohome.com.cn&quot; + new_urls print new_url, &apos;..new_url...&apos; if new_url: yield Request(new_url, callback=self.parse) settings.py 中Configure item pipelinesITEM_PIPELINES = { &apos;Photo.pipelines.jandanPipeline&apos;: 200, # &apos;Photo.pipelines.PhotoPipeline&apos;: 300, } 存储下载图片所在位置IMAGES_STORE = &apos;/Users/sansi/Desktop/Scrapy/Photo/Image&apos; DOWNLOAD_DELAY = 0.25 缩略图大小IMAGES_THUMBS = { &apos;small&apos;: (50, 50), &apos;big&apos;: (200, 200), } 图片的失效期限IMAGES_EXPIRES = 90 pipelines.py 中 导入头文件 import os import urllib import scrapy from scrapy.exceptions import DropItem from scrapy.pipelines.images import ImagesPipeline from Photo import settings 编写爬取下载 class PhotoPipeline(object): def process_item(self, item, spider): return item 重写ImagesPipeline，对各个url返回Request class jandanPipeline(ImagesPipeline): def get_media_requests(self, item, info): for image_url in item['image_urls']: yield scrapy.Request(image_url) 当一个项目所有的请求完成时调用def item_completed(self, results, item, info): image_paths = [x[&apos;path&apos;] for ok, x in results if ok] if not image_paths: raise DropItem(&quot;Item contains no images&quot;) item[&apos;images&apos;] = image_paths return item]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Python_scrapy多数据及数据库存储]]]></title>
    <url>%2F2017%2F12%2F19%2FPython-scrapy%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[welcome to myblog Dome地址 Spiders使用scrapy的spiders进行多网页爬取保存到本地 Princesmall.py中 导入头文件注意：..items from scrapy.spiders import Spider from scrapy.selector import Selector from scrapy.http import Request import scrapy from ..items import PrincesmallItem 获取princesmall的所有title，link，time注意：要用yield item。要用yield item。要用yield item。重要说三遍 class princesmallSpider(Spider): name = &quot;princesmall&quot; download_delay = 1 allowed_domains = [&quot;princesmall.cn&quot;] start_urls = [ &quot;http://princesmall.cn&quot; ] def parse(self, response): sel = Selector(response) sites = sel.xpath(&apos;//header[@class=&quot;post-header&quot;]&apos;) for site in sites: item = PrincesmallItem() title = site.xpath(&apos;h1/a/text()&apos;).extract() link = site.xpath(&apos;h1/a/@href&apos;).extract() time = site.xpath(&apos;div/span/time/text()&apos;).extract() item[&apos;title&apos;] = [t.encode(&apos;utf-8&apos;) for t in title] item[&apos;link&apos;] = [l.encode(&apos;utf-8&apos;) for l in link] item[&apos;time&apos;] = [m.encode(&apos;utf-8&apos;) for m in time] yield item # title_prince = sel.xpath(&apos;//header[@class=&quot;post-header&quot;]/h1/a/text()&apos;).extract() # url_prince = sel.xpath(&apos;//header[@class=&quot;post-header&quot;]/h1/a/@href&apos;).extract() # time_prince = sel.xpath(&apos;//header[@class=&quot;post-header&quot;]/div/span/time/text()&apos;).extract() # # item[&apos;title&apos;] = [t.encode(&apos;utf-8&apos;) for t in title_prince] # item[&apos;link&apos;] = [l.encode(&apos;utf-8&apos;) for l in url_prince] # item[&apos;time&apos;] = [m.encode(&apos;utf-8&apos;) for m in time_prince] # # yield item print item, &apos;------&apos; # 爬取下一页 urls = sel.xpath(&apos;//nav[@class=&quot;pagination&quot;]/a[@class=&quot;extend next&quot;]/@href&apos;).extract() for url in urls: url = &quot;http://princesmall.cn&quot; + url yield Request(url, callback=self.parse) # yield scrapy.Request(url,callback=self.parse) 获取w3cshoolxml的title，link，desc class w3schoolSpider(Spider): name = &quot;w3school&quot; allowed_domains = [&quot;w3school.com.cn&quot;] start_urls = [ &quot;http://www.w3school.com.cn/xml/xml_syntax.asp&quot; ] def parse(self, response): sel = Selector(response) sites = sel.xpath(&apos;//div[@id=&quot;navsecond&quot;]/div[@id=&quot;course&quot;]/ul[1]/li&apos;) items = [] for site in sites: item = PrincesmallItem() title = site.xpath(&apos;a/text()&apos;).extract() link = site.xpath(&apos;a/@href&apos;).extract() desc = site.xpath(&apos;a/@title&apos;).extract() item[&apos;title&apos;] = [t.encode(&apos;utf-8&apos;) for t in title] item[&apos;link&apos;] = [l.encode(&apos;utf-8&apos;) for l in link] item[&apos;desc&apos;] = [d.encode(&apos;utf-8&apos;) for d in desc] items.append(item) return items pipelines.py注意：保存到本地，text，json，xml…有时候用ensure_ascii = False.有时候要用decode(“unicode_escape”).初学者还没分清区别 import codecs import json class PrincesmallPipeline(object): def __init__(self): self.file = codecs.open(&apos;prince.json&apos;, &apos;w&apos;, encoding=&apos;utf-8&apos;) # self.file = codecs.open(&apos;princesmall.json&apos;,&apos;wb&apos;,encoding=&apos;utf-8&apos;) # self.file = codecs.open(&apos;w3school_data_utf8.json&apos;, &apos;wb&apos;, encoding=&apos;utf-8&apos;) def process_item(self, item, spider): # line = json.dumps(dict(item), ensure_ascii=False) + &apos;\n&apos; # self.file.write(line) line = json.dumps(dict(item)) + &apos;\n&apos; self.file.write(line.decode(&quot;unicode_escape&quot;)) return item items.py 中仍然不变import scrapy from scrapy.item import Item, Field class PrincesmallItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() title = Field() link = Field() desc = Field() time = Field() pass 下载MySQLMac ： 官网下载dmg文件打开 homebrew下载,Mac 个人倾向这个下载，不然会出现各种各样的环境问题，反正我是处理了好多问题。最后用pip install mysql 根本不用考虑环境问题，一步到位。。。。 pipelines.py导入头文件： from twisted.enterprise import adbapi import MySQLdb from MySQLdb import cursors from scrapy import log 类方法 class PrincesmallSQLPipeline(object): def __init__(self): self.dbpool = adbapi.ConnectionPool(&quot;MySQLdb&quot;, host = &quot;localhost&quot;, db = &quot;new_schema_prince&quot;, user = &quot;root&quot;, passwd = &quot;princesmall&quot;, cursorclass = MySQLdb.cursors.DictCursor, charset = &quot;utf8&quot;, use_unicode =True ) def process_item(self,item,spider): query = self.dbpool.runInteraction(self._conditional_insert,item) query.addErrback(self.handle_error) return item def _conditional_insert(self,tb,item): prince_title = item[&apos;title&apos;] prince_link = item[&apos;link&apos;] prince_time = item[&apos;time&apos;] # print prince_link, prince_title, prince_time, &apos;--------&apos; # 删除所有数据 # tb.execute(&quot;DELETE FROM TABLE_NAME &quot;) # 插入数据，prince_link[0]取出list列表中的数据 tb.execute(&quot;INSERT INTO TABLE_NAME (Prince_Title, Prince_Link, Prince_Time) VALUES (&apos;%s&apos;, &apos;%s&apos;, &apos;%s&apos;)&quot; % (prince_title[0], prince_link[0], prince_time[0])) log.msg(&quot;item data in :%s&quot; % item, level=log.DEBUG) def handle_error(self,e): log.err(e)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[DuerOS_小度]]]></title>
    <url>%2F2017%2F12%2F05%2FDuerOS-%E5%B0%8F%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[智能家居方向，DuerHomeSDK研究及开发 DuerHomeSDK具备的功能BDuerAbility.h获取各能力状态，如播放器状态，扬声器状态等，由各子类分别调用 BDuerAlerts.h提醒事件 设置成功（SetAlertSucceeded）、 设置失败（SetAlertFailed）、 删除成功（DeleteAlertSucceeded）、 删除失败（DeleteAlertFailed）、 响铃开始（AlertStarted）、 响铃结束（AlertStopped）、 响铃打断其他事件（AlertEnteredForeground）、 响铃事件被打断（AlertEnteredBackground） 提醒ID 提醒类型type 提醒时间scheduledTime 是否正在提醒isActive BDuerAudioPlayer.h 获取播放器状态 播放指定音频 音箱状态事件 开始（PlaybackStarted）、 完成（PlaybackFinished）、 失败（PlaybackFailed）、 停止（PlaybackStopped）、 暂停（PlaybackPaused）、 恢复（PlaybackResumed）、 状态（PlaybackState）、 进度上报（ProgressReportIntervalElapsed） BDuerAuthentication.H 对设备做授权配对操作 百度账号登录，第三方登录等 登录信息获取 BDuerBLEDevice.H BLE设备 BDuerBTDiscoverService.h 发现待配网的DuserBTD设备 开始扫描 停止扫描 BDuerDevice.h 设备传给app的数据 类名 获取的信息 BDuerAudioPlayer * audioPlayer; //播放器 BDuerSpeaker * speaker; //扬声器 BDuerAlerts * alerts; //提醒 BDuerSystemInfo * systemInfo; //硬件设备属性 BDuerScreenMsg * screenMsg; //绘制界面 BDuerLocation * location; //地理位置 BDuerAuthentication * authentication; //设备授权 BDuerTVLink * tvLink; //音箱连接电视 BDuerTTSInfo * ttsInfo; //修改设备tts播报的音色 BDuerPlaybackController * playbackController; //简单播放控制 BDuerDeviceDiscoverService.h 发现已配好网的DuserOS设备（同一局域网线） 开始发现 停止发现 BDuerDeviceListenService.h DuserOS设备上线后，会通知SDK，SDK会将监听到的该设备抛出 开始监听 停止监听 BDuerErrorCodes.h 错误数据码 错误码 错误信息 BDuerBLEConnectionFail = 1001, // 蓝牙连接失败 BDuerAPConnectionFail = 1002, // AP连接失败 BDuerNetDataExchangeFail = 1003, // 配网数据交换失败 BDuerDuerDeviceDiscoverFail = 1004, // 未发现小度之家设备 BDuerParamError = 1008, // 参数缺失 BDuerVersionNotSupportError = 1009, // 版本不支持 BDuerUnDefinedError = 1010, // 未定义错误，详细错误请见error的description BDuerDuerDeviceListenFail = 1011, // 监听失败 BDuserHomeSDKInterface.h 与设备无关的属性 BDuerBTDiscoverService * btDiscoverService;//蓝牙发现，发现多台蓝牙设备 BDuerDeviceDiscoverService * deviceDiscoverService;//局域网发现，发现多台DuerOS设备 BDuerDeviceListenService * deviceListenService;//局域网监听，设备上线会通知外部 BDuerNetConfigure * netConfigure;//配网 BDuerLogin * login;//用户登录信息，跳转登录页等 厂商指定的设备列表 添加授权 解除授权 BDuerLocation.H 获取地理位置 设置地理位置 BDuerLogin.H 用户登录 多用户登录，切换 退出登录 获取登录信息 BDuerNetConfigure.H 配网类（蓝牙和渡鸦科技）） BDuerPlaybackController.H 设备控制指令 PlayCommandIssued（播放）、 PauseCommandIssued（暂停）、 NextCommandIssued（下一首）、 PreviousCommandIssued（上一首） BDuerScreenMsg.h 获取播放器页面信息，还很多 歌曲信息 卡片信息 文本信息 BDuerSpeaker.h 获取扬声器状态 设置音量大小 是否静音 注册时间回调 音量事件： 音量改变（VolumeChanged）、 静音状态改变（MuteChanged） 扬声器状态（VolumeState） BDuerSystemInfo 从音响中获取设备系统信息 请求硬重置 设置设备名称 获取设备状态 属性 信息 NSString * ssid; //wifi热点名字 NSString * mac; //mac地址 NSString * bleMac; //蓝牙mac地址 NSString * sn; //序列号 NSString * ip; //ip地址 NSString * clientID; //开发者账号 NSString * deviceID; // NSString * appID; //产品AppID，已废弃 NSString * deviceVersion; NSString * softwareVersion; NSString * protocolVersion; NSString * onlineStatus; //是否能连上公网，0 是能连上 NSString * name; //可选，设备的名称，调用fetchSystemInfoFromServer会返回 NSString * tone; //可选，设备的音色，调用fetchSystemInfoFromServer会返回 BDuerTTSInfo.h TTS音色 获取TTS状态 更新TTS音色 注册音色改变 属性 |取值—————————-|——–NSString tts_volume; |//可选，声音大小 0-9，默认为 5NSString tts_speed;|//可选，语速 0-9，默认为 5NSString tts_pitch;|//可选，语调0-9，默认为 5SString tts_speaker;|//可选，声音0:普通女声 1:普通男生 2:特别男生 3:情感男生&lt;度逍遥&gt; 4:情感儿童生&lt;度丫丫&gt;，默认为 0NSString tts_aue;|//可选，音频格式NSString tts_rate;|//可选，码率NSString * tts_xml;|//可选，是不是xml BDuerTVLink.h 控制音箱去发送Link指令给电视 控制音箱去发送UnLink指令给电视 注册音箱与电视连接状态回调 获取连接状态和信息 DomeAPP做了些什么登录接口测试 登录 网页登录并授权，返回OAuthCode，进入DUEROS 是否登录 若已登录，显示登录，否则显示未登录 注销登录 注销成功 授权度秘 对话式人工智能系统：影音娱乐，生活服务，交通出行，信息查询等 测试 返回授权结果： data，登录IDloginID，信息msg和状态码status 获取用户信息 一直出现错误null 切换用户 切换用户显示：60194486，无可操作-&gt;back。界面显示切换用户错误 登出指定用户 无反应 移除指定用户 无反应 配网接口测试 蓝牙配网测试 电脑手机蓝牙均不可被发现（需要先登录） AP配网测试 无音响AP，点击确定到设置界面 获取云端设备 无反应（代码中有TV，audio）应该都没获取到 百度取消对产品的授权 返回data数据，loginID ，msg ，status 版本号： 0.1.5]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Python_scrapy基础爬虫]]]></title>
    <url>%2F2017%2F12%2F04%2FPython-scrapy%E5%9F%BA%E7%A1%80%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[welcome to my blog thanks Dome: github地址 学习整理了两周时间开始写Python爬虫，完全出于自己的爱好 创建项目1、scrapy startproject tutorial （你的项目名称） spider 爬虫目录，用于创建文件，编写爬虫代码 settings 配置文件 items 设置数据存储 pipelines 数据处理和存储 编写爬虫代码1、定义一个类princesmall，导入scrapy 2、必须定义name、allowed_domains、start_urls name：爬虫的名字 allowed_domains：爬取的范围 start_urls 爬取得开始网页 name = &quot;lezhi&quot; allowed_domains = [&quot;lezhi.com&quot;] start_urls = [ &quot;http://www.lezhi.com/Resume/hefei?perpage/10/companyname_type/1/keywords/%CB%E3%B7%A8%B9%A4%B3%CC%CA%A6/degreem/0/page/1=&quot;, ] 3、def parse （self，response） scrapy 返回response的默认方法 css解析，直接定位到目录 allfill = response.css(“.right.fll”).xpath(“label/div[1]/text()”).extract() XPath解析，层层下拨 name = response.xpath(‘//a/div/label/div[1]/text()’).extract() 保存爬取数据 settings.py 文件 ROBOTSTXT_OBEY = False ITEM_PIPELINES = { &apos;tutorial.pipelines.TutorialPipeline&apos;: 300, } items.py 文件 class TutorialItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() company = scrapy.Field() name = scrapy.Field() info = scrapy.Field() pass pipelines.py 文件 import json import codecs class TutorialPipeline(object): def __init__(self): self.file = codecs.open(&apos;small.json&apos;,&apos;wb&apos;,encoding=&apos;utf-8&apos;) def process_item(self, item, spider): line = json.dumps(dict(item)) + &apos;\n&apos; print line, &apos;&gt;&gt;&gt;&gt;&gt;&apos; self.file.write(line.decode(&quot;unicode_escape&quot;)) return item 好吧，简单的数据爬取，完美收关 项目中遇到的问题总结下载scrapy及使用问题 Permission denied 权限问题：加sudo，输入密码 TLSVersion.TLSv1_1: SSL.OP_NO_TLSv1_1 版本问题： pip install scrapy 需要 pyopenssl twisted ==13.1.0 spider加载item类中方法，找不到 目录问题：from ..items import DmozItem（第一个点表示当前目录，第二个点表示上层目录）]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS_排序算法]]]></title>
    <url>%2F2017%2F11%2F24%2FiOS-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本篇博客主要对快速排序，冒泡排序和简单选择排序进行改进，在时间处理上降低1/2。 QuickSort - 快速升序排序快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法 先调用改进算法QsortImprove使之基本有序 再用插入排序对基本有序序列排序 + (void)quickSort:(NSMutableArray *)array arrayCount:(int)c centerK:(int)k{ [self qsortImprove:array lowA:0 highB:c centerK:k]; for (int i = 1; i &lt;= c; i ++) { int tmp = (int)[array[i] integerValue]; int j = i - 1; while (tmp &lt; (int)[array[j] integerValue]) { array[j + 1] = array[j]; j = j - 1; } array[j + 1] = [NSNumber numberWithInt:tmp]; } } 长度大于k时开始递归，k为指定的数 调用的PartitionArray 算法保持不变 +(void)qsortImprove:(NSMutableArray *)array lowA:(int)a highB:(int)b centerK:(int)k{ if (b - a &gt; k) { int privot = [self partitionArray:array lowA:a highB:b]; [self qsortImprove:array lowA:a highB:privot -1 centerK:k]; [self qsortImprove:array lowA:privot +1 highB:b centerK:k]; } } 基本有序 + (int)partitionArray:(NSMutableArray *)array lowA:(int)a highB:(int)b{ // 基准元素 int privotKey = (int)array[a]; // 从表的两端交替地向中间扫描 while (a &lt; b) { while (a &lt; b &amp;&amp; [array[b] integerValue] &gt;= privotKey) { b--; int tmp = (int)[array[a] integerValue]; array[a] = array[b]; array[b] = [NSNumber numberWithInt:tmp]; } while (a &lt; b &amp;&amp; [array[a] integerValue] &lt;= privotKey) { a++; int tmp = (int)[array[a] integerValue]; array[a] = array[b]; array[b] = [NSNumber numberWithInt:tmp]; } } return a; } BubbleSort - 冒泡排序对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。 +(void)bubbleSort:(NSMutableArray *)array lowA:(int)low highB:(int)high{ int tmp,j; while (low &lt; high) { for (j= low; j &lt; high; ++j) //正向冒泡,找到最大者 if ([array[j] integerValue]&gt; [array[j+1] integerValue]) { tmp = (int)[array[j] integerValue]; array[j]=array[j+1]; array[j+1]=[NSNumber numberWithInt:tmp]; } --high; //修改high值, 前移一位 for ( j= high; j &gt; low; --j) //反向冒泡,找到最小者 if ([array[j] integerValue]&lt;[array[j-1] integerValue]) { tmp = (int)[array[j] integerValue]; array[j]=array[j-1]; array[j-1]=[NSNumber numberWithInt:tmp]; } ++low;//修改low值,后移一位 } } SelectSort - 简单选择排序 在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换； 然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。 + (void)selectSort:(NSMutableArray *)array arrayCount:(int)n{ for (int i = 0; i &lt; n; i ++) { for (int j = i + 1; j &lt; n; j ++) { if ([array[i] integerValue] &gt; [array[j] integerValue]) { int temp = [array[i] intValue]; array[i] = array[j]; array[j] = [NSNumber numberWithInt:temp]; } } } } ComparatorSort - 比较排序利用系统自带的方法比较排序 +(NSArray *)ComparatorSort:(NSMutableArray *)array{ NSArray * arr = [array sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) { if ([obj1 integerValue] &gt; [obj2 integerValue]) { return (NSComparisonResult)NSOrderedDescending; } if ([obj1 integerValue] &lt; [obj2 integerValue]) { return (NSComparisonResult)NSOrderedAscending; } return (NSComparisonResult)NSOrderedSame; }]; return arr; }]]></content>
      <categories>
        <category>OC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[Animation_ViewAnimation应用]]]></title>
    <url>%2F2017%2F11%2F22%2FAnimation-ViewAnimation%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome:github地址 最近各式各样的动画也是被我玩坏了，今天直接拿来结合需求用。今天主要整理了UIView的动画方法，跟present，push不同，但又很相似，可以满足日常所需动画。话不多说，直接上码。 Animation +(void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion; duration : 动画时间 delay : 延迟时间 options : 动画的方式，so much... animation : 需要执行的动作 completion : 完成后的方法，可以为空 案例，登录注册的左移，右移和透明[UIView animateWithDuration:1 animations:^{ CGFloat x = self.nameTextField.frame.origin.x; x += Width - 40; self.nameTextField.alpha = 1.0; [self.nameTextField setFrame:CGRectMake(x, 100, Width - 80, 50)]; } completion:^(BOOL finished) { }]; [UIView animateWithDuration:1 delay:0.5 options:(UIViewAnimationOptionCurveEaseInOut) animations:^{ CGFloat x = self.passwordTextField.frame.origin.x; x -= Width - 40; self.passwordTextField.alpha = 1.0; [self.passwordTextField setFrame:CGRectMake(x, 200, Width - 80, 50)]; } completion:^(BOOL finished) { }]; [UIView animateWithDuration:1 delay:1 options:(UIViewAnimationOptionCurveEaseInOut) animations:^{ self.loginBtn.alpha =1.0; [self.loginBtn setTitle:@&quot;Login&quot; forState:UIControlStateNormal]; } completion:^(BOOL finished) { }]; 目前动画实现登录注册就好了 Transition +(void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^ __nullable)(void))animations completion:(void (^ __nullable)(BOOL finished))completion; view : 需要变换的视图 duration : 动画的时间 options : 动画的方式， so much... animation : 需要执行的动作 completion : 完成后的方法，可以为空 案例，点击切换图片[UIView transitionWithView:cell.imageView duration:1 options:UIViewAnimationOptionTransitionFlipFromLeft animations:^{ if ([cell.imageView.image isEqual:[UIImage imageNamed:@&quot;two&quot;]]) { cell.imageView.image = [UIImage imageNamed:@&quot;one&quot;]; }else{ cell.imageView.image = [UIImage imageNamed:@&quot;two&quot;]; } } completion:^(BOOL finished) { }]; 目前点击动画翻页就好了 KeyFrame +(void)animateKeyframesWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewKeyframeAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion; duration : 动画时间 delay : 延迟时间 options : 动画方式， so much... animation : 需要执行的动作 completion : 完成后的方法，可以为空 案例，移动画线[UIView animateKeyframesWithDuration:1 delay:0 options:(UIViewKeyframeAnimationOptionCalculationModeLinear) animations:^{ CAShapeLayer * shapelayer = [CAShapeLayer layer]; self.path = [UIBezierPath bezierPath]; [self.path moveToPoint:CGPointMake(50, 200)]; [self.path addLineToPoint:CGPointMake(200, 200)]; [self.path addLineToPoint:CGPointMake(200, 350)]; [self.path addLineToPoint:CGPointMake(350, 350)]; shapelayer.path = self.path.CGPath; shapelayer.fillColor = [UIColor clearColor].CGColor; shapelayer.lineWidth = 4.0f; shapelayer.strokeColor = [UIColor redColor].CGColor; [self.view.layer addSublayer:shapelayer]; CABasicAnimation *pathAnima = [CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;]; pathAnima.duration = 3.0f; pathAnima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; pathAnima.fromValue = [NSNumber numberWithFloat:0.0f]; pathAnima.toValue = [NSNumber numberWithFloat:1.0f]; pathAnima.fillMode = kCAFillModeForwards; pathAnima.removedOnCompletion = NO; [shapelayer addAnimation:pathAnima forKey:@&quot;strokeEndAnimation&quot;]; } completion:^(BOOL finished) { }]; 目前一条移动的线条就好了 炫酷的TableViewCell出场动画这里只给出前几条，代码里已经全部封装好了 Animation类，遍历改变alpha+(void)alphaAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i &lt; cells.count; i++) { UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i]; cell.alpha = 0.0; [UIView animateWithDuration:0.3 delay:i*0.05 options:0 animations:^{ cell.alpha = 1.0; } completion:^(BOOL finished) { }]; } } Transition类遍历移动x+(void)moveAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i &lt; cells.count; i++) { CGFloat totalTime = 0.4; UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i]; cell.transform = CGAffineTransformMakeTranslation(-XS_SCREEN_WIDTH, 0); [UIView animateWithDuration:0.4 delay:i*(totalTime/cells.count) usingSpringWithDamping:0.7 initialSpringVelocity:1/0.7 options:UIViewAnimationOptionCurveEaseIn animations:^{ cell.transform = CGAffineTransformIdentity; } completion:^(BOOL finished) { }]; } } 遍历交叉移动x+(void)shakeAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i &lt; cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; if (i%2 == 0) { cell.transform = CGAffineTransformMakeTranslation(-XS_SCREEN_WIDTH,0); }else { cell.transform = CGAffineTransformMakeTranslation(XS_SCREEN_WIDTH,0); } [UIView animateWithDuration:0.4 delay:i*0.03 usingSpringWithDamping:0.75 initialSpringVelocity:1/0.75 options:0 animations:^{ cell.transform = CGAffineTransformIdentity; } completion:^(BOOL finished) { }]; } } 遍历移动y+(void)fallAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; NSTimeInterval totalTime = 0.8; for (int i = 0; i &lt; cells.count; i++) { UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i]; cell.transform = CGAffineTransformMakeTranslation(0, - XS_SCREEN_HEIGHT); [UIView animateWithDuration:0.3 delay:(cells.count - i)*(totalTime/cells.count) options:0 animations:^{ cell.transform = CGAffineTransformIdentity; } completion:^(BOOL finished) { }]; } }]]></content>
      <categories>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Animation_ViewAnimation]]]></title>
    <url>%2F2017%2F11%2F21%2FAnimation-ViewAnimation%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 ViewControllerAnimation注：所有的动画我都封装起来了，这里不仅有present和dismiss在viewController中跳转，还有各种动画push和pop，当然view的动画出场也是必不可少的。拿了直接用即可，简单粗暴看代码，这里可以让你知其然，知其所以然。 PresentAnimation实现UIViewControllerTransitioningDelegate的代理方法，把present从下面出来的view从右边动画出来，具体代码看github代码，具体方法如下： -(NSTimeInterval)transitionDuration:(id)transitionContext{ return 1.0; } -(void)animateTransition:(id)transitionContext{ UIViewController * fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; UIViewController * toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; UIView *containerView = [transitionContext containerView]; UIView *fromView = nil; UIView *toView = nil; if ([transitionContext respondsToSelector:@selector(viewForKey:)]) { fromView = [transitionContext viewForKey:UITransitionContextFromViewKey]; toView = [transitionContext viewForKey:UITransitionContextToViewKey]; }else{ fromView = fromViewController.view; toView = toViewController.view; } BOOL isPresent = (toViewController.presentingViewController == fromViewController); CGRect fromFrame = [transitionContext initialFrameForViewController:fromViewController]; CGRect toFrame = [transitionContext finalFrameForViewController:toViewController]; if (isPresent) { fromView.frame = fromFrame; toView.frame = CGRectOffset(toFrame, toFrame.size.width, 0); [containerView addSubview:toView]; } NSTimeInterval transitionDuration = [self transitionDuration:transitionContext]; [UIView animateWithDuration:transitionDuration animations:^{ if (isPresent) { toView.frame = toFrame; fromView.frame = CGRectOffset(fromFrame, fromFrame.size.width*0.3*-1, 0); } } completion:^(BOOL finished) { BOOL isCancelled = [transitionContext transitionWasCancelled]; if (isCancelled) [toView removeFromSuperview]; [transitionContext completeTransition:!isCancelled]; }]; } -(id)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source{ return (id)[[PresentAnimation alloc]init]; } DismissAnimation - (NSTimeInterval)transitionDuration:(id)transitionContext{ return 1.0; } -(void)animateTransition:(id)transitionContext{ UIViewController *fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; UIViewController *toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; UIView *containerView = [transitionContext containerView]; UIView *fromView = nil; UIView *toView = nil; if ([transitionContext respondsToSelector:@selector(viewForKey:)]) { fromView = [transitionContext viewForKey:UITransitionContextFromViewKey]; toView = [transitionContext viewForKey:UITransitionContextToViewKey]; }else{ fromView = fromViewController.view; toView = toViewController.view; } BOOL isDismiss = (fromViewController.presentingViewController == toViewController); CGRect fromFrame = [transitionContext initialFrameForViewController:fromViewController]; CGRect toFrame = [transitionContext finalFrameForViewController:toViewController]; if (isDismiss) { fromView.frame = fromFrame; toView.frame = CGRectOffset(toFrame, toFrame.size.width*0.3*-1, 0); [containerView insertSubview:toView belowSubview:fromView]; } NSTimeInterval transitionDuration = [self transitionDuration:transitionContext]; [UIView animateWithDuration:transitionDuration animations:^{ if (isDismiss) { toView.frame = toFrame; fromView.frame = CGRectOffset(fromFrame, fromFrame.size.width, 0); } } completion:^(BOOL finished) { BOOL isCancel = [transitionContext transitionWasCancelled]; if (isCancel) { [toView removeFromSuperview]; } [transitionContext completeTransition:!isCancel]; }]; } - (nullable id )animationControllerForDismissedController:(UIViewController *)dismissed { return (id)[[DismissAnimation alloc]init]; } PushAnimation动画添加新的view，type和subType不同，动画方式就不一样。这里只写一个不累赘 +(void)pushView:(UIView *)View subView:(UIView *)subView AndAnimationType:(NSString *)type AndsubType:(NSString *)subType{ CATransition *transition = [CATransition animation]; transition.duration = 1.0f; transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; transition.type = type; transition.subtype = subType; [View.layer addAnimation:transition forKey:@&quot;pushTransitionAnimation&quot;]; [View addSubview:subView]; } PopAnimation动画移除新的view +(void)popView:(UIView *)View subView:(UIView *)subView AndAnimationType:(NSString *)type AndsubType:(NSString *)subType { CATransition *transition = [CATransition animation]; transition.duration = 1.0f; transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; transition.type = type; transition.subtype = subType; [View.superview.layer addAnimation:transition forKey:@&quot;popTransitionAnimation&quot;]; [subView removeFromSuperview]; } 注：关于CATransition的type和subType的介绍，前两篇博客已经介绍过，看Animation_CATransition这篇。 ScaleViewAnimationCGAffineTransform 主要用于形变，位移和旋转，可用于动画展示 transform属性介绍，这里介绍最常用和好用的，其他属性去看CGAffineTransform 位移X,Y CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty) 伸缩X,Y CGAffineTransformMakeScale(CGFloat sx, CGFloat sy) 旋转M_PI CGAffineTransformMakeRotation(CGFloat angle) 组合 CGAffineTransformConcat(CGAffineTransform t1,CGAffineTransform t2) 回到原位 CGAffineTransformIdentity 动画调用，包括动画时间，动画完成后回调 -(void)scaleView:(UIView *)view CGFloatX:(CGFloat)x CGFloatY:(CGFloat)y CGFloatW:(CGFloat)w CGFloatH:(CGFloat)h{ CGFloat scaleW = self.window.frame.size.width / w; CGFloat scaleH = self.window.frame.size.height / h; CGFloat W = scaleW * 50 - 50 - x; CGFloat H = scaleH * 50 - 50 - y; [UIView animateWithDuration:1.0 animations:^{ view.transform =CGAffineTransformConcat(CGAffineTransformMakeScale(scaleW, scaleH), CGAffineTransformMakeTranslation(W,H)); } completion:^(BOOL finished) { dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ view.transform = CGAffineTransformIdentity; }); }]; }]]></content>
      <categories>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Amimation_GroupAnimation]]]></title>
    <url>%2F2017%2F11%2F20%2FAmimation-GroupAnimation%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 CAAnimation大家族的最后一个组合动画，所有复杂的动画都是有组合动画合成的，也可以说是最简单的。其实没什么可说的，就上一个炫酷的心形组合动画好了，其余的可以在我的代码中看到，简单到你怀疑自己。 GroupAnimationanimations：动画集合数组 draw a heart - (void)drawRect:(CGRect)rect { // 间距 CGFloat padding = 4.0; // 半径(小圆半径) CGFloat curveRadius = (rect.size.width - 2 * padding)/4.0; UIBezierPath *heartPath = [UIBezierPath bezierPath]; // 起点 CGPoint tipLocation = CGPointMake(rect.size.width/2, rect.size.height-padding); // 从起点开始画 [heartPath moveToPoint:tipLocation]; // (左圆的第二个点) CGPoint topLeftCurveStart = CGPointMake(padding, rect.size.height/2.4); // 添加二次曲线 [heartPath addQuadCurveToPoint:topLeftCurveStart controlPoint:CGPointMake(topLeftCurveStart.x, topLeftCurveStart.y + curveRadius)]; // 画圆 [heartPath addArcWithCenter:CGPointMake(topLeftCurveStart.x+curveRadius, topLeftCurveStart.y) radius:curveRadius startAngle:M_PI endAngle:0 clockwise:YES]; // (左圆的第二个点) CGPoint topRightCurveStart = CGPointMake(topLeftCurveStart.x + 2*curveRadius, topLeftCurveStart.y); // 画圆 [heartPath addArcWithCenter:CGPointMake(topRightCurveStart.x+curveRadius, topRightCurveStart.y) radius:curveRadius startAngle:M_PI endAngle:0 clockwise:YES]; // 右上角控制点 CGPoint topRightCurveEnd = CGPointMake(topLeftCurveStart.x + 4*curveRadius, topRightCurveStart.y); // 添加二次曲线 [heartPath addQuadCurveToPoint:tipLocation controlPoint:CGPointMake(topRightCurveEnd.x, topRightCurveEnd.y+curveRadius)]; // 设置填充色 [[UIColor redColor] setFill]; [heartPath fill]; heartPath.lineWidth = 2; heartPath.lineCapStyle = kCGLineCapRound; heartPath.lineJoinStyle = kCGLineJoinRound; [[UIColor yellowColor] setStroke]; [heartPath stroke]; }]]></content>
      <categories>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Animation_ProgressAnimation]]]></title>
    <url>%2F2017%2F11%2F19%2FAnimation-ProgressAnimation%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 今天主要讲一些动画的运用，也就是进度条，有弧形的，扇形的，圆形的。其实没什么难点，我封装在一个个View里，直接调用就行，弧度跟着进度条走就OK的。饮水思源，喜欢或者用得上就github给个Star ProgressAnimationUIBezierPath方法详解UIBezierPath 顾名思义，这是用贝塞尔曲线的方式来构建一段弧线，你可以用任意条弧线来组成你想要的形状 -(void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise center 圆弧圆心 radius 圆弧半径 startAngle 开始弧度 endAngle 结束弧度 closewise 是否顺时针 -(void)fill 填充颜色 -(void)stroke 线条颜色 注: 使用UIBezierPath绘画的代码写在自定义视图的drawRect:方法中 CAShaperLayerCAShaperLayer也就是在现有的图层上再次添加或覆盖一层以达到界面在显示时会呈现出不同形状的效果 fillColor 填充颜色 strokeColor 边框颜色 lineWidth 线条宽度 path 线条曲线 strokeStart 开始角度 strokeEnd 结束角度 注：进度条主要就以上方法 应用界面调用懒加载UISlider - (UISlider *)sectorSlider{ if (_sectorSlider == nil) { _sectorSlider = [[UISlider alloc]initWithFrame:CGRectMake(winWidth/2.0 - 100, 100, 200, 10)]; _sectorSlider.continuous = YES; [_sectorSlider addTarget:self action:@selector(sliderValueChanged:) forControlEvents:UIControlEventValueChanged]; [_sectorSlider setMinimumValue:0.0]; [_sectorSlider setMaximumValue:1.0]; } return _sectorSlider; } 点击调用UISlider方法 -(void)sliderValueChanged:(UISlider *)slider{ NSLog(@"---%f", slider.value); self.percentLable.text = [NSString stringWithFormat:@"%.2f",slider.value * 100]; [self.animationView setStartMove:slider.value]; [self.animationBallView setStartMove:slider.value]; [self.animationTimeView setStartMove:slider.value]; } 圆形进度条生成 UIBezierPath根据进度条随时改变开始弧度和结束弧度，不设置中心point - (void)drawRect:(CGRect)rect { CGPoint point = CGPointMake(100, 100); CGFloat radius = 95.0f; UIBezierPath *ballPath = [UIBezierPath bezierPathWithArcCenter:point radius:radius startAngle:self.startAngle endAngle:self.endAngle clockwise:YES]; [[UIColor greenColor]set]; [ballPath fill]; // 在球形的外面绘制一个描边空心的圆形，不然很难看 UIBezierPath *strokePath = [UIBezierPath bezierPathWithArcCenter:point radius:radius startAngle:0 endAngle:-0.00000001 clockwise:YES]; [[UIColor lightGrayColor]set]; [strokePath stroke]; } -(void)setStartMove:(CGFloat)value{ // 设置起始点，位置是根据进度动态变换的 self.startAngle = M_PI_2 - value * M_PI; self.endAngle = M_PI_2 + value * M_PI; [self setNeedsDisplay]; } 扇形进度条生成 UIBezierPath根据进度条随时改变结束弧度，设置中心point -(void)drawRect:(CGRect)rect{ CGPoint point = CGPointMake(100 , 100); CGFloat radius = 95.0f; CGFloat startAngle = - M_PI_2; CGFloat endAngle = startAngle + self.endAngle; UIBezierPath * path = [UIBezierPath bezierPathWithArcCenter:point radius:radius startAngle:startAngle endAngle:endAngle clockwise:YES]; [path addLineToPoint:point]; [[UIColor greenColor]set]; [path fill]; UIBezierPath *strokePath = [UIBezierPath bezierPathWithArcCenter:point radius:radius startAngle:0 endAngle:-0.00000001 clockwise:YES]; [[UIColor lightGrayColor]set]; [strokePath stroke]; } - (void)setStartMove:(CGFloat)value{ self.endAngle = value * M_PI * 2; [self setNeedsDisplay]; } 弧形进度条生成 先画一个封闭的背景圆self.backShaperLayer 根据圆弧先设置self.shaperLayer的开始，根据进度条的改变随时改变结束弧度 - (void)drawRect:(CGRect)rect{ self.shapeLayer = [CAShapeLayer layer]; self.shapeLayer.fillColor = [UIColor clearColor].CGColor; self.shapeLayer.lineWidth = 6.0f; self.shapeLayer.strokeColor = [UIColor greenColor].CGColor; self.backShapeLayer = [CAShapeLayer layer]; self.backShapeLayer.fillColor = [UIColor clearColor].CGColor; self.backShapeLayer.lineWidth = 6.0f; self.backShapeLayer.strokeColor = [UIColor darkGrayColor].CGColor; UIBezierPath * path = [UIBezierPath bezierPath]; [path addArcWithCenter:CGPointMake(50, 50) radius:40 startAngle:0 endAngle:M_PI * 2 clockwise:YES]; self.shapeLayer.path = path.CGPath; self.shapeLayer.strokeStart = 0; self.shapeLayer.strokeEnd = self.toValue; self.backShapeLayer.path = path.CGPath; self.backShapeLayer.strokeStart = 0; self.backShapeLayer.strokeEnd = 1; [self.layer addSublayer:self.backShapeLayer]; [self.layer addSublayer:self.shapeLayer]; } - (void)setStartMove:(CGFloat)value{ self.toValue = value; [self setNeedsDisplay]; }]]></content>
      <categories>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Animation_TransitionAnimation]]]></title>
    <url>%2F2017%2F11%2F18%2FAnimation-TransitionAnimation%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 今天周末也没有工作要去加班正好可以好好地整理CATransition动画属性的讲解和应用，以及UIView翻页的实例，简单上手。 TransitionAnimation duration 设置动画时间 type 设置运动类型 1、公有API的Type Fade, 淡入淡出 Push, 推挤 Reveal, 揭开 MoveIn, 覆盖 2、私有API的Type Cube, 立方体 SuckEffect, 吮吸 OglFlip, 翻转 RippleEffect, 波纹 PageCurl, 翻页 PageUnCurl, 反翻页 CameraIrisHollowOpen, 开镜头 CameraIrisHollowClose, 关镜头 3、UIView翻页Type CurlDown, 下翻页 CurlUp, 上翻页 FlipFromLeft, 左翻转 FlipFromRight, 右翻转 subtype 设置运动方向 kCATransitionFromLeft kCATransitionFromBottom kCATransitionFromRight kCATransitionFromTop timingFunction 设置运动轨迹 kCAMediaTimingFunctionLinear 线性,即匀速 kCAMediaTimingFunctionEaseIn 先慢后快 kCAMediaTimingFunctionEaseOut 先快后慢 kCAMediaTimingFunctionEaseInEaseOut 先慢后快再慢 kCAMediaTimingFunctionDefault 实际效果是动画中间比较快. 4、使用方法 - (void) transitionWithType:(NSString *)type WithSubtype:(NSString *)subtype ForView:(UIView *)view{ CATransition *animation = [CATransition animation]; animation.duration = 0.7f; animation.type = type; if (subtype != nil) { animation.subtype = subtype; } [view.layer addAnimation:animation forKey:@&quot;animation&quot;]; } 5、实例应用，UIView上下左右翻页 - (void) animationWithView : (UIView *)view WithAnimationTransition : (UIViewAnimationTransition) transition{ [UIView animateWithDuration:1.0f animations:^{ [UIView setAnimationCurve:UIViewAnimationCurveEaseInOut]; [UIView setAnimationTransition:transition forView:view cache:YES]; } completion:^(BOOL finished) { self.title = @&quot;0000&quot;; }]; }]]></content>
      <categories>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Animation_keyFrameAnimation]]]></title>
    <url>%2F2017%2F11%2F17%2FAnimation-keyFrameAnimation%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 CAPropertyAnimation 的子类有CABsicAnimation 和 CAKeyframeAnimation。今天要说的就是CAKeyframeAnimation关键帧动画，毫无疑问一切复杂的动画都是由简单的动画拼接来的，知其所以然，需要的时候必定能写出好的动画 keyFrameAnimation属性值了解1、关键帧值数组,一组变化值 @property(nullable, copy) NSArray *values; 2、关键帧帧路径,优先级比values大 @property(nullable) CGPathRef path; 3、每一帧对应的时间,时间可以控制速度.它和每一个帧相对应,取值为0.0-1.0,不设则每一帧时间相等. @property(nullable, copy) NSArray *keyTimes; 4、每一帧对应的时间曲线函数,也就是每一帧的运动节奏 @property(nullable, copy) NSArray *timingFunctions; 5、动画的计算模式,默认值: kCAAnimationLinear.有以下几个值: @property(copy) NSString *calculationMode; kCAAnimationLinear 关键帧为座标点的时候,关键帧之间直接直线相连进行插值计算; kCAAnimationDiscrete 离散的,也就是没有补间动画 kCAAnimationPaced 平均，keyTimes跟timeFunctions失效 kCAAnimationCubic 对关键帧为座标点的关键帧进行圆滑曲线相连后插值计算,对于曲线的形状还可以通过tensionValues,continuityValues,biasValues来进行调整自定义,keyTimes跟timeFunctions失效 kCAAnimationCubicPaced 在kCAAnimationCubic的基础上使得动画运行变得均匀,就是系统时间内运动的距离相同,,keyTimes跟timeFunctions失效 6、动画的张力,当动画为立方计算模式的时候此属性提供了控制插值,因为每个关键帧都可能有张力所以连续性会有所偏差它的范围为[-1,1].同样是此作用 @property(nullable, copy) NSArray *tensionValues; 7、动画的连续性值 @property(nullable, copy) NSArray *continuityValues; 8、动画的偏斜率 @property(nullable, copy) NSArray *biasValues; 9、动画沿路径旋转方式,默认为nil.它有两个值: @property(nullable, copy) NSString *rotationMode; kCAAnimationRotateAuto 自动旋转 kCAAnimationRotateAutoReverse 自动翻转 动画应用draw a curve keyFrame： path：路径 duration：单次时间 rotationMode：旋转样式 repeatCount：重复次数 1、弧形 - (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise ; center ： 弧形的中心 radius： 弧形的半径 startAngle：弧形开始弧度 endAngle：弧形结束弧度 colockwise：顺逆时针 2、抛物线 - (void)moveToPoint:(CGPoint)point - (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint; point：开始位置 endPoint：结束位置 controlPoint：拐点位置 3、椭圆形 + (instancetype)bezierPathWithOvalInRect:(CGRect)rect; rect： x起点 y起点 width宽度 height高度 4、圆形 rect： width = height]]></content>
      <categories>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Animation_SpringAnimation]]]></title>
    <url>%2F2017%2F11%2F16%2FAnimation-SpringAnimation%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 昨天整理了BasicAnimation，昨晚对SpringAnimation也进行了梳理。说白了，它的父类也是BasicAnimation，也增加了UIView 实例方法的应用。明天将会整理CATransition动画使用方法和应用实例。 SpringAnimation1、 mass: 质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大 动画的速度变慢，并且波动幅度变大 2、 stiffness: 刚度系数(劲度系数/弹性系数)，刚度系数越大，形变产生的力就越大，运动越快 3、 damping: 阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快 4、 initialVelocity: 初始速率，动画视图的初始速度大小 速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反 5、 CASpringAnimation * springAnimation = [CASpringAnimation animationWithKeyPath:@&quot;position&quot;]; springAnimation.damping = damping; springAnimation.stiffness = stiffness; springAnimation.mass = mass; springAnimation.initialVelocity = initialVelocity; springAnimation.toValue = [NSValue valueWithCGSize:CGSizeMake(self.redView.layer.position.x, self.redView.layer.position.y + 200)]; springAnimation.duration = springAnimation.settlingDuration; [self.redView.layer addAnimation:springAnimation forKey:springAnimation.keyPath]; 6、 [UIView animateWithDuration:5 delay:0 usingSpringWithDamping:0.3 initialSpringVelocity:10 options:UIViewAnimationOptionTransitionFlipFromRight animations:^{ CGPoint point =self.redView.center; point.y += 150; [self.redView setCenter:point]; } completion:^(BOOL finished) { [self.redView setCenter:CGPointMake(250 + 49, 250 + 49)]; [self.redView setBackgroundColor:[UIColor redColor]]; }]; } duration: 动画时长 delay: 动画延迟 damping: 弹簧效果 springVelocity: 初始速度 options: 过度效果]]></content>
      <categories>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Animation_BasicAnimation]]]></title>
    <url>%2F2017%2F11%2F15%2FAnimation-BasicAnimation%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 由于下班的时候出了事故，导致卧病休息了一个月左右，天天根本没时间更新博客，觉得没有记录就没有进步，很难过。好歹前段时间完成了公司的任务，现在有时间整理点东西。关于Animation明天会陆续整理出来，今天就是最简单的BasicAnimation。 BasicAnimation 1、keyPath rotation 旋轉 scale 缩放 translation 平移 CGPoint Key Paths : (example)position.x 位移 CGRect Key Paths : (example)bounds.size.width 伸缩 origin 原点 size 大小 opacity 透明度 backgroundColor 背景 颜色 contents 内容 Shadow Key Path: 阴影 2、 duration：动画的持续时间 3、 repeatCount：动画的重复次数 4、 timingFunction：动画的时间节奏控制 5、Use case 0: animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.x&quot;]; //setFromValue不设置,默认以当前状态为准 [animation setToValue:@(2 * M_PI)]; break; case 1: animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.y&quot;]; //setFromValue不设置,默认以当前状态为准 [animation setToValue:@(2 * M_PI)]; break; case 2: animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;]; //setFromValue不设置,默认以当前状态为准 [animation setToValue:@(2 * M_PI)]; break; case 3: //平移 animation = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;]; //setFromValue不设置,默认以当前状态为准 [animation setToValue:[NSValue valueWithCGPoint:CGPointMake(self.redView.center.x, self.redView.center.y + 200)]]; break; case 4: animation = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;]; [animation setFromValue:@1.0]; [animation setToValue:@0.1]; break; case 5: animation = [CABasicAnimation animationWithKeyPath:@&quot;backgroundColor&quot;]; animation.fromValue = (__bridge id _Nullable)([UIColor redColor].CGColor); animation.toValue = (__bridge id _Nullable)([UIColor greenColor].CGColor); break; case 6: animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;]; [animation setFromValue:@1.0]; [animation setToValue:@0.1]; break; case 7: animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale.x&quot;]; [animation setFromValue:@1.0]; [animation setToValue:@0.1]; break; case 8: animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale.y&quot;]; [animation setFromValue:@1.0]; [animation setToValue:@0.1]; break; case 9: animation = [CABasicAnimation animationWithKeyPath:@&quot;bounds&quot;]; [animation setToValue:[NSValue valueWithCGRect:CGRectMake(self.redView.frame.origin.x, self.redView.frame.origin.y, 200, 200)]]; break; default: break; } [animation setDelegate:self];//代理回调 [animation setDuration:1];//设置动画时间，单次动画时间 [animation setRemovedOnCompletion:NO];//默认为YES,设置为NO时setFillMode有效 [animation setTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]]; [animation setAutoreverses:YES]; [animation setFillMode:kCAFillModeBoth]; [self.redView.layer addAnimation:animation forKey:@&quot;basicAnimation&quot;];]]></content>
      <categories>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS_零碎知识点整理]]]></title>
    <url>%2F2017%2F09%2F30%2FiOS-%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. 明天就十一，项目也告一段路，今天就把以前的零碎知识点整理下，备忘录好几页找都不好找了 iOS中属性@property的常用关键字strong，weak，assign，copy，nonatomic，retain ，atomic…. 属性 解析 strong 释放旧对象，将旧对象的值赋予输入对象，输入对象的索引计数加1 weak 不增加引用计数，不持有对象，因此也不能决定对象释放 assign 适用于基础数据类型（NSInteger CGFloat…），不增加引用计数 copy 建立一个索引计数为1 的对象然后释放旧对象，此属性只对那些实行了NSCopying协议的对象类型有效（NSString , Block） nonatomic 非原子性访问对于属性赋值的时候不加锁，多线程并发访问会提高性能，如果不加此属性则默认是两个访问方法都为原子型事务访问 retain 对象的引用计数+1。ARC下已经不再使用此关键字，用strong代替 atomic 和 nonatomic用来决定编译器生成的getter和setter是否为原子操作，atomic设置成员变量的@property属性时 默认为是atomic 提供线程安全 unsafe_unretained 跟weak类似，声明一个弱引用，但是当引用计数为0时，变量不会自动设置为nil ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？strong, atomic, readwrite copy 和 strong（1）因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.（2）如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性 ClassClass 是一个 objc_class 结构类型的指针；而 id（任意对象） 是一个 objc_object 结构类型的指针struct objc_class { struct objc_class* isa; struct objc_class* super_class; const char* name; long version; long info; long instance_size; struct objc_ivar_list* ivars; struct objc_method_list** methodLists; struct objc_cache* cache; struct objc_protocol_list* protocols; }; （1）isa：对象的isa指向类（class），类的isa指向元类（meta class），元类isa指向元类的根类（root meteClass）。isa 帮助一个对象找到它的方法 （2）super_class：指向该类的父类！如果该类已经是最顶层的根类，如 NSObject 或 NSProxy），那么 super_class 就为 NULL。 （3）name：一个 C 字符串，指示类的名称。 （4）version：类的版本信息，默认初始化为 0。我们可以在运行期对其进行修改（class_setVersion）或获取 （5）info：供运行期使用的一些位标识。有如下一些位掩码：CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含实例方法和变量；CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法；CLS_INITIALIZED (0x4L) 表示该类已经被运行期初始化了，这个标识位只被 objc_addClass 所设置；CLS_POSING (0x8L) 表示该类被 pose 成其他的类；（poseclass 在ObjC 2.0中被废弃了）；CLS_MAPPED (0x10L) 为ObjC运行期所使用CLS_FLUSH_CACHE (0x20L) 为ObjC运行期所使用CLS_GROW_CACHE (0x40L) 为ObjC运行期所使用CLS_NEED_BIND (0x80L) 为ObjC运行期所使用CLS_METHOD_ARRAY (0x100L) 该标志位指示 methodlists 是指向一个 objc_method_list 还是一个包含 objc_method_list 指针的数组； （6）instance_size：该类的实例变量大小（包括从父类继承下来的实例变量）。 （7）ivars：指向 objc_ivar_list 的指针，存储每个实例变量的内存地址，如果该类没有任何实例变量则为 NULL； （8）methodLists：与 info 的一些标志位有关，CLS_METHOD_ARRAY 标识位决定其指向的东西（是指向单个 objc_method_list还是一个 objc_method_list 指针数组），如果 info 设置了 CLS_CLASS 则 objc_method_list 存储实例方法，如果设置的是 CLS_META 则存储类方法； （9）cache：指向 objc_cache 的指针，用来缓存最近使用的方法，以提高效率。 （10）protocols：指向 objc_protocol_list 的指针，存储该类声明要遵守的正式协议。 IMPIMP本质上就是一个函数指针，指向方法的实现，在objc.h找到它的定义typedef void (IMP)(void / id, SEL, … */ ); #elsetypedef id (*IMP)(id, SEL, …); #endif objc_msgSendobjc_msgSend它具体是如何发送消息：首先根据receiver对象的isa指针获取它对应的class；优先在class的cache查找message方法，如果找不到，再到methodLists查找；如果没有在class找到，再到super_class查找；一旦找到message这个方法，就执行它实现的IMP。注：当objc_msgSend找不到实现的IMP时，程序并不会直接崩溃，而是给开发者一个plan b：方法决议与消息转发 iOS的一些小技巧控件 设置UILable行间距 NSMutableAttributedString* attrString = [[NSMutableAttributedString alloc] initWithString:label.text]; NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init]; [style setLineSpacing:20]; [attrString addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, label.text.length)]; label.attributedText = attrString; UILabel显示不同颜色字体 NSMutableAttributedString * string = [[NSMutableAttributedString alloc] initWithString:label.text]; [string addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0,5)]; [string addAttribute:NSForegroundColorAttributeName value:[UIColor greenColor] range:NSMakeRange(5,6)]; [string addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(11,5)]; label.attributedText = string; 动画修改label上的文字 方法一 CATransition * animation = [CATransition animation]; animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; animation.type = kCATransitionFade; animation.duration = 0.75; [self.label.layer addAnimation:animation forKey:@&quot;kCATransitionFade&quot;]; self.label.text = @&quot;New&quot;; 方法二 [UIView transitionWithView:self.label duration:0.25f options:UIViewAnimationOptionTransitionCrossDissolve animations:^{ self.label.text = @&quot;Well done!&quot;; } completion:nil]; 方法三 [UIView animateWithDuration:1.0 animations:^{ self.label.alpha = 0.0f; self.label.text = @&quot;newText&quot;; self.label.alpha = 1.0f; }]; 播放一张张连续的图片 加入现在有三张图片分别为animate_1、animate_2、animate_3 方法一： imageView.animationImages = @[[UIImage imageNamed:@&quot;animate_1&quot;], [UIImage imageNamed:@&quot;animate_2&quot;], [UIImage imageNamed:@&quot;animate_3&quot;]]; imageView.animationDuration = 1.0; 方法二： imageView.image = [UIImage animatedImageNamed:@&quot;animate_&quot; duration:1.0]; 方法二解释下： 这个方法会加载animate_为前缀的，后边0-1024，也就是animate_0、animate_1一直到animate_1024 修改UISearBar内部背景颜色 UITextField *textField = [_searchBar valueForKey:@&quot;_searchField&quot;]; textField.backgroundColor = [UIColor redColor]; 监听UISlider拖动状态 [slider addTarget:self action:@selector(sliderValurChanged:forEvent:) forControlEvents:UIControlEventValueChanged]; - (void)sliderValurChanged:(UISlider*)slider forEvent:(UIEvent*)event { UITouch *touchEvent = [[event allTouches] anyObject]; switch (touchEvent.phase) { case UITouchPhaseBegan: NSLog(@&quot;开始拖动&quot;); break; case UITouchPhaseMoved: NSLog(@&quot;正在拖动&quot;); break; case UITouchPhaseEnded: NSLog(@&quot;结束拖动&quot;); break; default: break; } } 加密 MD5加密 + (NSString *)md5:(NSString *)str { const char *concat_str = [str UTF8String]; unsigned char result[CC_MD5_DIGEST_LENGTH]; CC_MD5(concat_str, (unsigned int)strlen(concat_str), result); NSMutableString *hash = [NSMutableString string]; for (int i =0; i&lt;16; i++){ [hash appendFormat:@&quot;X&quot;, result[i]]; } return [hash uppercaseString]; } base64加密 @interface NSData (Base64) /** * @brief 字符串base64后转data */ + (NSData *)dataWithBase64EncodedString:(NSString *)string { if (![string length]) return nil; NSData *decoded = nil; #if __MAC_OS_X_VERSION_MIN_REQUIRED &lt; __MAC_10_9 || __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_7_0 if (![NSData instancesRespondToSelector:@selector(initWithBase64EncodedString:options:)]) { #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot; decoded = [[self alloc] initWithBase64Encoding:[string stringByReplacingOccurrencesOfString:@&quot;[^A-Za-z0-9+/=]&quot; withString:@&quot;&quot; options:NSRegularExpressionSearch range:NSMakeRange(0, [string length])]]; #pragma clang diagnostic pop } else #endif { decoded = [[self alloc] initWithBase64EncodedString:string options:NSDataBase64DecodingIgnoreUnknownCharacters]; } return [decoded length]? decoded: nil; } /** * @brief NSData转string * @param wrapWidth 换行长度 76 64 */ - (NSString *)base64EncodedStringWithWrapWidth:(NSUInteger)wrapWidth { if (![self length]) return nil; NSString *encoded = nil; #if __MAC_OS_X_VERSION_MIN_REQUIRED &lt; __MAC_10_9 || __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_7_0 if (![NSData instancesRespondToSelector:@selector(base64EncodedStringWithOptions:)]) { #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot; encoded = [self base64Encoding]; #pragma clang diagnostic pop } else #endif { switch (wrapWidth) { case 64: { return [self base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength]; } case 76: { return [self base64EncodedStringWithOptions:NSDataBase64Encoding76CharacterLineLength]; } default: { encoded = [self base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)0]; } } } if (!wrapWidth || wrapWidth &gt;= [encoded length]) { return encoded; } wrapWidth = (wrapWidth / 4) * 4; NSMutableString *result = [NSMutableString string]; for (NSUInteger i = 0; i &lt; [encoded length]; i+= wrapWidth) { if (i + wrapWidth &gt;= [encoded length]) { [result appendString:[encoded substringFromIndex:i]]; break; } [result appendString:[encoded substringWithRange:NSMakeRange(i, wrapWidth)]]; [result appendString:@&quot;\r\n&quot;]; } return result; } /** * @brief NSData转string 换行长度默认64 */ - (NSString *)base64EncodedString { return [self base64EncodedStringWithWrapWidth:0]; } 3DES加密 #import @interface NSData (3DES) /** * 利用3DES加密数据 */ - (NSData*)encryptedWith3DESUsingKey:(NSString*)key andIV:(NSData*)iv { NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding]; size_t dataMoved; NSMutableData *encryptedData = [NSMutableData dataWithLength:self.length + kCCBlockSize3DES]; CCCryptorStatus result = CCCrypt(kCCEncrypt,kCCAlgorithm3DES,kCCOptionPKCS7Padding,keyData.bytes,keyData.length,iv.bytes,self.bytes,self.length,encryptedData.mutableBytes,encryptedData.length,&amp;dataMoved); if (result == kCCSuccess) { encryptedData.length = dataMoved; return encryptedData; } return nil; } /** * @brief 利用3DES解密数据 */ - (NSData*)decryptedWith3DESUsingKey:(NSString*)key andIV:(NSData*)iv { NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding]; size_t dataMoved; NSMutableData *decryptedData = [NSMutableData dataWithLength:self.length + kCCBlockSize3DES]; CCCryptorStatus result = CCCrypt(kCCDecrypt,kCCAlgorithm3DES,kCCOptionPKCS7Padding,keyData.bytes,keyData.length,iv.bytes,self.bytes,self.length,decryptedData.mutableBytes,decryptedData.length,&amp;dataMoved); if (result == kCCSuccess) { decryptedData.length = dataMoved; return decryptedData; } return nil; } 零碎知识点 页面跳转实现翻转动画 modal方式 TestViewController *vc = [[TestViewController alloc] init]; vc.view.backgroundColor = [UIColor redColor]; vc.modalTransitionStyle = UIModalTransitionStyleCoverVertical; [self presentViewController:vc animated:YES completion:nil]; push方式: TestViewController *vc = [[TestViewController alloc] init]; vc.view.backgroundColor = [UIColor redColor]; [UIView beginAnimations:@&quot;View Flip&quot; context:nil]; [UIView setAnimationDuration:0.80]; [UIView setAnimationCurve:UIViewAnimationCurveEaseInOut]; [UIView setAnimationTransition:UIViewAnimationTransitionFlipFromRight forView:self.navigationController.view cache:NO]; [self.navigationController pushViewController:vc animated:YES]; [UIView commitAnimations]; 多网络请求： dispatch_group_t group = dispatch_group_create(); dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.wzb.test.www&quot;, DISPATCH_QUEUE_SERIAL); dispatch_group_enter(group); dispatch_group_async(group, serialQueue, ^{ // 网络请求一 [WebClick getDataSuccess:^(ResponseModel *model) { dispatch_group_leave(group); } failure:^(NSString *err) { dispatch_group_leave(group); }]; }); dispatch_group_enter(group); dispatch_group_async(group, serialQueue, ^{ // 网络请求二 [WebClick getDataSuccess:getBigTypeRM onSuccess:^(ResponseModel *model) { dispatch_group_leave(group); } failure:^(NSString *errorString) { dispatch_group_leave(group); }]; }); dispatch_group_enter(group); dispatch_group_async(group, serialQueue, ^{ // 网络请求三 [WebClick getDataSuccess:^{ dispatch_group_leave(group); } failure:^(NSString *errorString) { dispatch_group_leave(group); }]; }); // 所有网络请求结束后会来到这个方法 dispatch_group_notify(group, serialQueue, ^{ dispatch_async(dispatch_get_global_queue(0, 0), ^{ dispatch_async(dispatch_get_main_queue(), ^{ // 刷新UI }); }); }); 监听scrollView是否滚动到了顶部／底部 -(void)scrollViewDidScroll: (UIScrollView*)scrollView { float scrollViewHeight = scrollView.frame.size.height; float scrollContentSizeHeight = scrollView.contentSize.height; float scrollOffset = scrollView.contentOffset.y; if (scrollOffset == 0) { // 滚动到了顶部 } else if (scrollOffset + scrollViewHeight == scrollContentSizeHeight) { // 滚动到了底部 } } 过滤空格 -(NSString *)userName:(NSString *)name{ name = [name stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];//前后空格 name = [name stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];//中间空格 return name; } 获取邮箱用户部分和域名部分 - (BOOL)validateEmail:(NSString *)email { if ((0 != [email rangeOfString:@&quot;@&quot;].length) &amp;&amp; (0 != [email rangeOfString:@&quot;.&quot;].length)) { NSCharacterSet *tmpInvalidCharSet = [[NSCharacterSet alphanumericCharacterSet] invertedSet]; NSMutableCharacterSet *tmpInvalidMutableCharSet = [tmpInvalidCharSet mutableCopy]; [tmpInvalidMutableCharSet removeCharactersInString:@&quot;_-&quot;]; NSRange range1 = [email rangeOfString:@&quot;@&quot; options:NSCaseInsensitiveSearch]; //取得用户名部分 NSString *userNameString = [email substringToIndex:range1.location]; NSLog(@&quot;length---%ld&quot;,userNameString.length); if (userNameString.length &lt; 1 || userNameString.length &gt; 20) { return NO; }else //取得域名部分 NSString *domainString = [email substringFromIndex:range1.location + 1]; NSArray *domainArray = [domainString componentsSeparatedByString:@&quot;.&quot;]; for (NSString *string in domainArray) { NSRange rangeOfInavlidChars = [string rangeOfCharacterFromSet:tmpInvalidMutableCharSet]; if (rangeOfInavlidChars.length != 0 || [string isEqualToString:@&quot;&quot;]) return NO; } return YES; } else { return NO; } }]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS_正则表达式]]]></title>
    <url>%2F2017%2F09%2F25%2FiOS-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. 新的项目用户名、邮箱和密码等要用到正则，所以就把以前整理的拿出来用了，不要太方便，索性就打个flag吧。嗯，我以前笔记做的还是比较清楚的 正则表达式记录表 元字符1、 \b : 单词的开始或结束 2、 .* : 任意数量的不包含换行的字符 . : 匹配除换行符以外的任意字符 3、 \d : 是新的元字符，匹配一位数字 \d{n} : 必须连续重复匹配n次 4、 \s : 匹配任意的空白符（空格，制表格，换行符，中文全角空格等） 5、 \w : 匹配字母或者数字或者下划线或者汉字等 6、 ^ : 匹配字符串的开始 ￥ : 匹配字符串的结束 注意： * 字符转义 如果你想查找元字符本身，比如.和* ，这时候你就应该使用\.和\* 重复 代码 | 说明 ------------- | ------------- * | 重复零次或更多次 + | 重复一次或更多次 ? | 重复零次或一次 {n} | 重复n次 {n,} | 重复n次或更多次 {n,m} | 重复n到m次 注意： *字符类 如果想匹配没有预定义的元字符集合，比如a，e，o。这时候你就要[aeo]就匹配任何一个英文元音的字母。[.?!]匹配任意一个标点符号 分枝条件 满足任意一种规则都应该当成匹配，用 | 把不同的规则分割开来 0\d{2}-\d{8}|0\d{3}-\d{7} 这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445) \(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔 使用分枝条件时，要注意个分枝的顺序 \d{5}-\d{4}|\d{5} 换成 \d{5}|\d{5}-\d{4}，那么就只会匹配5位的邮编。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了 重复多个字符，使用分组 (\d{1,3}\.){3}\d{1,3}是一个简单的IP地址匹配表达式 (\d{1,3}\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3}) 不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址 ((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。解析正确IP：01-09,0-255 1. 2[0-4]\d :（200-249) 2. 25[0-5] :(250-255) 3. [01]?\d\d? : (01-09,0-199) 反义 代码 |语法 --------------|------------------- \W |匹配任意不是字母，数字，下划线，汉字的字符 \S |匹配任意不是空白符的字符 \D |匹配任意非数字的字符 \B |匹配不是单词开头或结束的位置 [^x] |匹配除了x以外的任意字符 [^aeiou] |匹配除了aeiou这几个字母以外的任意字符 例如： \S+匹配不包含空白符的字符串。 &lt;a[^&gt;]+&gt;匹配用尖括号括起来的以a开头的字符串 后向引用常用分组语法 分类 |代码/语法 |说明 -----------|-------------|----------------- 捕获 | (exp) |匹配exp,并捕获文本到自动命名的组里 | (?&lt;name&gt;exp |匹配exp,并捕获文本到名称为name的组里，也可以写成(?&apos;name&apos;exp) | (?:exp) |匹配exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言 | (?=exp) | 匹配exp前面的位置 | (?&lt;=exp) |匹配exp后面的位置 | (?!exp) |匹配后面跟的不是exp的位置 | (?&lt;!exp) |匹配前面不是exp的位置 注释 | (?#comment) |这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 注意： 分组0对应整个正则表达式 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号 你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权 例如： \b(\w+)\b\s+\1\b可以用来匹配重复的单词：html html 零宽断言 &lt;?!w+&gt; ?&lt;!w+ \b\w*q[^u]\w*\b匹配包含后面不是字母u的字母q的单词。 你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w*\b将会匹配下一个单词，于是\b\w*q[^u]\w*\b就能匹配整个Iraq fighting 负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：\b\w*q(?!u)\w*\b 例如 \d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。 (?&lt;![a-z])\d{7}匹配前面不是小写字母的七位数字。 (?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)匹配不包含属性的简单HTML标签内里的内容：被尖括号括起来的单词(比如可能是&lt;b&gt;)，然后是.*(任意的字符串),最后是一个后缀(?=&lt;\/\1&gt;)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是&lt;b&gt;的话，后缀就是&lt;/b&gt;了。整个表达式匹配的是&lt;b&gt;和&lt;/b&gt;之间的内容(再次提醒，不包括前缀和后缀本身) 注释 代码 |语法 ------------------|----------------- (?&lt;= |# 断言要匹配的文本的前缀 &lt;(\w+)&gt; |# 查找尖括号括起来的字母或数字(即HTML/XML标签) ( | # 前缀结束 .* | # 匹配任意文本 (?= | # 断言要匹配的文本的后缀 &lt;\ / \1&gt; |# 查找尖括号括起来的内容：前面是一个&quot;/&quot;，后面是先前捕获的标签 ) | # 后缀结束 例如： 2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)。 贪婪和懒惰 a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。它会匹配整个字符串aabab。这被称为贪婪匹配 a.*?b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，匹配任意数量的重复，(但是在能使整个匹配成功的前提下)使用最少的重复,会匹配aab和ab。这被称为懒惰匹配 注意： 为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？ 简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高： 最先开始的匹配拥有最高的优先权 懒惰限定符 代码 |说明 -----------------|------------------------ *？ |重复任意次，但尽可能少重复 +？ |重复1次或更多次，但尽可能少重复 ？？ |重复0次或1次，但尽可能少重复 {n,m}? |重复n到m次，但尽可能少重复 {n,}? |重复n次以上，但尽可能少重复 处理选项注意: Regex regex = new Regex(@&quot;\ba\w{6}\b&quot;, RegexOptions.IgnoreCase); 常用的处理选项 名称 |说明 ---------------------------|-------------------------------- IgnoreCase |匹配时不区分大小写 Multiline |更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.) Singleline |更改.的含义，使它与每一个字符匹配（包括换行符\n） IgnorePatternWhitespace |忽略表达式中的非转义空白并启用由#标记的注释。 ExplicitCapture | 仅捕获已被显式命名的组。 常用事例 说明 |正则表达式 -----------------|---------------------------- 网址(url) |[a-zA-z]+://[^\s]* IP地址 |((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?) 电子邮件(email) |\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)* QQ号码 | [1-9]\d{4,} HTML标签 |&lt;(.*)(.*)&gt;.*&lt;\/\1&gt;|&lt;(.*) \/&gt; 密码(有数字/大写字母/小写字母/标点，8位以上) |(?=^.{8,}$)(?=.*\d)(?=.*\W+)(?=.*[A-Z])(?=.*[a-z])(?!.*\n).*$ 日期 |(\d{4}|\d{2})-((1[0-2])|(0?[1-9]))-(([12][0-9])|(3[01])|(0?[1-9])) 汉字 |[\u4e00-\u9fa5] 中文及全角标点符号 |[\u3000-\u301e\ufe10-\ufe19\ufe30-\ufe44\ufe50-\ufe6b\uff01-\uffee] 注意： ios 开发使用 RegexKit.framework 框架 使用规则： 昵称验证：(4-8)位汉字 + (BOOL) validateNickname:(NSString *)nickname { NSString *nicknameRegex = @&quot;^[\u4e00-\u9fa5]{4,8}$&quot;; NSPredicate *passWordPredicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,nicknameRegex]; return [passWordPredicate evaluateWithObject:nickname]; } 密码验证：(6-20)位英文不分大小写和数字 + (BOOL) validatePassword:(NSString *)passWord { NSString *passWordRegex = @&quot;^[a-zA-Z0-9]{6,20}+$&quot;; NSPredicate *passWordPredicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,passWordRegex]; return [passWordPredicate evaluateWithObject:passWord]; } 邮箱验证： + (BOOL) validateEmail:(NSString *)email { NSString *emailRegex = @&quot;[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}&quot;; NSPredicate *emailTest = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, emailRegex]; return [emailTest evaluateWithObject:email]; }]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[GIT_版本库管理]]]></title>
    <url>%2F2017%2F09%2F22%2FGIT-%E7%89%88%E6%9C%AC%E5%BA%93%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[今天新同事不会用git，着实让我惊讶了，还好我有做笔记的习惯。就把我A long time ago 学习整理的git给他了，上手简单，很快就会成为git 大神，啊哈哈 Git 小技能多人开发Git版本库的管理是再好不过的了，首先你要会把远程仓库的代码clone到你的电脑里，其次建立本地你的分支，写上你的code，然后添加到暂存区，没有问题就提交到修改区。既然是同时开发，肯能你同事也修改了，那就要把他的code先从远程仓库pull下来，不管你知不知道他们是否提交，避免冲突，先pull再push。然后无误后在merge到master分支，一切一气呵成。 远程仓库管理 先克隆代码到桌面吧，这克隆的是master分支代码 cd desktop git clone (远程仓库地址) 如果你想克隆远程别的分支代码 git checkout -b (分支名) origin/(远程分支名) git checkout —track origin/(远程分支名) 添加远程仓库 git remote add origin (远程仓库地址)： 删除远程仓库 git remote remove origin (远程仓库地址) 显示远程分支 git remote show origin 代码管理 代码添加到暂存区 git add (文件名)：添加某个文件 git add . : 添加所有文件 git add -A : 添加所有文件夹和文件 代码添加到当前分支 git commit -m "提交描述" 拉取远程代码 git pull origin (远程分支) 同步本地代码 git push origin (远程分支) 分支管理 查看当前分支 git branch 创建新的分支 git checkout -b newBranch 删除旧的分支 git checkout -d newBranch 合并分支 git merge (要合并的分支) 提交管理 找到历史提交的commit id git log —pretty=oneline —abbrev-commit 取消暂存 git reset HEAD 文件名 放弃当前修改 git checkout -- (文件名)：（放弃当前文件修改） git checkout . :(放弃当前所有修改) 恢复commit_id对应的版本 git reset --hard commit_id 标签管理 查看标签 git tag 查看标签信息 git show v1.0 创建标签 git tag v1.0 : 创建1.0标签 git tag v2.0 (commit_id): 创建指定提交的标签 删除标签 git tag -d v1.0 :（删除1.0标签） git push origin :refs/tags/v0.9：（删除远程0.9标签） 推送本地标签 git push origin v1.0 ：（推送本地标签到远程） git push origin —tags：（推送所有本地标签到远程） 当然没有写Git冲突处理，因为我觉得冲突太简单了，打开项目包内容，定位到冲突的地方。保留正确的code，删除多余的运行就OK。如果一些乱七八糟的冲突，当然我也遇到过但是没有记录下来，很遗憾。 冲突解决]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[机器学习_CoreML_Inceptionv3]]]></title>
    <url>%2F2017%2F09%2F21%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-CoreML-Inceptionv3%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome:github地址 一直直接用图片给.mlmodel去识别，觉得没有直接调用相机来的方便，一直看的都是swift版本的，所以想写一个oc的，立个flag。 CoreML_Inceptionv3 相机调用 info.plist 添加调用相机请求 相机调用请求 相机数据输出的delegate 实例化对象 摄像显示区域 相机调用请求 相机数据输出 线程 数据显示 InceptionvModel InceptionvModel输出 @property (nonatomic,strong) AVCaptureVideoPreviewLayer *previewLayer; @property (nonatomic,strong) AVCaptureSession *session; @property (nonatomic,strong) AVCaptureVideoDataOutput *videoOutPut; @property (nonatomic,strong) AVCaptureConnection *videoConnection; @property (nonatomic,strong) dispatch_queue_t videoQueue; @property (nonatomic,strong) UILabel *resultLabel; @property (nonatomic,strong) Inceptionv3 *InceptionvModel; @property (nonatomic,strong) Inceptionv3Output *outPut; 相机调用请求 self.session = [[AVCaptureSession alloc] init]; //视频 AVCaptureDevice *videoDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; if (videoDevice.isFocusPointOfInterestSupported && [videoDevice isFocusModeSupported:AVCaptureFocusModeContinuousAutoFocus]) { [videoDevice lockForConfiguration:nil]; [videoDevice setFocusMode:AVCaptureFocusModeContinuousAutoFocus]; [videoDevice unlockForConfiguration]; } AVCaptureDeviceInput *cameraDeviceInput = [[AVCaptureDeviceInput alloc] initWithDevice:videoDevice error:nil]; if ([self.session canAddInput:cameraDeviceInput]) { [self.session addInput:cameraDeviceInput]; } //视频 self.videoOutPut = [[AVCaptureVideoDataOutput alloc] init]; NSDictionary * outputSettings = [[NSDictionary alloc] initWithObjectsAndKeys:[NSNumber numberWithInt:kCVPixelFormatType_32BGRA],(id)kCVPixelBufferPixelFormatTypeKey, nil]; [self.videoOutPut setVideoSettings:outputSettings]; if ([self.session canAddOutput:self.videoOutPut]) { [self.session addOutput:self.videoOutPut]; } self.videoConnection = [self.videoOutPut connectionWithMediaType:AVMediaTypeVideo]; self.videoConnection.enabled = NO; [self.videoConnection setVideoOrientation:AVCaptureVideoOrientationPortrait]; 初始化预览层 self.previewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:self.session]; [self.previewLayer setVideoGravity:AVLayerVideoGravityResizeAspectFill]; 打开相机 [self.session startRunning]; self.videoConnection.enabled = YES; self.videoQueue = dispatch_queue_create("videoQueue", NULL); [self.videoOutPut setSampleBufferDelegate:self queue:self.videoQueue]; 关闭相机 [self.videoOutPut setSampleBufferDelegate:nil queue:nil]; self.videoConnection.enabled = NO; self.videoQueue = nil; [self.session stopRunning]; CoreML数据输出 获取相机数据输出的CMSampleBufferRef 转换成UIImage大小为299.299 输出为Inceptionv3Output 下载Inceptionv3.mlmodel target-&gt;build phases-&gt;compile sources 添加Inceptionv3.mlmodel 导入头文件Inceptionv3.h 数据转换 -(UIImage *)image:(CGSize)resize{ UIGraphicsBeginImageContext(resize); [self drawInRect:CGRectMake(0, 0, resize.width, resize.height)]; UIImage * image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image; } 数据输出 -(void)imageOutput:(CMSampleBufferRef)sampleBuffer{ CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer); CIImage * ciImage = [CIImage imageWithCVImageBuffer:imageBuffer]; Inceptionv3Image * uiImage =[[Inceptionv3Image alloc]initWithCIImage:ciImage]; UIImage * uiimage = [uiImage image:CGSizeMake(299, 299)]; CGImageRef cgImage = uiimage.CGImage; CVPixelBufferRef pixelBuffer = [ImageConvert pixelBufferFromImage:cgImage]; self.InceptionvModel = [[Inceptionv3 alloc]init]; self.outPut = [self.InceptionvModel predictionFromImage:pixelBuffer error:nil]; } 在AVCaptureOutputDelegat回调方法中开启线程 把相机输出的数据转换成Inceptionv3接收的数据 在主线程刷新界面 dispatch_queue_t queue = dispatch_queue_create("CMSampleBufferRef", NULL); dispatch_sync(queue, ^{ [self imageOutput:sampleBuffer]; dispatch_async(dispatch_get_main_queue(), ^{ self.resultLabel.text = self.outPut.classLabel; }); });]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[机器学习_CoreML_MobileNet]]]></title>
    <url>%2F2017%2F09%2F20%2FPython-CoreML-MobileNet%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome:github地址 CoreML_MobileNet接着上面再写一个MobileNet.mlmodel,这次这个直接拿来用。 GoogLeNetPlaces.mlmodel 和 Resnet50都可以识别人物和静态物体。不过这个才24M，小多了，所以就简尔处理给张特定的image，然后输出结果 Download Core ML ModelGoogLeNetPlaces.mlmodel下载地址 导入头文件 #import < CoreML/CoreML.h> #import < Vision/Vision.h> #import "GoogLeNetPlaces.h" 图片识别 创建Resnet对象，加载CoreMLModel GoogLeNetPlaces *googleModel = [[GoogLeNetPlaces alloc] init]; VNCoreMLModel * vnCoreModel = [VNCoreMLModel modelForMLModel:googleModel.model error:nil]; 创建Vision请求，带有completion handle VNCoreMLRequest * vnCoreMlRequest = [[VNCoreMLRequest alloc] initWithModel:vnCoreModel completionHandler:^(VNRequest * _Nonnull request, NSError * _Nullable error) { CGFloat confidence = 0.0f; VNClassificationObservation * tempClassification = nil; for (VNClassificationObservation *classification in request.results) { if (classification.confidence > confidence) { confidence = classification.confidence; tempClassification = classification; } } }]; VNClassificationObservation对象两个属性 identifier：识别对象 confidence：识别率 发送图片识别请求 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ VNImageRequestHandler * vnImageRequestHandler = [[VNImageRequestHandler alloc] initWithCGImage:image.CGImage options:nil]; NSError *error = nil; [vnImageRequestHandler performRequests:@[vnCoreMlRequest] error:&error]; if (error) { NSLog(@"%@",error.localizedDescription); } }); 回调在主线程更新UI dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ self.resultLable.text = [NSString stringWithFormat:@"识别结果:%@",tempClassification.identifier]; self.confidenceLabel.text = [NSString stringWithFormat:@"匹配率:%@",@(tempClassification.confidence)]; }); 多次下来是不是很简单，大同小异，只要熟悉CoreML，一切就是那么easy]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[机器学习_CoreML_Resnet50]]]></title>
    <url>%2F2017%2F09%2F20%2FPython-CoreML-Resnet50%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome:github地址 CoreML_Resnet50把玩了几天的CoreML，现在上手就写很是方便啊，所以研究透之后再来些例子就简单了。这次用的是苹果提供的resnet50.mlmodel。 Download Core ML ModelResnet50.mlmodel下载地址 导入 把下载后的mlmodel放入Xcode里面，绑定target，会自动生成.h和.m文件 导入头文件 #import < CoreML/CoreML.h> #import < Vision/Vision.h> #import "Resnet50.h" 添加UIScrollView和UIPageControl self.scrollView = [[UIScrollView alloc]initWithFrame:CGRectMake(0, 0, viewWidth, 250)]; self.scrollView.delegate = self; self.scrollView.bounces = YES; self.scrollView.contentSize = CGSizeMake(5 * viewWidth, 250); self.scrollView.pagingEnabled = YES; self.scrollView.showsHorizontalScrollIndicator = NO; [self.view addSubview:self.scrollView]; self.pageControl = [[UIPageControl alloc]init]; [self.pageControl setCenter:CGPointMake(viewWidth / 2 - 20, 250 - 10)]; self.pageControl.numberOfPages = 5; self.pageControl.pageIndicatorTintColor = [UIColor blackColor]; self.pageControl.currentPageIndicatorTintColor = [UIColor redColor]; for (int i = 0; i < 5; i ++) { UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(i * viewWidth, 0, viewWidth, 250)]; imageView.image = [UIImage imageNamed:[NSString stringWithFormat:@"%d.jpg",i + 1]]; [self.scrollView addSubview:imageView]; } [self.view addSubview:self.pageControl]; 滚动到开头或末尾 if (scrollView.contentOffset.x > 4 * viewWidth) { self.scrollView.contentOffset = CGPointMake(0, 0); }else if (scrollView.contentOffset.x < 0){ self.scrollView.contentOffset = CGPointMake(4 * viewWidth, 0); } 滚动结束后识别图片 self.currentImage =[UIImage imageNamed:[NSString stringWithFormat:@"%d.jpg",(int)(self.pageControl.currentPage)]]; [self openResnet50]; 图片识别 创建Resnet对象，加载CoreMLModel Resnet50 *resnetModel = [[Resnet50 alloc] init]; VNCoreMLModel * vnCoreModel = [VNCoreMLModel modelForMLModel:resnetModel.model error:nil]; 创建Vision请求，带有completion handle VNCoreMLRequest * vnCoreMlRequest = [[VNCoreMLRequest alloc] initWithModel:vnCoreModel completionHandler:^(VNRequest * _Nonnull request, NSError * _Nullable error) { CGFloat confidence = 0.0f; VNClassificationObservation * tempClassification = nil; for (VNClassificationObservation *classification in request.results) { if (classification.confidence > confidence) { confidence = classification.confidence; tempClassification = classification; } } }]; VNClassificationObservation对象两个属性 identifier：识别对象 confidence：识别率 发送图片识别请求 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ VNImageRequestHandler * vnImageRequestHandler = [[VNImageRequestHandler alloc] initWithCGImage:image.CGImage options:nil]; NSError *error = nil; [vnImageRequestHandler performRequests:@[vnCoreMlRequest] error:&error]; if (error) { NSLog(@"%@",error.localizedDescription); } }); 回调在主线程更新UI dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ self.resultLable.text = [NSString stringWithFormat:@"识别结果:%@",tempClassification.identifier]; self.confidenceLabel.text = [NSString stringWithFormat:@"匹配率:%@",@(tempClassification.confidence)]; });]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[机器学习_Python_mlmodel]]]></title>
    <url>%2F2017%2F09%2F20%2FPython-mlmodel%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome:github地址 CoreMLModel把玩CoreML创建自己的.mlmodel的心酸历程，足足摆弄了半天，各种坑。立个flag [Permission denied]问题 pip install -U coremltools 从图也可以看出coremltools包含numpy,six,protobuf,coremltools。因为权限问题导致失败 sudo pip install -U coremltools 遇到[Permission denied]都要加sudo ImportError: No module named pkg_resources 问题 Step: 1 Login in root user. sudo su root Step: 2 Uninstall python-pip package if existing. apt-get purge -y python-pip Step: 3 Download files using wget command(File download in pwd ) wget https://bootstrap.pypa.io/get-pip.py Step: 4 Run python file. python ./get-pip.py Step: 5 Finaly exicute installation command. apt-get install python-pip Note: User must be root. 好吧，这两个问题遍布整个流程，期间各种小问题我已经不记得了，接下来就开始正文了 下载coremltools sudo pip install -U coremltools 下载pip.py文件 sudo python get-pip.py 下载scikit-learn sudo pip install -U numpy scipy scikit-learn 下载panda sudo pip install pandas 准备就绪，开工 创建csv文件 csv文件属性Square_Feet，Price 记录文件所存储位置，调用的时候需要 在终端输入生成.mlmodel文件 导入需要的类 调用csv文件 coremltools转换成.mlmodel文件 author,license,description描述 输入Square_Feet，输出Price，保存 import coremltools from sklearn.linear_model import LinearRegression import pandas as pd data = pd.read_csv(‘/Users/sansi/Desktop/CoreMLModel/input_data.csv’) model = LinearRegression() model.fit(data[[“Square_Feet”]], data[“Price”]) coreml_model = coremltools.converters.sklearn.convert(model, “Square_Feet”, “Price”) coreml_model.author = ‘tongle’ coreml_model.license = ‘BSD’ coreml_model.short_description = ‘Predicts the price of a house in the Seattle area.’ coreml_model.input_description[‘Square_Feet’] = ‘Size (in square feet)’ coreml_model.output_description[‘Price’] = ‘Price of the house’ coreml_model.save(‘HousePricer.mlmodel’) 如果没有一点python功底，我都要死在电脑前了，哈哈]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS_CellAnimation]]]></title>
    <url>%2F2017%2F09%2F12%2FiOS-CellAnimation%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 最近在用cell动画，就研究修改了别人的cell动画，整理了一下。 使用：导入Animation类，直接用类调用,输入要动画的tableview和动画type，即可 [Animation addAnimationWithTableView:tableView andRow:self.type]; UITableViewCell 出场动画：简而明了的说就是利用cell的contentView来做一下出场动画animation CGFloat width = [[UIScreen mainScreen] bounds].size.width - 40; UIView *view = [[UIView alloc] initWithFrame:CGRectMake(20, 10, width, 60)]; view.backgroundColor = [UIColor redColor]; view.layer.masksToBounds = YES; view.layer.cornerRadius = 9.0; [cell.contentView addSubview:view]; UIViewmove动画 + (void)moveAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i < cells.count; i++) { CGFloat totalTime = 0.4; UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i]; cell.transform = CGAffineTransformMakeTranslation(-XS_SCREEN_WIDTH, 0); [UIView animateWithDuration:0.4 delay:i*(totalTime/cells.count) usingSpringWithDamping:0.7 initialSpringVelocity:1/0.7 options:UIViewAnimationOptionCurveEaseIn animations:^{ cell.transform = CGAffineTransformIdentity; } completion:^(BOOL finished) { }]; } } alpha动画 + (void)alphaAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i]; cell.alpha = 0.0; [UIView animateWithDuration:0.3 delay:i*0.05 options:0 animations:^{ cell.alpha = 1.0; } completion:^(BOOL finished) { }]; } } fall动画 + (void)fallAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; NSTimeInterval totalTime = 0.8; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i]; cell.transform = CGAffineTransformMakeTranslation(0, - XS_SCREEN_HEIGHT); [UIView animateWithDuration:0.3 delay:(cells.count - i)*(totalTime/cells.count) options:0 animations:^{ cell.transform = CGAffineTransformIdentity; } completion:^(BOOL finished) { }]; } } shake动画 + (void)shakeAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; if (i%2 == 0) { cell.transform = CGAffineTransformMakeTranslation(-XS_SCREEN_WIDTH,0); }else { cell.transform = CGAffineTransformMakeTranslation(XS_SCREEN_WIDTH,0); } [UIView animateWithDuration:0.4 delay:i*0.03 usingSpringWithDamping:0.75 initialSpringVelocity:1/0.75 options:0 animations:^{ cell.transform = CGAffineTransformIdentity; } completion:^(BOOL finished) { }]; } } overTurn动画 + (void)overTurnAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; cell.layer.opacity = 0.0; cell.layer.transform = CATransform3DMakeRotation(M_PI, 1, 0, 0); NSTimeInterval totalTime = 0.7; [UIView animateWithDuration:0.3 delay:i*(totalTime/cells.count) options:0 animations:^{ cell.layer.opacity = 1.0; cell.layer.transform = CATransform3DIdentity; } completion:^(BOOL finished) { }]; } } toTop动画 + (void)toTopAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; NSTimeInterval totalTime = 0.8; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [tableView.visibleCells objectAtIndex:i]; cell.transform = CGAffineTransformMakeTranslation(0, XS_SCREEN_HEIGHT); [UIView animateWithDuration:0.35 delay:i*(totalTime/cells.count) options:UIViewAnimationOptionCurveEaseOut animations:^{ cell.transform = CGAffineTransformIdentity; } completion:^(BOOL finished) { }]; } } spring动画 + (void)springListAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; cell.layer.opacity = 0.7; cell.layer.transform = CATransform3DMakeTranslation(0, -XS_SCREEN_HEIGHT, 20); NSTimeInterval totalTime = 1.0; [UIView animateWithDuration:0.4 delay:i*(totalTime/cells.count) usingSpringWithDamping:0.65 initialSpringVelocity:1/0.65 options:UIViewAnimationOptionCurveEaseIn animations:^{ cell.layer.opacity = 1.0; cell.layer.transform = CATransform3DMakeTranslation(0, 0, 20); } completion:^(BOOL finished) { }]; } } shrink动画 + (void)shrinkToTopAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; CGRect rect = [cell convertRect:cell.bounds fromView:tableView]; cell.transform = CGAffineTransformMakeTranslation(0, -rect.origin.y); [UIView animateWithDuration:0.5 animations:^{ cell.transform = CGAffineTransformIdentity; }]; } } laydown动画 + (void)layDownAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; NSMutableArray *rectArr = [[NSMutableArray alloc] init]; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; CGRect rect = cell.frame; [rectArr addObject:[NSValue valueWithCGRect:rect]]; rect.origin.y = i * 10; cell.frame = rect; cell.layer.transform = CATransform3DMakeTranslation(0, 0, i*5); } NSTimeInterval totalTime = 0.8; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; CGRect rect = [[rectArr objectAtIndex:i] CGRectValue]; [UIView animateWithDuration:(totalTime/cells.count) * i animations:^{ cell.frame = rect; } completion:^(BOOL finished) { cell.layer.transform = CATransform3DIdentity; }]; } } rote动画 + (void)roteAnimationWithTableView:(UITableView *)tableView { NSArray *cells = tableView.visibleCells; CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"transform.rotation.y"]; animation.fromValue = @(-M_PI); animation.toValue = 0; animation.duration = 0.3; animation.removedOnCompletion = NO; animation.repeatCount = 3; animation.fillMode = kCAFillModeForwards; animation.autoreverses = NO; for (int i = 0; i < cells.count; i++) { UITableViewCell *cell = [cells objectAtIndex:i]; cell.alpha = 0.0; [UIView animateWithDuration:0.1 delay:i*0.25 options:0 animations:^{ cell.alpha = 1.0; } completion:^(BOOL finished) { [cell.layer addAnimation:animation forKey:@"rotationYkey"]; }]; } }]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS-QRCodeImage]]]></title>
    <url>%2F2017%2F09%2F11%2FiOS-QRCodeImage%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 好几天没写博客了，正好在忙二维码的生成，扫描就里一个flag吧 原始二维码通过滤镜CIFilter生成二维码 创建过滤器 给过滤器添加数据 设置滤镜inputMessage数据 输出二维码 + (CIImage *)qrCodeImageWithContent:(NSString *)content{ CIFilter *qrFilter = [CIFilter filterWithName:@"CIQRCodeGenerator"]; NSData *contentData = [content dataUsingEncoding:NSUTF8StringEncoding]; [qrFilter setValue:contentData forKey:@"inputMessage"]; [qrFilter setValue:@"H" forKey:@"inputCorrectionLevel"]; CIImage *image = qrFilter.outputImage; return image; } void ProviderReleaseData (void *info, const void *data, size_t size){ free((void*)data); } 生成制定大小的二维码 传入原始二维码数据 设置倍数scale 通过bitmapImage放大并保存 + (UIImage *)qrCodeImageWithContent:(NSString *)content codeImageSize:(CGFloat)size{ CIImage *image = [self qrCodeImageWithContent:content]; CGRect integralRect = CGRectIntegral(image.extent); CGFloat scale = MIN(size/CGRectGetWidth(integralRect), size/CGRectGetHeight(integralRect)); size_t width = CGRectGetWidth(integralRect)*scale; size_t height = CGRectGetHeight(integralRect)*scale; CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceGray(); CGContextRef bitmapRef = CGBitmapContextCreate(nil, width, height, 8, 0, colorSpaceRef, (CGBitmapInfo)kCGImageAlphaNone); CIContext *context = [CIContext contextWithOptions:nil]; CGImageRef bitmapImage = [context createCGImage:image fromRect:integralRect]; CGContextSetInterpolationQuality(bitmapRef, kCGInterpolationNone); CGContextScaleCTM(bitmapRef, scale, scale); CGContextDrawImage(bitmapRef, integralRect, bitmapImage); CGImageRef scaledImage = CGBitmapContextCreateImage(bitmapRef); CGContextRelease(bitmapRef); CGImageRelease(bitmapImage); return [UIImage imageWithCGImage:scaledImage]; } 原始条形码通过滤镜CIFilter生成二维码 创建过滤器 给过滤器添加数据 设置滤镜inputMessage数据 输出二维码 + (CIImage *)barcodeImageWithContent:(NSString *)content{ CIFilter *qrFilter = [CIFilter filterWithName:@"CICode128BarcodeGenerator"]; NSData *contentData = [content dataUsingEncoding:NSUTF8StringEncoding]; [qrFilter setValue:contentData forKey:@"inputMessage"]; [qrFilter setValue:@(0.00) forKey:@"inputQuietSpace"]; CIImage *image = qrFilter.outputImage; return image; } void ProviderReleaseData (void *info, const void *data, size_t size){ free((void*)data); } 生成定制大小的条形码 传入原始二维码数据 设置倍数scale 通过bitmapImage放大并保存 + (UIImage *)barcodeImageWithContent:(NSString *)content codeImageSize:(CGSize)size{ CIImage *image = [self barcodeImageWithContent:content]; CGRect integralRect = CGRectIntegral(image.extent); CGFloat scale = MIN(size.width/CGRectGetWidth(integralRect), size.height/CGRectGetHeight(integralRect)); size_t width = CGRectGetWidth(integralRect)*scale; size_t height = CGRectGetHeight(integralRect)*scale; CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceGray(); CGContextRef bitmapRef = CGBitmapContextCreate(nil, width, height, 8, 0, colorSpaceRef, (CGBitmapInfo)kCGImageAlphaNone); CIContext *context = [CIContext contextWithOptions:nil]; CGImageRef bitmapImage = [context createCGImage:image fromRect:integralRect]; CGContextSetInterpolationQuality(bitmapRef, kCGInterpolationNone); CGContextScaleCTM(bitmapRef, scale, scale); CGContextDrawImage(bitmapRef, integralRect, bitmapImage); CGImageRef scaledImage = CGBitmapContextCreateImage(bitmapRef); CGContextRelease(bitmapRef); CGImageRelease(bitmapImage); return [UIImage imageWithCGImage:scaledImage]; } 彩色二维码获取原始二维码改变像素点颜色 @param content 二维码数据 @param size 二维码大小 @param red 0 ~ 1.0 @param green 0 ~ 1.0 @param blue 0 ~ 1.0 + (UIImage *)qrCodeImageWithContent:(NSString *)content codeImageSize:(CGFloat)size red:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue{ UIImage *image = [self qrCodeImageWithContent:content codeImageSize:size]; int imageWidth = image.size.width; int imageHeight = image.size.height; size_t bytesPerRow = imageWidth * 4; uint32_t *rgbImageBuf = (uint32_t *)malloc(bytesPerRow * imageHeight); CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB(); CGContextRef context = CGBitmapContextCreate(rgbImageBuf, imageWidth, imageHeight, 8, bytesPerRow, colorSpaceRef, kCGBitmapByteOrder32Little|kCGImageAlphaNoneSkipLast); CGContextDrawImage(context, CGRectMake(0, 0, imageWidth, imageHeight), image.CGImage); //遍历像素, 改变像素点颜色 int pixelNum = imageWidth * imageHeight; uint32_t *pCurPtr = rgbImageBuf; for (int i = 0; i< pixelNum; i++, pCurPtr++) { if ((*pCurPtr & 0xFFFFFF00) < 0x99999900) { uint8_t* ptr = (uint8_t*)pCurPtr; ptr[3] = red*255; ptr[2] = green*255; ptr[1] = blue*255; }else{ uint8_t* ptr = (uint8_t*)pCurPtr; ptr[0] = 0; } } //取出图片 CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, rgbImageBuf, bytesPerRow * imageHeight, ProviderReleaseData); CGImageRef imageRef = CGImageCreate(imageWidth, imageHeight, 8, 32, bytesPerRow, colorSpaceRef, kCGImageAlphaLast | kCGBitmapByteOrder32Little, dataProvider, NULL, true, kCGRenderingIntentDefault); CGDataProviderRelease(dataProvider); UIImage *resultImage = [UIImage imageWithCGImage:imageRef]; CGImageRelease(imageRef); CGContextRelease(context); CGColorSpaceRelease(colorSpaceRef); return resultImage; } 给二维码添加中心logo + (UIImage *)qrCodeImageWithContent:(NSString *)content codeImageSize:(CGFloat)size logo:(UIImage *)logo logoFrame:(CGRect)logoFrame red:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue{ UIImage * image = [self qrCodeImageWithContent:content codeImageSize:size red:red green:green blue:blue]; if (logo != nil) { UIGraphicsBeginImageContext(image.size); [image drawInRect:CGRectMake(0, 0, image.size.width, image.size.height)]; [logo drawInRect:logoFrame]; UIImage *resultImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return resultImage; }else{ return image; } } 彩色条形码获取原始二维码改变像素点颜色 @param content 二维码数据 @param size 二维码大小 @param red 0 ~ 1.0 @param green 0 ~ 1.0 @param blue 0 ~ 1.0 + (UIImage *)barcodeImageWithContent:(NSString *)content codeImageSize:(CGSize)size red:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue{ UIImage *image = [self barcodeImageWithContent:content codeImageSize:size]; int imageWidth = image.size.width; int imageHeight = image.size.height; size_t bytesPerRow = imageWidth * 4; uint32_t *rgbImageBuf = (uint32_t *)malloc(bytesPerRow * imageHeight); CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB(); CGContextRef context = CGBitmapContextCreate(rgbImageBuf, imageWidth, imageHeight, 8, bytesPerRow, colorSpaceRef, kCGBitmapByteOrder32Little|kCGImageAlphaNoneSkipLast); CGContextDrawImage(context, CGRectMake(0, 0, imageWidth, imageHeight), image.CGImage); //遍历像素, 改变像素点颜色 int pixelNum = imageWidth * imageHeight; uint32_t *pCurPtr = rgbImageBuf; for (int i = 0; i< pixelNum; i++, pCurPtr++) { if ((*pCurPtr & 0xFFFFFF00) < 0x99999900) { uint8_t* ptr = (uint8_t*)pCurPtr; ptr[3] = red*255; ptr[2] = green*255; ptr[1] = blue*255; }else{ uint8_t* ptr = (uint8_t*)pCurPtr; ptr[0] = 0; } } //取出图片 CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, rgbImageBuf, bytesPerRow * imageHeight, ProviderReleaseData); CGImageRef imageRef = CGImageCreate(imageWidth, imageHeight, 8, 32, bytesPerRow, colorSpaceRef, kCGImageAlphaLast | kCGBitmapByteOrder32Little, dataProvider, NULL, true, kCGRenderingIntentDefault); CGDataProviderRelease(dataProvider); UIImage *resultImage = [UIImage imageWithCGImage:imageRef]; CGImageRelease(imageRef); CGContextRelease(context); CGColorSpaceRelease(colorSpaceRef); return resultImage; } 渐变二维码绘制黑白二维码 - (UIImage *)genQRCodeImageMask:(UIImage *)image { if (image != nil) { int bitsPerComponent = 8; int bytesPerPixel = 4; int width = image.size.width; int height = image.size.height; unsigned char * imageData = (unsigned char *)malloc(width * height * bytesPerPixel); // 将原始黑白二维码图片绘制到像素格式为ARGB的图片上，绘制后的像素数据在imageData中。 CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGContextRef imageContext = CGBitmapContextCreate(imageData, width, height, bitsPerComponent, bytesPerPixel * width, colorSpace, kCGImageAlphaPremultipliedFirst); UIGraphicsPushContext(imageContext); CGContextTranslateCTM(imageContext, 0, height); CGContextScaleCTM(imageContext, 1, -1); [image drawInRect:CGRectMake(0, 0, width, height)]; CGColorSpaceRelease(colorSpace); // 根据每个像素R通道的值修改Alpha通道的值，当Red大于100，则将Alpha置为0，反之置为255 for (int row = 0; row < height; ++row) { for (int col = 0; col < width; ++col) { int offset = row * width * bytesPerPixel + col * bytesPerPixel; unsigned char r = imageData[offset + 1]; unsigned char alpha = r > 100 ? 0 : 255; imageData[offset] = alpha; } } CGImageRef cgMaskImage = CGBitmapContextCreateImage(imageContext); UIImage *maskImage = [UIImage imageWithCGImage:cgMaskImage]; CFRelease(cgMaskImage); UIGraphicsPopContext(); CFRelease(imageContext); free(imageData); return maskImage; } return nil; } 设置蒙层的颜色 - (CAGradientLayer *)gradientLayer { if (_gradientLayer == nil) { _gradientLayer = [CAGradientLayer new]; _gradientLayer.colors = @[ (__bridge id)[UIColor colorWithRed: 0x2a / 255.0 green:0x9c / 255.0 blue: 0x1f / 255.0 alpha:1.0].CGColor, (__bridge id)[UIColor colorWithRed: 0xe6 / 255.0 green:0xcd / 255.0 blue: 0x27 / 255.0 alpha:1.0].CGColor, (__bridge id)[UIColor colorWithRed: 0xe6 / 255.0 green:0x27 / 255.0 blue: 0x57 / 255.0 alpha:1.0].CGColor ]; [self.layer addSublayer: _gradientLayer]; _gradientLayer.frame = self.bounds; } return _gradientLayer; } 添加蒙层，设置黑白二维码图片 - (void)setQRCodeImage:(UIImage *)qrcodeImage { UIImage *maskImage = [self genQRCodeImageMask: qrcodeImage]; self.maskLayer.contents = (__bridge id)maskImage.CGImage; self.maskLayer.frame = self.bounds; self.gradientLayer.mask = self.maskLayer; }]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS物理动画引擎_UIDynamic]]]></title>
    <url>%2F2017%2F09%2F05%2FiOS%E7%89%A9%E7%90%86%E5%8A%A8%E7%94%BB%E5%BC%95%E6%93%8E-UIDynamic%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks.Dome: github地址 iOS物理动画引擎-UIDynamic UIDynamicBehavior 仿真行为 创建一个仿真者,用来仿真所有的物理行为 animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view] 2. 创建具体的物理仿真行为 gravity = [[UIGravityBehavior alloc]init] collision = [[UICollisionBehavior alloc]init] snapBehavior = [[UISnapBehavior alloc] init] itemBehavior = [[UIDynamicItemBehavior alloc] init] 3. 将物理仿真行为添加给仿真者实现仿真效果。 -(void)addBehavior:(UIDynamicBehavior *)behavior; -(void)removeBehavior:(UIDynamicBehavior *)behavior; -(void)removeAllBehaviors; UIGravityBehavior 重力行为 创建仿真者 self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view]; 创建仿真行为 -(UIGravityBehavior *)gravity{ if (_gravity == nil) { _gravity = [[UIGravityBehavior alloc]init]; } return _gravity; } -(UICollisionBehavior *)collision{ if (_collision == nil) { _collision = [[UICollisionBehavior alloc]init]; } return _collision; } 触碰屏幕生成重力小球 -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ UITouch * touch = touches.anyObject; CGPoint location = [touch locationInView:self.view]; self.redView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, widthRed, widthRed)]; self.redView.center = location; [self.view addSubview:self.redView]; // 随机色方块 self.redView.backgroundColor = randomColor; // 创建重力的物理仿真行为，并设置具体的items(需要仿真的view) [self.gravity addItem:self.redView]; // 下落方向 // [gravity setAngle:0.5]; // 创建弹性的物理仿真行为，并设置具体的items(需要仿真的view) [self.collision addItem:self.redView]; self.collision.translatesReferenceBoundsIntoBoundary = YES; // 将重力仿真行为添加给仿真者实现仿真效果，开始仿真 [self.animator addBehavior:self.gravity]; [self.animator addBehavior:self.collision]; } UICollisionBehavior 碰撞行为 创建仿真者 self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view]; 创建碰撞对象 self.greenView = [[UIView alloc] initWithFrame:CGRectMake(100, 200, 100, 30)]; self.greenView.backgroundColor = [UIColor greenColor]; [self.view addSubview:self.greenView]; self.blueView = [[UIView alloc] initWithFrame:CGRectMake(120, 300, 100, 30)]; self.blueView.backgroundColor = [UIColor blueColor]; [self.view addSubview:self.blueView]; //未绑定仿真对象 self.blackView = [[UIView alloc] initWithFrame:CGRectMake(140, 400, 100, 30)]; self.blackView.backgroundColor = [UIColor blackColor]; [self.view addSubview:self.blackView]; // 物体角度 self.blueView.transform = CGAffineTransformMakeRotation(M_PI_4); self.greenView.transform = CGAffineTransformMakeRotation(-M_PI / 8); 创建仿真行为 -(UIGravityBehavior *)gravity{ if (_gravity == nil) { _gravity = [[UIGravityBehavior alloc]init]; } return _gravity; } -(UICollisionBehavior *)collision{ if (_collision == nil) { _collision = [[UICollisionBehavior alloc]init]; } return _collision; } 开始碰撞行为 -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ // 获取点击位置，生成仿真者 UITouch * touch = touches.anyObject; CGPoint location = [touch locationInView:self.view]; self.redView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, widthRed, widthRed)]; self.redView.center = location; // pch中宏定义的随机色 self.redView.backgroundColor = randomColor; [self.view addSubview:self.redView]; [self.gravity addItem:self.redView]; // 添加碰撞检测 [self.collision addItem:self.redView]; [self.collision addItem:self.greenView]; [self.collision addItem:self.blueView]; self.collision.translatesReferenceBoundsIntoBoundary = YES; self.collision.collisionDelegate = self; __weak typeof(self) weakSelf = self; // 获取方块运动轨迹坐标 self.collision.action = ^{ NSLog(@"%@", NSStringFromCGRect(weakSelf.redView.frame)); }; CGFloat Y = self.view.frame.size.height; CGFloat X = self.view.frame.size.width; CGFloat height = self.view.frame.size.height; //设置红色的View为底边界,左边框跟右边框作为边界 [self.collision addBoundaryWithIdentifier:@"collision1" fromPoint:CGPointMake(0,Y) toPoint:CGPointMake(X, Y)]; [self.collision addBoundaryWithIdentifier:@"collision2" fromPoint:CGPointMake(0, 0) toPoint:CGPointMake(0, height)]; [self.collision addBoundaryWithIdentifier:@"collision3" fromPoint:CGPointMake(X,0) toPoint:CGPointMake(X, height)]; [self.animator addBehavior:self.collision]; [self.animator addBehavior:self.gravity]; } 碰撞开始时给被碰撞的物体添加重力仿真 // UICollisionBehavior 代理行为 - (void)collisionBehavior:(UICollisionBehavior*)behavior beganContactForItem:(id )item withBoundaryIdentifier:(nullable id )identifier atPoint:(CGPoint)p{ if ([item isEqual:self.greenView]) { UIGravityBehavior * gravity = [[UIGravityBehavior alloc] initWithItems:@[self.greenView]]; [self.animator addBehavior:gravity]; }else if ([item isEqual:self.blueView]){ UIGravityBehavior * gravity = [[UIGravityBehavior alloc] initWithItems:@[self.blueView]]; [self.animator addBehavior:gravity]; } } UISnapBehavior 吸附行为 创建仿真者 self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view]; 创建吸附对象 -(UIView *)redView{ if (_redView ==nil) { _redView = [[UIView alloc]initWithFrame:CGRectMake(p.x, p.y, 50, 50)]; _redView.backgroundColor = [UIColor redColor]; [self.view addSubview:_redView]; } return _redView; } 开始吸附行为 -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ [self.animator removeAllBehaviors]; UITouch * touch = touches.anyObject; CGPoint location = [touch locationInView:self.view]; p = location; NSLog(@"%@",NSStringFromCGPoint(location)); // 3 添加吸附事件 UISnapBehavior *snap = [[UISnapBehavior alloc] initWithItem:self.redView snapToPoint:location]; // 改变震动幅度，0表示振幅最大，1振幅最小 snap.damping = 0.5; // 4. 将吸附事件添加到仿真者行为中 [self.animator addBehavior:snap]; } UIDynamicItemBehavior 迅猛移动弹跳摆动行为 创建仿真者 self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view]; 创建仿真行为 -(UIGravityBehavior *)gravity{ if (_gravity == nil) { _gravity = [[UIGravityBehavior alloc]init]; } return _gravity; } -(UICollisionBehavior *)collision{ if (_collision == nil) { _collision = [[UICollisionBehavior alloc]init]; [_collision addBoundaryWithIdentifier:@"barrier" forPath:[UIBezierPath bezierPathWithRect:self.view.bounds]]; _collision.translatesReferenceBoundsIntoBoundary = YES; } return _collision; } -(UIDynamicItemBehavior *)itemBehavior{ if (_itemBehavior == nil) { _itemBehavior = [[UIDynamicItemBehavior alloc] init]; _itemBehavior.elasticity = 1; } return _itemBehavior; } 生成小球，添加仿真事件 -(void)touchesAddSquareView{ float viewWidth = 20; UIView * view = [[UIView alloc]initWithFrame:CGRectMake(p.x, p.y, viewWidth, viewWidth)]; view.layer.cornerRadius = viewWidth / 2.0; view.backgroundColor = randomColor; [self performSelector:@selector(removeView:) withObject:view afterDelay:10]; [self.view addSubview:view]; [self.collision addItem:view]; [self.itemBehavior addItem:view]; [self.gravity addItem:view]; [self.animator addBehavior:self.collision]; [self.animator addBehavior:self.itemBehavior]; [self.animator addBehavior:self.gravity]; } 点触，移动和松开创建小球 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { UITouch * touch = touches.anyObject; CGPoint location = [touch locationInView:self.view]; p = location; [self touchesAddSquareView]; } - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event { UITouch * touch = touches.anyObject; CGPoint location = [touch locationInView:self.view]; p = location; [self touchesAddSquareView]; } - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event { [self touchesAddSquareView]; } 10s后删除小球和其物理仿真行为 -(void)removeView:(UIView *)view{ if (view == nil) { return; } [UIView animateWithDuration:.5 animations:^{ view.alpha = 0; } completion:^(BOOL finished) { [view removeFromSuperview]; [self.collision removeItem:view]; [self.itemBehavior removeItem:view]; [self.gravity removeItem:view]; }]; }]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift_popAnimation实例]]]></title>
    <url>%2F2017%2F08%2F28%2FSwift-popAnimation%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 情人节在写博客也是蛮拼的 Pod pop 如 [Swift_popAnimation初级] 动画思路 三条杠变叉：中间杠的消失和两边杠的偏移。 叉变三条杠：两边杠的偏移和中间杠的出现。 三条杠用三个view来代替，添加在一个button上。声明全局属性 var hamburger = true var hamburgerButton : UIButton? var top:UIView? var middle:UIView? var bottom:UIView? 实例化对象 self.hamburgerButton = UIButton() self.hamburgerButton?.backgroundColor = UIColor.black self.hamburgerButton?.frame = CGRect(x: 100, y: 200, width: 150, height: 150) self.hamburgerButton?.layer.cornerRadius = 75 self.view.addSubview(hamburgerButton!) self.hamburgerButton?.addTarget(self, action:#selector(didTapHamburgerButton), for: UIControlEvents.touchUpInside) //三道杠 let sectionWidth:CGFloat = 80.0 let sectionHeight:CGFloat = 11.0 //top top = UIView(frame: CGRect(x: (self.hamburgerButton?.bounds.size.width)! / 2 - sectionWidth / 2, y: 40, width: sectionWidth, height: sectionHeight)) top?.backgroundColor = UIColor.white top?.isUserInteractionEnabled = false top?.layer.cornerRadius = sectionHeight / 2 self.hamburgerButton?.addSubview(top!) //middle middle = UIView(frame: CGRect(x: (self.hamburgerButton?.bounds.size.width)! / 2 - sectionWidth / 2, y: 69, width: sectionWidth, height: sectionHeight)) middle?.backgroundColor = UIColor.white middle?.isUserInteractionEnabled = false middle?.layer.cornerRadius = sectionHeight / 2 self.hamburgerButton?.addSubview(middle!) //bottom bottom = UIView(frame: CGRect(x: (self.hamburgerButton?.bounds.size.width)! / 2 - sectionWidth / 2, y: 99, width: sectionWidth, height: sectionHeight)) bottom?.backgroundColor = UIColor.white bottom?.isUserInteractionEnabled = false bottom?.layer.cornerRadius = sectionHeight / 2 self.hamburgerButton?.addSubview(bottom!) pop对象复用 颜色动画： var topColor = self.top?.pop_animation(forKey: "topColor") as! POPSpringAnimation? var bottomColor = self.top?.pop_animation(forKey: "bottomColor") as! POPSpringAnimation? 旋转动画： var topRotate = self.top?.layer.pop_animation(forKey: "topRotate") as! POPSpringAnimation? var bottomRotate = self.top?.layer.pop_animation(forKey: "bottomRotate") as! POPSpringAnimation? 位置动画： var topPosition = self.top?.layer.pop_animation(forKey: "topPosition")as!POPSpringAnimation? var bottomPosition = self.top?.layer.pop_animation(forKey: "bottomPosition")as!POPSpringAnimation? 三道杠变红叉叉 hamburger = false UIView.animate(withDuration: 0.2, animations: { self.middle?.alpha = 0 }) //变色 if topColor != nil { topColor?.toValue = UIColor.red }else{ topColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor) topColor?.toValue = UIColor.red topColor?.springBounciness = 0 topColor?.springSpeed = 18 top?.pop_add(topColor, forKey: "topColor") } if bottomColor != nil { bottomColor?.toValue = UIColor.red }else{ bottomColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor) bottomColor?.toValue = UIColor.red bottomColor?.springBounciness = 0 bottomColor?.springSpeed = 18 bottom?.pop_add(topColor, forKey: "bottomColor") } //旋转 if topRotate != nil { topRotate?.toValue = -Double.pi / 4 }else{ topRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation) topRotate?.toValue = -Double.pi / 4 topRotate?.springBounciness = 11 topRotate?.springSpeed = 18 top?.layer.pop_add(topRotate, forKey: "topRotate") } if bottomRotate != nil { bottomRotate?.toValue = Double.pi / 4 }else{ bottomRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation) bottomRotate?.toValue = Double.pi / 4 bottomRotate?.springBounciness = 11 bottomRotate?.springSpeed = 18 bottom?.layer.pop_add(bottomRotate, forKey: "bottomRotate") } //移动 if topPosition != nil { topPosition?.toValue = 29 }else{ topPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY) topPosition?.toValue = 29 topPosition?.springBounciness = 11 topPosition?.springSpeed = 18 top?.layer.pop_add(topPosition, forKey: "topPosition") } if bottomPosition != nil { bottomPosition?.toValue = -29 }else{ bottomPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY) bottomPosition?.toValue = -29 bottomPosition?.springBounciness = 11 bottomPosition?.springSpeed = 18 bottom?.layer.pop_add(bottomPosition, forKey: "bottomPosition") } } 红叉叉变三道杠:逆向-&gt;就还原一起改变值 hamburger = true UIView.animate(withDuration: 0.2, animations: { self.middle?.alpha = 1 }) //变色 if topColor != nil { topColor?.toValue = UIColor.white }else{ topColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor) topColor?.toValue = UIColor.white topColor?.springBounciness = 0 topColor?.springSpeed = 18 top?.pop_add(topColor, forKey: "topColor") } if bottomColor != nil { bottomColor?.toValue = UIColor.white }else{ bottomColor = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor) bottomColor?.toValue = UIColor.white bottomColor?.springBounciness = 0 bottomColor?.springSpeed = 18 bottom?.pop_add(topColor, forKey: "bottomColor") } //旋转 if topRotate != nil { topRotate?.toValue = 0 }else{ topRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation) topRotate?.toValue = 0 topRotate?.springBounciness = 11 topRotate?.springSpeed = 18 top?.layer.pop_add(topRotate, forKey: "topRotate") } if bottomRotate != nil { bottomRotate?.toValue = 0 }else{ bottomRotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation) bottomRotate?.toValue = 0 bottomRotate?.springBounciness = 11 bottomRotate?.springSpeed = 18 bottom?.layer.pop_add(bottomRotate, forKey: "bottomRotate") } //移动 if topPosition != nil { topPosition?.toValue = 0 }else{ topPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY) topPosition?.toValue = 0 topPosition?.springBounciness = 11 topPosition?.springSpeed = 18 top?.layer.pop_add(topPosition, forKey: "topPosition") } if bottomPosition != nil { bottomPosition?.toValue = 0 }else{ bottomPosition = POPSpringAnimation(propertyNamed: kPOPLayerTranslationY) bottomPosition?.toValue = 0 bottomPosition?.springBounciness = 11 bottomPosition?.springSpeed = 18 bottom?.layer.pop_add(bottomPosition, forKey: "bottomPosition") } } } so easy]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift_popAnimation应用]]]></title>
    <url>%2F2017%2F08%2F25%2FSwift-popAnimation%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 Pod pop如上篇文章 创建UIbutton类对象与storyboard绑定 应用touchesBegan ，touchesEnded 开始点击 缩小0.5倍 旋转半圈 //缩放动画 var scale = self.pop_animation(forKey: TLscale)as?POPSpringAnimation if scale != nil { scale?.toValue = NSValue(cgPoint:CGPoint(x: 0.5, y: 0.5)) }else{ scale = POPSpringAnimation(propertyNamed: kPOPViewScaleXY) scale?.toValue = NSValue(cgPoint:CGPoint(x: 0.5, y: 0.5)) scale?.springBounciness = 20 scale?.springSpeed = 5 self.pop_add(scale, forKey: TLscale) } //旋转动画 var rotate = self.layer.pop_animation(forKey: TLrotate)as? POPSpringAnimation if rotate != nil { rotate?.toValue = Double.pi / 2 }else{ rotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation) rotate?.toValue = Double.pi / 2 rotate?.springBounciness = 20 rotate?.springSpeed = 18 self.layer.pop_add(rotate, forKey: TLrotate) } 结束点击 缩放1.0倍回到起始状态 旋转到起始位置 //缩放动画 var scale = self.pop_animation(forKey: TLscale)as?POPSpringAnimation if scale != nil { scale?.toValue = NSValue(cgPoint:CGPoint(x: 1, y: 1)) }else{ scale = POPSpringAnimation(propertyNamed: kPOPViewScaleXY) scale?.toValue = NSValue(cgPoint:CGPoint(x: 1, y: 1)) scale?.springBounciness = 20 scale?.springSpeed = 5 self.pop_add(scale, forKey: TLscale) } //旋转动画 var rotate = self.layer.pop_animation(forKey: TLrotate)as? POPSpringAnimation if rotate != nil { rotate?.toValue = 0 }else{ rotate = POPSpringAnimation(propertyNamed: kPOPLayerRotation) rotate?.toValue = 0 rotate?.springBounciness = 20 rotate?.springSpeed = 18 self.layer.pop_add(rotate, forKey: TLrotate)]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift_popAnimation初级]]]></title>
    <url>%2F2017%2F08%2F25%2FpopAnimation%E5%88%9D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 先初尝popAnimation一些环境配置和方法调用，下篇会写实例应用 Pods pop vim podfile platform :ios,'8.0' target "RedBall" do pod 'pop' end pod install 动画 宏定义 let TLspin = "spin" let TLmove = "move" let TLcolor = "color" let TLscale = "scale" 属性定义 let redBall = UIView(frame: CGRect(x: 100, y: 200, width: 100, height: 100)) let scale = POPSpringAnimation(propertyNamed:kPOPViewScaleXY) let move = POPSpringAnimation(propertyNamed: kPOPLayerPositionY) let spin = POPSpringAnimation(propertyNamed: kPOPLayerRotation) let color = POPSpringAnimation(propertyNamed: kPOPViewBackgroundColor) segmentContol创建 let array = [&quot;放大&quot;,&quot;旋转&quot;,&quot;移动&quot;,&quot;变色&quot;,&quot;归位&quot;] let segmentedControl = UISegmentedControl.init(items:array) segmentedControl.frame = CGRect(x:50,y:50,width:self.view.frame.size.width-100 ,height:30) segmentedControl.tintColor = UIColor.green segmentedControl.backgroundColor = UIColor.red segmentedControl.addTarget(self, action:#selector(segmentedControlChanged(segmented:)), for: UIControlEvents.valueChanged) self.view .addSubview(segmentedControl); 动画代码 pop放大，旋转，移动，变色，还原动画 springBounciness: 弹性振幅，范围0-20 springSpeed: 震动速度 pop_add: 加载动画 func redBallScale() { // 放大动画 scale?.toValue = NSValue(cgPoint:CGPoint(x: 2, y: 2)) scale?.springBounciness = 20 scale?.springSpeed = 1 redBall.pop_add(scale, forKey: TLscale) } func redBallSpin() { //旋转动画 spin?.toValue = Double.pi * 4 spin?.springBounciness = 20 spin?.springSpeed = 5 redBall.layer.pop_add(spin, forKey: TLspin) } func redBallMove() { //y坐标位移动画 move?.toValue = 500 move?.springBounciness = 20 move?.springSpeed = 5 redBall.layer.pop_add(move, forKey: TLmove) } func redBallColor() { //背景颜色变化 color?.toValue = UIColor.green color?.springBounciness = 20 color?.springSpeed = 5 redBall.pop_add(color, forKey: TLcolor) }]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS-绑定Amazon]]]></title>
    <url>%2F2017%2F08%2F23%2FiOS-%E7%BB%91%E5%AE%9AAmazon%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github地址 为实现echo语音控制只能家居，所以需要绑定亚马逊账号 Install the Login with Amazon SDK for iOS 下载亚马逊SDK LoginWithAmazonSDKForiOS.zip 工程中拖入SDK LoginWithAmazon.framework Target - BuildPhases - Link Binary With Libraries中添加framework Register with Login with Amazon注册亚马逊账号亚马逊注册 登录亚马逊账号亚马逊登录 输入App的名称，链接和App图标等 注册地址 App Console.前提是你有亚马逊账号 Add iOS Settings to an Application 亚马逊 App应用界面，点击iOS设置，如果你的iOS App已经注册好，点击 API Key 需要输入你的Bundle ID,target - General Add Your API Key to Your App Property List 选择 project - Info.plist 添加APIKey ，选择copy，别出错 Add a URL Scheme to Your App Property List 选择 project - Info.plist 添加URL types Item 0 Document Role 填写Editor。 Shames 填写 prefs Item 1 identifier 填写bundle ID。 Shames 填写amzn-bundle ID 其他填写如下图 Using the SDK for iOS APIs创建亚马逊类，导入 #import&lt; LoginWithAmazon/LoginWithAmazon.h&gt; Using the SDK for iOS APIs 在 AppDelegate 导入import &lt; LoginWithAmazon/LoginWithAmazon.h&gt;. 添加以下方法,返回亚马逊URL - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation { #pragma unused(application,annotation) // Pass on the url to the SDK to parse authorization code from the url. BOOL isValidRedirectLogInURL = [AMZNAuthorizationManager handleOpenURL:url sourceApplication:(NSString *)sourceApplication]; if(!isValidRedirectLogInURL){ return NO; } // App may also want to handle url return YES; } Handle the Login Button and Get Profile Data 发出登录请求 userID ，profile，postalCode successful 成功登录返回数据result.token，result.user，user.userID error 回复错误 userDidCancel 用户自动取消 - (IBAction)onLogInButtonClicked:(id)sender { // Build an authorize request. AMZNAuthorizeRequest *request = [[AMZNAuthorizeRequest alloc] init]; request.scopes = [NSArray arrayWithObjects: [AMZNProfileScope userID], [AMZNProfileScope profile], [AMZNProfileScope postalCode]]; // Make an Authorize call to the Login with Amazon SDK. [[AMZNAuthorizationManager sharedManager] authorize:request withHandler:^(AMZNAuthorizeResult *result, BOOL userDidCancel, NSError *error) { if (error) { // Handle errors from the SDK or authorization server. } else if (userDidCancel) { // Handle errors caused when user cancels login. } else { // Authentication was successful. // Obtain the access token and user profile data. NSString *accessToken = result.token; AMZNUser *user = result.user; NSString *userID = user.userID; } }]; } Fetch User Profile Data 获取登录信息 user.userID，user.name，user.email，user.postalCode 在error时可以添加重新登录方法 AMZNUser fetch:^(AMZNUser *user, NSError *error) { if (error) { // Error from the SDK, or no user has authorized to the app. } else if (user) { NSString *userID = user.userID; //NSString *name = user.name; //NSString *email = user.email; //NSString *postalCode = user.postalCode; } }]; Check for User Login at Startup // Build an authorize request. AMZNAuthorizeRequest *request = [[AMZNAuthorizeRequest alloc] init]; request.scopes = [NSArray arrayWithObjects: // [AMZNProfileScope userID], [AMZNProfileScope profile], [AMZNProfileScope postalCode]]; request.interactiveStrategy = AMZNInteractiveStrategyNever; [[AMZNAuthorizationManager sharedManager] authorize:request withHandler:^(AMZNAuthorizeResult *result, BOOL userDidCancel, NSError *error) { if (error) { // Error from the SDK, indicating the user was not previously authorized to your app for the requested scopes. } else { // The user was previously authorized to your app. // Obtain the access token and user profile data. NSString *accessToken = result.token; AMZNUser *user = result.user; NSString *userID = user.userID; } }]; Clear Authorization Data and Log Out a User 退出登录 清除亚马逊数据 [[AMZNAuthorizationManager sharedManager] signOut:^(NSError * _Nullable error) { if (!error) { // error from the SDK or Login with Amazon authorization server. } }]; 注：亚马逊账号绑定在本地存储，所以多手机登录需要存储userID到自己服务器，实现多手机登录状态回显]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS-OpenGL图形绘制二]]]></title>
    <url>%2F2017%2F08%2F23%2FiOS-OpenGL%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks.Dome: github地址 本章讲如何用原生OpenGL绘制图形及渲染图片 环境搭建 创建一个新的工程，点击target-&gt;Build Phases -&gt; Link Binary With Libraries添加库 GLKit.framework OpenGLES.framework 导入头文件: #import &lt; OpenGLES/ES2/gl.h &gt; #import &lt; OpenGLES/ES2/glext.h &gt; 三角形宏定义一个三角线 const GLfloat Trianglevertices[] = { 0.0f, 0.5f, 0.0f, -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f }; const GLubyte Triangleindices[] = { 0,1,2 }; VBO申请空间并绑定目标-(void)OneRenderVerticesAnColorsForTriangles{ GLuint vertexBuffer; glGenBuffers(1, &amp;vertexBuffer); // 绑定vertexBuffer到GL_ARRAY_BUFFER目标 glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer); // 为VBO申请空间，初始化并传递数据 glBufferData(GL_ARRAY_BUFFER, sizeof(Trianglevertices), Trianglevertices, GL_STATIC_DRAW); GLuint indexBuffer; glGenBuffers(1, &amp;indexBuffer); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Triangleindices), Triangleindices, GL_STATIC_DRAW); // 使用VBO时，最后一个参数0为要获取参数在GL_ARRAY_BUFFER中的偏移量 glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(_positionSlot); glDrawElements(GL_TRIANGLES, sizeof(Triangleindices)/sizeof(Triangleindices[0]), GL_UNSIGNED_BYTE, 0); } 四边形宏定义定义一个Vertex结构, 其中包含了坐标和颜色 typedef struct { float Position[3]; float Color[4]; } Vertex; 顶点数组 const Vertex Vertices[] = { {{-1,-1,0}, {0,0,0,1}},// 左下，黑色 {{1,-1,0}, {1,0,0,1}}, // 右下，红色 {{-1,1,0}, {0,0,1,1}}, // 左上，蓝色 {{1,1,0}, {0,1,0,1}}, // 右上，绿色 }; 索引数组 const GLubyte Indices[] = { 0,1,2, // 三角形0 1,2,3 // 三角形1 }; VBO申请空间并绑定目标 取出Vertices数组中的坐标点值，赋给_positionSlot 取出Colors数组中的每个坐标点的颜色值，赋给_colorSlot 绘制两个三角形，不复用顶点，因此需要6个顶点坐标。 V0-V1-V2, V3-V4-V5 通用部分定义属性EAGLContext * _context; CAEAGLLayer * _EALayer; GLuint _colorBufferRender; // 渲染缓冲区 GLuint _frameBuffer; // 帧缓冲区 GLuint _positionSlot; // 用于绑定shader中的Position参数 GLuint _colorSlot; // 用于绑定shader中的SourceColor参数 GLuint _glProgram; 颜色和离屏渲染 生成一个renderBuffer，id是_colorRenderBuffer 设置为当前renderBuffer 为color renderbuffer 分配存储空间 FBO用于管理colorRenderBuffer，离屏渲染 设置为当前framebuffer 将 _colorRenderBuffer 装配到 GL_COLOR_ATTACHMENT0 这个装配点上 -(void)setColorAndFrameBufferRender{ if (_colorBufferRender) { glDeleteRenderbuffers(1, &amp;_colorBufferRender); _colorBufferRender = 0; } if (_frameBuffer) { glDeleteFramebuffers(1, &amp;_frameBuffer); _frameBuffer = 0; } glGenRenderbuffers(1, &amp;_colorBufferRender); glBindRenderbuffer(GL_RENDERBUFFER, _colorBufferRender); [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:_EALayer]; glGenFramebuffers(1, &amp;_frameBuffer); glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer); glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _colorBufferRender); } 创建绘制对象 setup context, 渲染上下文，管理所有绘制的状态，命令及资源信息。 setup layer, 必须要是CAEAGLLayer才行，才能在其上描绘OpenGL内容 如果在viewController中，使用[self.view.layer addSublayer:eaglLayer]; 如果在view中，可以直接重写UIView的layerClass类方法即可return [CAEAGLLayer class]。 - (void)setContentViewAndCAEGLayer{ _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2]; [EAGLContext setCurrentContext:_context]; _EALayer = (CAEAGLLayer*)self.view.layer; _EALayer.frame = self.view.frame; _EALayer.opaque = YES; _EALayer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithBool:YES],kEAGLDrawablePropertyRetainedBacking,kEAGLColorFormatRGBA8,kEAGLDrawablePropertyColorFormat, nil]; } 设置清屏 设置清屏颜色 用来指定要用清屏颜色来清除由mask指定的buffer，此处是color buffer 将指定renderBuffer渲染在屏幕上 -(void)glClear{ glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); glViewport(0, 0, self.view.frame.size.width , self.view.frame.size.height); } 离屏渲染显示绘制图片创建glsl文件：建一个empty文件，修改后缀即可三角形Fragment precision mediump float; void main(void) { gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); } 三角形Vertex attribute vec4 Position; void main(void) { gl_Position = Position; } 四边形Fragment varying lowp vec4 DestinationColor; void main(void) { gl_FragColor = DestinationColor; } 四边形Vertex attribute vec4 Position; attribute vec4 SourceColor; varying vec4 DestinationColor; void main(void) { DestinationColor = SourceColor; gl_Position = Position; } 创建一个分类继承NSObject实现以下两个类方法 + (GLuint)compileShader:(NSString*)shaderName withType:(GLenum)shaderType; + (GLuint)compileShaders:(NSString *)shaderVertex shaderFragment:(NSString *)shaderFragment; Shader四边形Shaders - (void)processShaders { _glProgram = [TLShaderOperation compileShaders:@&quot;Vertex&quot; shaderFragment:@&quot;Fragment&quot;]; glUseProgram(_glProgram); _positionSlot = glGetAttribLocation(_glProgram, &quot;Position&quot;); _colorSlot = glGetAttribLocation(_glProgram, &quot;SourceColor&quot;); } 三角形Shaders - (void)processTriangleShaders { // 编译shaders _glProgram = [TLShaderOperation compileShaders:@&quot;TriangleVertex&quot; shaderFragment:@&quot;TriangleFragment&quot;]; glUseProgram(_glProgram); // 获取指向vertex shader传入变量的指针, 然后就通过该指针来使用 // 即将_positionSlot 与 shader中的Position参数绑定起来 glGetAttribLocation(_glProgram, &quot;Position&quot;); } 获取图片 unbind the shader 从FBO中读取图像数据，离屏渲染。 图像经过render之后，已经在FBO中了，即使不将其拿到RenderBuffer中，依然可以使用getResultImage取到图像数据。 用[_eaglContext presentRenderbuffer:GL_RENDERBUFFER];，实际上就是将FBO中的图像拿到RenderBuffer中（即屏幕上） - (UIImage *)getResultImage { CGSize currentFBOSize = self.view.frame.size; NSUInteger totalBytesForImage = (int)currentFBOSize.width * (int)currentFBOSize.height * 4; GLubyte *_rawImagePixelsTemp = (GLubyte *)malloc(totalBytesForImage); glReadPixels(0, 0, (int)currentFBOSize.width, (int)currentFBOSize.height, GL_RGBA, GL_UNSIGNED_BYTE, _rawImagePixelsTemp); glUseProgram(0); glBindFramebuffer(GL_FRAMEBUFFER, 0); CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, _rawImagePixelsTemp, totalBytesForImage, (CGDataProviderReleaseDataCallback)&freeData); CGColorSpaceRef defaultRGBColorSpace = CGColorSpaceCreateDeviceRGB(); CGImageRef cgImageFromBytes = CGImageCreate((int)currentFBOSize.width, (int)currentFBOSize.height, 8, 32, 4 * (int)currentFBOSize.width, defaultRGBColorSpace, kCGBitmapByteOrderDefault, dataProvider, NULL, NO, kCGRenderingIntentDefault); UIImage *finalImage = [UIImage imageWithCGImage:cgImageFromBytes scale:1.0 orientation:UIImageOrientationDownMirrored]; CGImageRelease(cgImageFromBytes); CGDataProviderRelease(dataProvider); CGColorSpaceRelease(defaultRGBColorSpace); return finalImage; } void freeData(void *info, const void *data, size_t size) { free((unsigned char *)data); } 用于显示图片UIImage *image = [self getResultImage]; if (image) { UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)]; imageView.backgroundColor = [UIColor whiteColor]; imageView.contentMode = UIViewContentModeScaleAspectFit; imageView.image = image; [self.view addSubview:imageView]; }]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS_OpenGL环境搭建和图形绘制]]]></title>
    <url>%2F2017%2F08%2F22%2FiOS-OpenGL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks.Dome: github地址 个人觉得OpenGl图形绘制很酷所以专研了一段时间，记录供以后自己使用和小白学习。 环境搭建 创建一个新的工程，点击target-&gt;Build Phases -&gt; Link Binary With Libraries添加库 GLKit.framework OpenGLES.framework 导入 #import 头文件 因为我用GLKBaseEffect绘制的，所以不需要导入更多的头文件 顶点输入一个顶点数组对象会储存以下这些内容： glEnableVertexAttribArray和glDisableVertexAttribArray的调用。 通过glVertexAttribPointer设置的顶点属性配置。 通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。 三角形 float vertices[] = { -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f }; 多边形 typedef struct { GLfloat Positon[3];//位置 GLfloat Color[4];//颜色 } Vertex; 顶点和颜色数组 const Vertex squareVertexData[] = { { 0.5f, 0.5f, -0.9f, 1.0f, 0.0f, 0.0f, 1.0f}, //0 {-0.5f, 0.5f, -0.9f, 0.0f, 1.0f, 0.0f, 1.0f}, //1 { 0.5f, -0.5f, -0.9f, 0.0f, 0.0f, 1.0f, 1.0f}, //2 {-0.5f, -0.5f, -0.9f, 0.0f, 0.0f, 0.0f, 1.0f} //3 }; 三角形数组 const GLubyte Indices[] = { 0, 1, 2, 2, 1, 3 }; 顶点数组对象：Vertex Array Object，VBO 使用glGenBuffers函数和一个缓冲ID生成一个VBO对象：unsigned int VBO;glGenBuffers(1, &amp;VBO); glBindBuffer函数把新创建的缓冲绑定到GL_ARRAY_BUFFER目标上：glBindBuffer(GL_ARRAY_BUFFER, VBO); 我们可以调用glBufferData函数，它会把之前定义的顶点数据复制到缓冲的内存中：glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);glBufferData： 它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上 第二个参数指定传输数据的大小(以字节为单位)；用一个简单的sizeof计算出顶点数据大小就行 第三个参数是我们希望发送的实际数据。 第四个参数指定了我们希望显卡如何管理给定的数据 GL_STATIC_DRAW ：数据不会或几乎不会改变。 GL_DYNAMIC_DRAW：数据会被改变很多。 GL_STREAM_DRAW ：数据每次绘制时都会改变。 现在我们已经把顶点数据储存在显卡的内存中，用VBO这个顶点缓冲对象管理 创建一个VAO和创建一个VBO很类似：unsigned int VAO;glGenVertexArrays(1, &amp;VAO); 要想使用VAO，要做的只是使用glBindVertexArray绑定VAO 绑定VAOglBindVertexArray(VAO); 把顶点数组复制到缓冲中供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); 设置顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 sizeof(float), (void)0);glEnableVertexAttribArray(0); 三角形 GL_ARRAY_BUFFER用于顶点数组 绑定vertexBuffer到GL_ARRAY_BUFFER 给VBO传递数据 取出地址 取出颜色 glVertexAttribPointer的最后一个参数是要获取的参数在GL_ARRAY_BUFFER（每一个Vertex）的偏移量 - (void)setupVBOs{ GLuint verticesBuffer; glGenBuffers(1, &verticesBuffer); glBindBuffer(GL_ARRAY_BUFFER, verticesBuffer); glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW); glEnableVertexAttribArray(GLKVertexAttribPosition); glEnableVertexAttribArray(GLKVertexAttribColor); glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 6, (GLfloat *)NULL + 0); glVertexAttribPointer(GLKVertexAttribColor, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 6, (GLfloat *)NULL + 3); } 多边形 申请一个标识符 把标识符绑定到GL_ARRAY_BUFFER上 把顶点数据从cpu内存复制到gpu内存 开启对应的顶点属性 设置合适的格式从buffer里面读取数据 - (void)setupVBOs{ GLuint buffer; glGenBuffers(1, &buffer); glBindBuffer(GL_ARRAY_BUFFER, buffer); glBufferData(GL_ARRAY_BUFFER, sizeof(squareVertexData), squareVertexData, GL_STATIC_DRAW); GLuint elementBuffer; glGenBuffers(1, &elementBuffer); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBuffer); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW); glEnableVertexAttribArray(GLKVertexAttribPosition); glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), 0); glEnableVertexAttribArray(GLKVertexAttribNormal); glVertexAttribPointer(GLKVertexAttribNormal, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid *) (sizeof(GLfloat) * 3)); glEnableVertexAttribArray(GLKVertexAttribColor); glVertexAttribPointer(GLKVertexAttribColor, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid *) (sizeof(GLfloat) * 6)); glEnableVertexAttribArray(GLKVertexAttribTexCoord0); glVertexAttribPointer(GLKVertexAttribTexCoord0, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid *) (sizeof(GLfloat) * 10)); } GLKViewDelegate 启动着色器 添加背景颜色 绘制图形 -(void)glkView:(GLKView *)view drawInRect:(CGRect)rect { [TLEffect prepareToDraw]; glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glDrawArrays(GL_TRIANGLES, 0, 3); } 在GLKView上绘制OpenGL内容 - (void)setupContext{ context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2]; if (!context) { NSLog(@"Failed to initialize OpenGLES 2.0 context"); exit(1); } [EAGLContext setCurrentContext:context]; GLKView *view = [[GLKView alloc]init]; view.delegate = self; view.frame = self.view.frame; view.context = context; view.drawableColorFormat = GLKViewDrawableColorFormatRGBA8888; if (![EAGLContext setCurrentContext:context]) { NSLog(@"Failed to set current OpenGL context"); exit(1); } [self.view addSubview:view]; }]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS_定时器动画的使用]]]></title>
    <url>%2F2017%2F08%2F18%2F%E5%AE%9A%E6%97%B6%E5%99%A8timer%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github 地址 项目中智能灯有个定时开关的功能，需要在界面上实现时间选择，动画走动然后就写了这个功能实现倒计时 实现准备时间数组： 1. hourArray 存放小时的数组 2. minuteArray 存放分钟的数组 _hourArray = [NSMutableArray array]; for (int i = 0; i < 24; i ++) { [_hourArray addObject:[NSString stringWithFormat:@"%d",i]]; } _minuteArray = [NSMutableArray array]; for (int i = 1; i < 60; i ++) { [_minuteArray addObject:[NSString stringWithFormat:@"%d",i]]; } 宏定义： #define WIN_WIDTH [self.view.bounds.size.width] #define WIN_HEIGHT [self.view.bounds.size.height] #define BACKCOLOR [UIColor colorWithRed:241/255.0 green:241/255.0 blue:241/255.0 alpha:1] #define BARCOLOR [QPUtilities colorWithHexString:@"#242947" alpha:1.f] 全局变量： { BOOL OpenOrClose; dispatch_source_t _timer; int hours; int minites; int secondTotal; int delayTotal; } 时间选择器UIPickView懒加载： -(StellarTimeView *)dateTimeView{ if (_dateTimeView == nil) { _dateTimeView =[[StellarTimeView alloc]initWithFrame:CGRectMake(0, 40, self.dateView.frame.size.width, self.view.bounds.size.height / 2 - 100)]; } return _dateTimeView; } pragma mark – UIPickerViewDateSource - (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView { return 3; } -(NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component { if (component == 0) { return (unsigned)[_hourArray count]; }else if (component == 1){ return 1; }else return (unsigned)[_minuteArray count]; } pragma mark – UIPickerViewDelegate -(CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent:(NSInteger)component { return 60; } -(CGSize)rowSizeForComponent:(NSInteger)component{ CGSize size = CGSizeFromString(@"20"); return size; } -(void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component { if (component == 0) { NSString *_proNameStr = [_hourArray objectAtIndex:(unsigned)row]; hours = [_proNameStr intValue]; }else if (component == 1){ } else { NSString *_proTimeStr = [_minuteArray objectAtIndex:(unsigned)row]; minites = [_proTimeStr intValue]; } } -(NSString*)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component { if (component == 0) { return [_hourArray objectAtIndex:(unsigned)row]; }else if (component == 1){ return @":"; } else { return [_minuteArray objectAtIndex:(unsigned)row]; } } 动画绘制懒加载： -(StellarTimeView *)dateTimeView{ if (_dateTimeView == nil) { _dateTimeView =[[StellarTimeView alloc]initWithFrame:CGRectMake(0, 40, self.dateView.frame.size.width, self.view.bounds.size.height / 2 - 100)]; } return _dateTimeView; } 添加一个navgationbar - (void)setNavigationbar { CGRect screenRect = [[UIScreen mainScreen] bounds]; UINavigationBar *navigationBar = [[UINavigationBar alloc] initWithFrame:CGRectMake(0, 0, screenRect.size.width, 49)]; navigationBar.tintColor = [UIColor blackColor]; navigationBar.backgroundColor = [UIColor greenColor]; //创建 UINavigationItem UINavigationItem * navigationBarTitle = [[UINavigationItem alloc] initWithTitle:@"UINavigationBar"]; [navigationBar pushNavigationItem: navigationBarTitle animated:YES]; [self.view addSubview: navigationBar]; } 注： 动画类已封装只需要传入Percent和progressView定时器的处理- (void)timeHeadle{ if (_timer==nil) { __block int timeout = 0; //倒计时时间 timeout = secondTotal; [self setIsTotalTimeSelect:secondTotal]; if (timeout!=0) { dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue); dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),(uint64_t) 1.0 * NSEC_PER_SEC, 0); //每秒执行 dispatch_source_set_event_handler(_timer, ^{ if(timeout&lt;=0){ //倒计时结束，关闭时界面显示 dispatch_source_cancel(_timer); _timer = nil; dispatch_async(dispatch_get_main_queue(), ^{ [self timeHide]; }); } else{ int hour = (int)(timeout/3600); int minute = (int)(timeout-hour*3600)/60; int second = timeout-hour*3600-minute*60; dispatch_async(dispatch_get_main_queue(), ^{ if (secondTotal == 0) { int total =[self isTotalTimeSelect]; self.dateTimeView.percent = (CGFloat)(total-delayTotal) / total + (CGFloat)(delayTotal- timeout) / total; } else{ self.dateTimeView.percent = (CGFloat)(secondTotal-timeout)/(CGFloat)secondTotal; } if (hour&lt;10) { if (minute&lt;10) { if (second&lt;10) { self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:0%d&quot;,hour,minute,second]; }else{ self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:%d&quot;,hour,minute,second]; } }else { if (second&lt;10) { self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:0%d&quot;,hour,minute,second]; }else{ self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:%d&quot;,hour,minute,second]; } } }else{ if (minute&lt;10) { if (second&lt;10) { self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:0%d&quot;,hour,minute,second]; }else{ self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:0%d:%d&quot;,hour,minute,second]; } }else { if (second&lt;10) { self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:0%d&quot;,hour,minute,second]; }else{ self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;0%d:%d:%d&quot;,hour,minute,second]; } } } }); timeout--; } }); dispatch_resume(_timer); }else{ self.dateTimeView.progressView.text = [NSString stringWithFormat:@&quot;00:00:00&quot;]; } } }]]></content>
      <categories>
        <category>OC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[iOS_CollectionViewCell的增删移]]]></title>
    <url>%2F2017%2F08%2F11%2F%E5%A2%9E%E5%88%A0%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github 地址 今日看到某娱乐项目选择增删移很好玩，周五上午没事就写了一个。 利用CollectionViewCell，将数据持久化保存在infoplist。 再也不怕回到解放前了。主要分[已添加]–[待添加]–[未添加]–[删除添加] CollectionViewCell UIBarButtonItem * rightItem = [[UIBarButtonItem alloc]initWithTitle:@"新增加" style:UIBarButtonItemStylePlain target:self action:@selector(add)]; self.navigationItem.rightBarButtonItem = rightItem; UICollectionViewFlowLayout * layout = [[UICollectionViewFlowLayout alloc]init]; layout.itemSize = CGSizeMake(50, 50); layout.scrollDirection = UICollectionViewScrollDirectionVertical; self.collectionView = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height) collectionViewLayout:layout]; self.collectionView.backgroundColor = [UIColor whiteColor]; self.collectionView.delegate = self; self.collectionView.dataSource = self; [self.collectionView registerNib:[UINib nibWithNibName:@"CollectionViewCell" bundle:nil] forCellWithReuseIdentifier:identifier]; [self.collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:headerId]; 两个数组用来存放已添加的和待添加的 if ([[NSUserDefaults standardUserDefaults]objectForKey:@"one"] == nil) { self.oneArray = [NSMutableArray arrayWithObjects:@"0",@"1",@"2",@"3",@"4",@"5",@"6",@"7",@"8",@"9",@"10",@"11",@"12",@"13",@"14",@"15",@"16",@"17",@"18",@"19",nil]; }else{ id array = [[NSUserDefaults standardUserDefaults]objectForKey:@"one"]; [self.oneArray addObjectsFromArray:array]; } if ( [[NSUserDefaults standardUserDefaults]objectForKey:@"two"] == nil) { self.twoArray = [NSMutableArray arrayWithObjects:@"a",@"b",@"c",@"d",@"e",@"f",@"g",@"h",@"i",@"j", nil]; }else{ id array = [[NSUserDefaults standardUserDefaults]objectForKey:@"two"]; [self.twoArray addObjectsFromArray:array]; } 每次改变后刷新要防止复用 UICollectionReusableView *headerView = [self.collectionView dequeueReusableSupplementaryViewOfKind:kind withReuseIdentifier:headerId forIndexPath:indexPath]; headerView.backgroundColor = [UIColor darkGrayColor]; [headerView.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)]; _titleLab = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width - 50, 40)]; _titleLab.textAlignment = NSTextAlignmentLeft; _titleLab.textColor = [UIColor whiteColor]; [headerView addSubview:self.titleLab]; 编辑状态下进行移动和删除 -(void)edit{ for (CollectionViewCell * cell in self.collectionView.visibleCells) { if (cell.edit == NO) { cell.layer.masksToBounds = NO; cell.layer.shadowOpacity = 0.7f; cell.layer.shadowColor = [UIColor darkGrayColor].CGColor; cell.layer.shadowOffset = CGSizeMake(1.f, 1.f); cell.deleteBtn.hidden = NO; [self.editBtn setTitle:@"完成" forState:UIControlStateNormal]; cell.edit = YES; }else{ cell.edit = NO; cell.deleteBtn.hidden = YES; cell.layer.masksToBounds = YES; [self.editBtn setTitle:@"编辑" forState:UIControlStateNormal]; } } } 添加数据,持久化存储刷新界面 -(void)add{ SCLAlertView * alert = [[SCLAlertView alloc]init]; [alert setHorizontalButtons:YES]; SCLTextView * textField = [alert addTextField:@"Enter your name"]; [alert addButton:@"确定" actionBlock:^(void) { NSLog(@"Text value: %@", textField.text); [self.twoArray addObject:textField.text]; [self.collectionView reloadData]; [[NSUserDefaults standardUserDefaults]setObject:self.twoArray forKey:@"two"]; [[NSUserDefaults standardUserDefaults]synchronize]; }]; [alert showEdit:self title:nil subTitle:@"请输入名称" closeButtonTitle:@"取消" duration:0.0f]; 增删移随时保存数据 [[NSUserDefaults standardUserDefaults]setObject:self.oneArray forKey:@"one"]; [[NSUserDefaults standardUserDefaults]setObject:self.twoArray forKey:@"two"]; [[NSUserDefaults standardUserDefaults]synchronize];]]></content>
      <categories>
        <category>OC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[iOS_自定义tarbar和侧边栏]]]></title>
    <url>%2F2017%2F08%2F03%2F%E8%87%AA%E5%AE%9A%E4%B9%89tarbar%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks. Dome: github 地址 pod RESideMenu vim podfile platform :ios,&apos;8.0&apos; target &apos;SideAndTarbar&apos; do pod &apos;RESideMenu&apos;, &apos;~&gt; 4.0.7&apos; AppDelegate.m添加RESideMenuDelegate didFinishLaunchingWithOptions self.window = [[UIWindow alloc]initWithFrame:[[UIScreen mainScreen ]bounds]]; TableViewController * viewController = [[TableViewController alloc]init]; TarBarViewController * barViewController = [[TarBarViewController alloc]init]; RESideMenu * sideMenu = [[RESideMenu alloc]initWithContentViewController:barViewController leftMenuViewController:viewController rightMenuViewController:nil]; sideMenu.delegate = self; sideMenu.contentViewShadowEnabled = YES; sideMenu.contentViewInPortraitOffsetCenterX = 100.f; sideMenu.contentViewScaleValue = 1.0; sideMenu.menuPreferredStatusBarStyle = UIStatusBarStyleLightContent; sideMenu.bouncesHorizontally = NO; self.window.rootViewController = sideMenu; 自定义tabbar 添加子控制器属性 添加navgationbar 去除tabbar分割线 选中controller后图片和标题改变 -(void)addChildViewController:(UIViewController *)childController title:(NSString *)title image:(UIImage *)image selecteImage:(UIImage *)selectedImage{ UINavigationController * controller = [[UINavigationController alloc]initWithRootViewController:childController]; childController.view.backgroundColor = [UIColor whiteColor]; childController.navigationItem.title = title; [[UITabBar appearance] setShadowImage:[UIImage new]]; [[UITabBar appearance] setBackgroundImage:[[UIImage alloc]init]]; selectedImage = [selectedImage imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]; self.tabBar.tintColor = [UIColor greenColor]; controller.tabBarItem = [[UITabBarItem alloc]initWithTitle:title image:image selectedImage:selectedImage]; [self addChildViewController:controller]; } 添加子控制器 -(void)setNewBar{ OneViewController * one = [[OneViewController alloc]init]; [self addChildViewController:one title:@"MainOne" image:[UIImage imageNamed:@"icon_home_normal"] selecteImage:[UIImage imageNamed:@"icon_home_selected"]]; TwoViewController * two = [[TwoViewController alloc]init]; [self addChildViewController:two title:@"MainTwo" image:[UIImage imageNamed:@"icon_door_normal"] selecteImage:[UIImage imageNamed:@"icon_door_selected"]]; } 在各自类中进行操作就OK 例如： self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc]initWithImage:[UIImage imageNamed:@"icon_sidebar"] style:UIBarButtonItemStylePlain target:self action:@selector(presentLeftMenuViewController:)]; UIButton * button = [[UIButton alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; button.backgroundColor = [UIColor greenColor]; [self.view addSubview:button];]]></content>
      <categories>
        <category>OC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo简单操作]]></title>
    <url>%2F2017%2F07%2F25%2FHexo%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Welcome to my blog. Thanks.打开themes/next/source/css/_custom/custom.styl.参考样式:博客地址 /*标题 */ .post-title{ color: red; } /*内容 */ .post-body{ color: green; } /*author */ .author{ text-align: center; color: red; } /*心photo */ .with-love{ color: red; } /*乐乐 */ .theme-link{ color: red; } .busuanzi-value{ color: rebeccapurple; } Next主题操作 生成新页面 hexo g 发布代码 hexo d 开启调试服务 hexo s –debug 为next主题的主页文章添加阴影效果 打开themes/next/source/css/_schemes/Mist/_posts-expanded.styl文件 找到类.posts-expand下面的.post .post { margin-top: 120px; } 改成: .post { margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); } 添加“Fork me on Github” ribbon 打开themes\next\layout\layout.swig &lt;a href=&quot;你的地址&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; left: 0; border: 0;&quot; src=&quot;https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67&quot; alt=&quot;Fork me on GitHub&quot; data-canonical-src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png&quot;&gt;&lt;/a&gt; 404界面 找到根目录-source 创建HTML文件 打开：commonweal: /404.html &lt;html&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;http://www.princesmall.cn&quot; homePageName=&quot;回到乐乐的主页&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注：如果返回的还是qq主页，请参考我网页源码，毕竟有些长，这只是不body。然后copy到你的404.html下 文章末尾追加版权信息 找到themes/next/layout/_macro/reward.swig 在最上面添加如下代码：（最上面） Hexo插入图片 首先确认根目录下_config.yml 中有 post_asset_folder:true 在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image –save 创建文件hexo new “文件名” 在source下会生成一个和文件名一样的文件夹，图片放在该文件夹下 例如： ![logo](文件名/logo.jpg) 是不是so easy！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>